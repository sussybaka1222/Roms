<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX0FA4A7C860524296835C24A3B1B947E8">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="CollisionGroups">Default^0^1\Plugin_Unselectable_Group^1^2</string>
			<Ref name="CurrentCamera">RBXC4CA890BA1DE43D6AFD8F90DD256E662</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">0</float>
			<bool name="FilteringEnabled">true</bool>
			<float name="Gravity">196.199997</float>
			<token name="InterpolationThrottling">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">true</bool>
			<token name="PhysicsSteppingMethod">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="SignalBehavior">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<OptionalCoordinateFrame name="WorldPivotInternal"></OptionalCoordinateFrame>
		</Properties>
		<Item class="Terrain" referent="RBXC0D682E88023461E8C60CEEE86817E17">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0470588282</R>
					<G>0.329411775</G>
					<B>0.360784322</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Camera" referent="RBXC4CA890BA1DE43D6AFD8F90DD256E662">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>20</Y>
					<Z>20</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>0.707211494</R11>
					<R12>0.707002044</R12>
					<R20>0</R20>
					<R21>-0.707002044</R21>
					<R22>0.707211494</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">6</token>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>0</X>
					<Y>5.85995865</Y>
					<Z>5.85577011</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBXA838FD253F7A4D91B8081E123C9A3F0C">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBXF0E326FF239748B0916ABFD716DF5DCB">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX5ECB634347C3469FB2F51B9858573E8C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBX6C15BFF84CA14DF0913A403A097A79DC">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX8366131C5F7D4C0782B5D3951D5E9D72">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Players" referent="RBXAE1AB903C148490E8AF24F0F1F13BF59">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">false</bool>
			<int name="MaxPlayersInternal">30</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">30</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX14C126FAE8CD4103B88CE6CC30600B3F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBX5D05EB397B224D61B1E45DA3E457D479">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PermissionsService" referent="RBXDDC3DA60605D48E68410F2562F908684">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBX8C1FD078E37A472B94F908C83982CA9A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<string name="SerializedEmulatedPolicyInfo"></string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX5625529468E74F99B4775757441BC801">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int64 name="CommitInflightAuthorId">0</int64>
			<string name="CommitInflightGuid"></string>
			<int name="CommitInflightPlaceVersion">0</int>
			<bool name="EnableScriptCollabByDefaultOnLoad">true</bool>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<int64 name="SrcPlaceId">5493847492</int64>
			<int64 name="SrcUniverseId">1920707755</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBXFB861D52374F42CFB2700FC769E911A0">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">128</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">false</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBXF34660C3F522480C9E3B14E762661A66">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBX8B08BEE8CCE44930845193C4C6AFB969">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX4F0B1231232E4D32BDE3685BD17ABF71">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX6761F14933FC4EB381505001C85879C0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">false</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ScreenGui" referent="RBXF92D15EDEF554252916FF1DE5BE5C30D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<bool name="IgnoreGuiInset">false</bool>
				<string name="Name">Canvas</string>
				<bool name="ResetOnSpawn">false</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<token name="ZIndexBehavior">0</token>
			</Properties>
			<Item class="Frame" referent="RBXD14C858C660844CCA068C45D28C68285">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0.5</X>
						<Y>0.5</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.752941191</R>
						<G>0.737254918</G>
						<B>0.725490212</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0.56078434</R>
						<G>0.552941203</G>
						<B>0.572549045</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">0</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">Canvas</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.5</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>160</XO>
						<YS>0</YS>
						<YO>144</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextButton" referent="RBX13BC3F5A82A647FAB956DDD15B8B23D6">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>0.231372565</G>
							<B>0.160784319</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">44</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">ResetButton</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>-10</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>8</XO>
							<YS>0</YS>
							<YO>8</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">RESET</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UICorner" referent="RBX42D0585231A04DF29E77456893DBAB90">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>1</S>
								<O>0</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIGradient" referent="RBX3EEC8700E90B43A19FF7420A350FE268">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<string name="Name">UIGradient</string>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">45</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
						</Properties>
					</Item>
				</Item>
				<Item class="UIGradient" referent="RBX63B206F61AC644CF84E6047FB7EFA8E2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<ColorSequence name="Color">0 1 1 1 0 1 0.72549 0.72549 0.72549 0 </ColorSequence>
						<bool name="Enabled">true</bool>
						<string name="Name">UIGradient</string>
						<Vector2 name="Offset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="Rotation">90</float>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBXD21225E739984465AAB5D8445A079925">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>0.231372565</G>
							<B>0.160784319</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">44</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">SetSaveStateButton</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>10</XO>
							<YS>0</YS>
							<YO>-10</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>8</XO>
							<YS>0</YS>
							<YO>8</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">SAVE</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UICorner" referent="RBX179EDB886337458E956244E12F6B523D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>1</S>
								<O>0</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIGradient" referent="RBXA6D999736A6D4502BF12F56913C46099">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<string name="Name">UIGradient</string>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">45</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBXF8B61CC650494B808596455D15C6CEDD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">UIPadding</string>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>2</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>2</O>
							</UDim>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX96D3CA3AFB064BEC87384B2A91532B5E">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>0.231372565</G>
							<B>0.160784319</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">44</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">StartSaveButton</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>20</XO>
							<YS>0</YS>
							<YO>-10</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>8</XO>
							<YS>0</YS>
							<YO>8</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">LOAD</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UICorner" referent="RBXB138A89BD51144BD86260BA40544A26B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>1</S>
								<O>0</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIGradient" referent="RBX70A0F8F77B234BAA8752C43C49AFF5D1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<string name="Name">UIGradient</string>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">45</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
						</Properties>
					</Item>
					<Item class="UIPadding" referent="RBX376DF83DC1AB4BD2A1327C477CF7C0D6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">UIPadding</string>
							<UDim name="PaddingBottom">
								<S>0</S>
								<O>2</O>
							</UDim>
							<UDim name="PaddingLeft">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingRight">
								<S>0</S>
								<O>0</O>
							</UDim>
							<UDim name="PaddingTop">
								<S>0</S>
								<O>2</O>
							</UDim>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX56BBBFA035EF407DB698C1F31A4BEF2A">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">Pixels</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBXFE0F21B0C970488FA76C0924F3FED5B2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CanvasManager</string>
					<string name="ScriptGuid">{CC20B0D2-4DE3-4327-A364-2234FBF8548B}</string>
					<ProtectedString name="Source"><![CDATA[local ui = require(game.ReplicatedStorage.UI.init).new()
local main = require(game.ReplicatedStorage.LuaGB.init)
local filebrowser = require(script.filebrowser)
main:reset()

local canvas = script.Parent.Canvas.Pixels

ui:create_canvas(canvas, 159, 143)
filebrowser = filebrowser.init(ui, main)

ui.image:load_image("logo", "https://cdn.discordapp.com/attachments/830545101650526259/830555541876506644/rluagb.png")
ui.image:load_image("dango", "https://cdn.discordapp.com/attachments/830545101650526259/830545294684979230/dango_0.png")
ui.image:load_image("palette_chooser", "https://cdn.discordapp.com/attachments/830545101650526259/830545259523866674/palette_chooser.png")
ui.image:load_image("round_button", "https://cdn.discordapp.com/attachments/830545101650526259/830545262812200970/round_button.png")
ui.image:load_image("pill_button", "https://cdn.discordapp.com/attachments/830545101650526259/830545261126352896/pill_button.png")
ui.image:load_image("d_pad", "https://cdn.discordapp.com/attachments/830545101650526259/830545252669980682/d-pad.png")
ui.image:load_image("folder", "https://cdn.discordapp.com/attachments/830545101650526259/830545254590578698/folder.png")
ui.image:load_image("font", "https://cdn.discordapp.com/attachments/830545101650526259/830545282642346004/5x3font.png")

game:GetService("RunService").Stepped:Connect(function()
	if main.emulator_running then
		main.gameboy:run_until_vblank()
	end	
end)

game:GetService("RunService").RenderStepped:Connect(function()
	if main.emulator_running then
		main:draw_game_screen(0, 0, 2, ui, filebrowser.palettes[filebrowser.palette_index])	
	else
		filebrowser:draw()
	end

	local function rgbToTable(color)
		return {color.r*255,color.g*255,color.b*255}	
	end
	
	main.gameboy.graphics.palette.set_dmg_colors(
		rgbToTable(filebrowser.palettes[filebrowser.palette_index][0]),
		rgbToTable(filebrowser.palettes[filebrowser.palette_index][1]),
		rgbToTable(filebrowser.palettes[filebrowser.palette_index][2]),
		rgbToTable(filebrowser.palettes[filebrowser.palette_index][3])
	)
end)

function input_state(key)
	if not main.emulator_running then
		filebrowser:refresh_items()
		if key == "Start" then
			filebrowser:shift_palette()
		end

		if key == "Select" then	

		end
		if key == "A" then
			local cursor_item = filebrowser.items[filebrowser.cursor_pos + 1]
			if cursor_item == nil then
				return
			end
			if cursor_item.Value == "IMPORT_ROM_ENTRY" then
				game.Players.LocalPlayer.PlayerGui:WaitForChild("ImportScreen"):WaitForChild("Menu").Visible = true
				return
			end
			main:load_game(game.ReplicatedStorage.RawData:InvokeServer(cursor_item.Value))		
		end
		if key == "Up" and filebrowser.cursor_pos > 0 then
			filebrowser.cursor_pos = filebrowser.cursor_pos - 1
			if filebrowser.cursor_pos < filebrowser.scroll_pos + 1 and filebrowser.scroll_pos > 0 then
				filebrowser.scroll_pos = filebrowser.cursor_pos - 1
			end
		end
		if key == "Down" and filebrowser.cursor_pos < #filebrowser.items - 1 then
			filebrowser.cursor_pos = filebrowser.cursor_pos + 1
			if filebrowser.cursor_pos > filebrowser.scroll_pos + 9 then
				filebrowser.scroll_pos = filebrowser.cursor_pos - 9
			end
		end
	end
end

main.gameboy.input.key_pressed = input_state


local StopButton = script.Parent.Canvas.ResetButton

StopButton.MouseButton1Click:Connect(function()
	main:reset()
	main.emulator_running = false
	main.gameboy.input.key_pressed = input_state
end)

local RomImportMenu = game.Players.LocalPlayer.PlayerGui:WaitForChild("ImportScreen"):WaitForChild("Menu")

RomImportMenu.Cancel.MouseButton1Click:Connect(function()
	filebrowser:refresh_items()	
	RomImportMenu.Visible = false
end)

RomImportMenu.RomConfirm.MouseButton1Click:Connect(function()
	game.ReplicatedStorage.SaveROM:InvokeServer(RomImportMenu.RomURL.Text, RomImportMenu.RomName.Text)
	RomImportMenu.RomURL.Text = ""
	RomImportMenu.RomName.Text = ""
	filebrowser:refresh_items()
	RomImportMenu.Visible = false
end)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE0741FF5671348A1914C14BDE8954FD8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">filebrowser</string>
						<string name="ScriptGuid">{E29638FA-4D7D-4DE6-A977-9A5A793DE1C9}</string>
						<ProtectedString name="Source"><![CDATA[local filebrowser = {}
filebrowser.__index = filebrowser

filebrowser.palettes = {}
filebrowser.palette_index = 3
filebrowser.palettes[1] = {[0]=Color3.fromRGB(255, 255, 255), [1]=Color3.fromRGB(192, 192, 192), [2]=Color3.fromRGB(128, 128, 128), [3]=Color3.fromRGB(0, 0, 0)}
filebrowser.palettes[2] = {[0]=Color3.fromRGB(215, 215, 215), [1]=Color3.fromRGB(140, 124, 114), [2]=Color3.fromRGB(100, 82, 73), [3]=Color3.fromRGB(45, 45, 45)}
filebrowser.palettes[3] = {[0]=Color3.fromRGB(224, 248, 208), [1]=Color3.fromRGB(136, 192, 112), [2]=Color3.fromRGB(52, 104, 86), [3]=Color3.fromRGB(8, 24, 32)}


filebrowser.init = function(canvas, main)	
	local filebrowser_new = setmetatable({}, filebrowser)
	filebrowser_new.ui = canvas
	filebrowser_new.gameboy = main
	filebrowser_new.game_screen = {}
	filebrowser_new.frame_counter = 0
	filebrowser_new.cursor_pos = 0
	filebrowser_new.scroll_pos = 0
	filebrowser_new.items = {}
	filebrowser_new:refresh_items()
	
	for y=0,canvas.canvas_height do
		filebrowser_new.game_screen[y] = {}
		for x=0,canvas.canvas_width do
			filebrowser_new.game_screen[y][x] = Color3.fromRGB(255,255,255)
		end
	end
	return filebrowser_new
end

function filebrowser:draw_background(sx, sy)
	for x = 0, self.ui.canvas_width do
		for y = 0, self.ui.canvas_height do
			local tx = math.floor((x + sx) / 8)
			local ty = math.floor((y + sy) / 8)
			if (tx + ty) % 2 == 0 then
				self.game_screen[y][x] = self.palettes[self.palette_index][0]
			else
				self.game_screen[y][x] = self.palettes[self.palette_index][1]
			end
		end
	end
end

function filebrowser:draw_shadow_pixel(x, y)
	local palette = self.palettes[self.palette_index]
	if self.game_screen[y][x] == palette[2] then
		self.game_screen[y][x] = palette[3]
	end
	if self.game_screen[y][x] == palette[1] then
		self.game_screen[y][x] = palette[2]
	end
	if self.game_screen[y][x] == palette[0] then
		self.game_screen[y][x] = palette[1]
	end
end

function filebrowser:draw_shadow(dx, dy, width, height)
	for x = dx, dx + width - 1 do
		for y = dy, dy + height - 1 do
			self:draw_shadow_pixel(x, y)
		end
	end
end

function filebrowser:shadow_box(x, y, width, height)
	local palette = self.palettes[self.palette_index]
	self:draw_shadow(x + 1, y + 1, width, height)
	self:draw_rectangle(x, y, width, height, palette[0], true)
	self:draw_rectangle(x, y, width, height, palette[3])
end

function filebrowser:draw_rectangle(dx, dy, width, height, color, filled)
	for x = dx, dx + width - 1 do
		for y = dy, dy + height - 1 do
			if filled or y == dy or y == dy + height - 1 or x == dx or x == dx + width - 1 then
				self.game_screen[y][x] = color
			end
		end
	end
end

function filebrowser:shift_palette()
	self.palette_index = self.palette_index + 1
	if (self.palette_index > 3) then
		self.palette_index = 1
	end
end

function filebrowser:draw_string(str, dx, dy, color, max_x)
	max_x = max_x or 159
	for i = 1, #str do
		local char = string.byte(str, i)
		if 31 < char and char < 128 then
			char = char - 32
			local font_x = char * 4
			local font_y = 0
			for x = 0, 3 do
				if i * 4 - 4 + x + dx < max_x then
					for y = 0, 5 do
						if y + dy <= 143 then
							local rgb, alpha = self.ui.image:get_pixel(font_x + x + 1, font_y + y + 1, "font")
							if alpha > 0 then
								self.game_screen[y + dy][i * 4 - 4 + x + dx] = color
							end
						end
					end
				end
			end
		end
	end
end

function filebrowser:refresh_items()
	coroutine.wrap(function()
		local roms = game.ReplicatedStorage.GetROMs:InvokeServer()
		for _,rom in pairs(game.ReplicatedStorage.ROMs:GetChildren()) do
			table.insert(roms, rom)
		end
		self.items = {
			{
				["Name"] = "Import ROM",
				["Value"] = "IMPORT_ROM_ENTRY"
			}
		}
		for _,rom in pairs(roms) do
			table.insert(self.items, rom)
		end
	end)()
end

function filebrowser:draw()
	-- queue up everything and then draw.
	local frames = self.frame_counter
	local scroll_amount = math.floor(frames / 8)
	self:draw_background(scroll_amount, scroll_amount * -1)
	self:shadow_box(7, 15, 146, 81)
	self.ui.image.palette = self.palettes[self.palette_index]
	
	-- highlight box
	self:draw_rectangle(8, 17 + ((self.cursor_pos - self.scroll_pos) * 7), 144, 7, self.palettes[self.palette_index][2], true)

	-- Filebrowser / game selection menu
	local y = 18
	local i = 0 - self.scroll_pos
	for _, item in pairs(self.items) do
		if i >= 0 and i < 11 then
			local color = self.palettes[self.palette_index][2]
			if i + self.scroll_pos == self.cursor_pos then
				color = self.palettes[self.palette_index][3]
			end
			self:draw_string(item.Name or item["Name"] or "ERR", 10, y, color, 152)
			y = y + 7
		end
		i = i + 1
	end	
	
	-- Logo
	self.ui.image:draw_image(22, 0, "logo", self.game_screen)
	self.ui.image:draw_image(7, 0, "dango", self.game_screen)
	
	self.ui.image:draw_image(133, 4, "palette_chooser", self.game_screen)
	self.ui.image:draw_image(136, 108, "round_button", self.game_screen)    -- A
	self.ui.image:draw_image(124, 120, "round_button", self.game_screen)    -- B
	self.ui.image:draw_image(86, 114, "pill_button", self.game_screen)     -- Start
	self.ui.image:draw_image(51, 114, "pill_button", self.game_screen)     -- Select
	self.ui.image:draw_image(12, 104, "d_pad", self.game_screen)
	--self.ui.image:draw_image(111, 0, "folder", self.game_screen)
	
	self:draw_string("X", 140, 111, self.palettes[self.palette_index][3])      -- A
	self:draw_string("Z", 128, 123, self.palettes[self.palette_index][3])      -- B
	self:draw_string("ENTER", 92, 117, self.palettes[self.palette_index][3])   -- Start
	self:draw_string("RSHIFT", 55, 117, self.palettes[self.palette_index][3])  -- Select
	
	for y=0,self.ui.canvas_height do
		for x=0,self.ui.canvas_width do
			self.ui:set_canvas_pixel(x, y, self.game_screen[y][x])
		end
	end
	
	self.frame_counter = self.frame_counter + 2
end

return filebrowser]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="UIScale" referent="RBX167A03DF17F64D62B378109CC8D13A60">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">UIScale</string>
					<float name="Scale">3</float>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX63114A01589843D4873ADE4FEE3EF62D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<bool name="IgnoreGuiInset">false</bool>
				<string name="Name">Controller</string>
				<bool name="ResetOnSpawn">true</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<token name="ZIndexBehavior">1</token>
			</Properties>
			<Item class="Frame" referent="RBX3AAC7C28CE1E4FF2A192E803482819A2">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0.5</X>
						<Y>0</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.752941191</R>
						<G>0.737254918</G>
						<B>0.725490212</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0.56078434</R>
						<G>0.552941203</G>
						<B>0.572549045</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">5</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">Controller</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>-99</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>208</XO>
						<YS>0</YS>
						<YO>87</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextButton" referent="RBXC61A8D4B55D44DD08FB525E7864DCC6B">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.427451015</R>
							<G>0.411764741</G>
							<B>0.415686309</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">44</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">Enum.KeyCode.Return</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>85</XO>
							<YS>0</YS>
							<YO>70</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>38</XO>
							<YS>0</YS>
							<YO>14</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">START</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">11</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UICorner" referent="RBX4A75B0BA1503449D8683741BF4C49DDC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>4</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIGradient" referent="RBX8D8D0D0036F84F0AB67D50D976E5F3BC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<string name="Name">UIGradient</string>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">45</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBXD63D4C35FEDF42BDA01C5EEEB69996BE">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.427451015</R>
							<G>0.411764741</G>
							<B>0.415686309</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">44</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">Enum.KeyCode.RightShift</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>44</XO>
							<YS>0</YS>
							<YO>70</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>38</XO>
							<YS>0</YS>
							<YO>14</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">SELECT</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">11</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UICorner" referent="RBX8500123272E14426BD945D5B3108AEE9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>4</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIGradient" referent="RBXB39F56058C87447D8CEF14B9212CF8DA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<string name="Name">UIGradient</string>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">45</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBXD193FF02BE0E42318A46DDD955E802CE">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.549019635</R>
							<G>0.184313729</G>
							<B>0.368627459</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">44</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">Enum.KeyCode.X</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>179</XO>
							<YS>0</YS>
							<YO>13</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>16</XO>
							<YS>0</YS>
							<YO>16</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">A</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">3</int>
					</Properties>
					<Item class="UICorner" referent="RBX95377E3415474DB1A377F27D959D83EF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>1</S>
								<O>0</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIGradient" referent="RBX8E38789AEDAB4580B99E2ABF0C2B5AE2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<string name="Name">UIGradient</string>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">45</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBXFF8F28D4D243425790D2439FB8FDFC55">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.549019635</R>
							<G>0.184313729</G>
							<B>0.368627459</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">44</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">Enum.KeyCode.Z</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>151</XO>
							<YS>0</YS>
							<YO>29</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>16</XO>
							<YS>0</YS>
							<YO>16</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">B</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">3</int>
					</Properties>
					<Item class="UICorner" referent="RBX5025FA4319424372AACE2AB938C00621">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>1</S>
								<O>0</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIGradient" referent="RBX1E5FCCD652524C71AFDDC27067332723">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<string name="Name">UIGradient</string>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">45</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX33BDABED6D8E48B0879E1F36B64B18FB">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.176470593</R>
							<G>0.176470593</G>
							<B>0.184313729</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">DPad</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>22</XO>
							<YS>0</YS>
							<YO>29</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>16</XO>
							<YS>0</YS>
							<YO>16</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="TextButton" referent="RBX99CAD76A730B4E7A894D2C1C9EB2AEDA">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoButtonColor">true</bool>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.176470593</R>
								<G>0.176470593</G>
								<B>0.184313729</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">44</token>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="Modal">false</bool>
							<string name="Name">Enum.KeyCode.A</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-16</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">false</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">&#226;&#134;&#144;</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="UICorner" referent="RBXB70E9C13C83C406D837F7BE82FDD844F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>4</O>
								</UDim>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIGradient" referent="RBXD0CD133042EE460F826B7356ECD24FCC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
								<bool name="Enabled">true</bool>
								<string name="Name">UIGradient</string>
								<Vector2 name="Offset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="Rotation">45</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
							</Properties>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX9D5E458DBE59403DAAFA4049D39FE36D">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoButtonColor">true</bool>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.176470593</R>
								<G>0.176470593</G>
								<B>0.184313729</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">44</token>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="Modal">false</bool>
							<string name="Name">Enum.KeyCode.D</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">false</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">&#226;&#134;&#146;</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="UICorner" referent="RBX7BFF5C53A60C4DBB82EAD1D718CA5961">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>4</O>
								</UDim>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIGradient" referent="RBX3F2C36CB0B5B4DC8B1770A5DF4FDCB36">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
								<bool name="Enabled">true</bool>
								<string name="Name">UIGradient</string>
								<Vector2 name="Offset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="Rotation">45</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
							</Properties>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBXD205A21366CB4D47B765B8C8A1060130">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoButtonColor">true</bool>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.176470593</R>
								<G>0.176470593</G>
								<B>0.184313729</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">44</token>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="Modal">false</bool>
							<string name="Name">Enum.KeyCode.S</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<bool name="RichText">false</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">&#226;&#134;&#147;</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="UICorner" referent="RBX41AEBC8BF8B64E01B355A6FD3D6471C4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>4</O>
								</UDim>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIGradient" referent="RBX812D615A12064E98ACD8C25B8780F641">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
								<bool name="Enabled">true</bool>
								<string name="Name">UIGradient</string>
								<Vector2 name="Offset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="Rotation">45</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
							</Properties>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX9A5C9C21565247B1B329C76887692780">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoButtonColor">true</bool>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.176470593</R>
								<G>0.176470593</G>
								<B>0.184313729</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">44</token>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="Modal">false</bool>
							<string name="Name">Enum.KeyCode.W</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>-16</YO>
							</UDim2>
							<bool name="RichText">false</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">&#226;&#134;&#145;</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
						<Item class="UICorner" referent="RBXD88A7E2DA35543919C8A3B06BE43A2B0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>4</O>
								</UDim>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="UIGradient" referent="RBX8392EE2B83104F0380508D8CDA5CC9E0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
								<bool name="Enabled">true</bool>
								<string name="Name">UIGradient</string>
								<Vector2 name="Offset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="Rotation">45</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX64A0D19C096A454C95812E99E410D074">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.176470593</R>
								<G>0.176470593</G>
								<B>0.184313729</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Cover</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>2</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBXC1A5A3CC626B473DB160C3C210D0D842">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.176470593</R>
								<G>0.176470593</G>
								<B>0.184313729</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Cover</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-2</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX9D4388849E614A5C91FFF7A138E1EC57">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.176470593</R>
								<G>0.176470593</G>
								<B>0.184313729</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Cover</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>2</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBXEA3B5400324A4FEC8A0955D2034D170C">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.176470593</R>
								<G>0.176470593</G>
								<B>0.184313729</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Cover</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>-2</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBXC9F5880025DF4440B9F5D8E7768FEDAB">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.427450985</R>
							<G>0.411764711</G>
							<B>0.41568628</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">44</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">Enum.KeyCode.P</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>126</XO>
							<YS>0</YS>
							<YO>70</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>38</XO>
							<YS>0</YS>
							<YO>14</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">PAUSE</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">11</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UICorner" referent="RBX3BF210F5672745B7BE7C303BBA40FA0A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>4</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="UIGradient" referent="RBX5F4E072E30454C56B84022BE47021DBB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<ColorSequence name="Color">0 1 1 1 0 1 0.866667 0.866667 0.866667 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<string name="Name">UIGradient</string>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">45</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
						</Properties>
					</Item>
				</Item>
				<Item class="UIGradient" referent="RBX78680F2B46BD48698DEA0F7AB6054183">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<ColorSequence name="Color">0 1 1 1 0 1 0.905882 0.905882 0.905882 0 </ColorSequence>
						<bool name="Enabled">true</bool>
						<string name="Name">UIGradient</string>
						<Vector2 name="Offset">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<float name="Rotation">90</float>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBXF7B4B597544746C0911BC195EA33D1C7">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<bool name="IgnoreGuiInset">false</bool>
				<string name="Name">FPSCounterGui</string>
				<bool name="ResetOnSpawn">true</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<int64 name="SourceAssetId">2194390315</int64>
				<BinaryString name="Tags"></BinaryString>
				<token name="ZIndexBehavior">0</token>
			</Properties>
			<Item class="TextLabel" referent="RBX22CD9C16F88C46029B0A12EC7F2F59D2">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>1</X>
						<Y>1</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">
						<R>0.105882362</R>
						<G>0.164705887</G>
						<B>0.207843155</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<token name="Font">44</token>
					<int name="LayoutOrder">0</int>
					<float name="LineHeight">1</float>
					<int name="MaxVisibleGraphemes">-1</int>
					<string name="Name">FPSCounterText</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>1</XS>
						<XO>-3</XO>
						<YS>1</YS>
						<YO>-3</YO>
					</UDim2>
					<bool name="RichText">false</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0.0511753969</XS>
						<XO>0</XO>
						<YS>0.0234332774</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<string name="Text">60 FPS</string>
					<Color3 name="TextColor3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<bool name="TextScaled">true</bool>
					<float name="TextSize">14</float>
					<Color3 name="TextStrokeColor3">
						<R>0</R>
						<G>0</G>
						<B>0</B>
					</Color3>
					<float name="TextStrokeTransparency">0</float>
					<float name="TextTransparency">0</float>
					<token name="TextTruncate">0</token>
					<bool name="TextWrapped">true</bool>
					<token name="TextXAlignment">1</token>
					<token name="TextYAlignment">1</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="LocalScript" referent="RBX0EC3FF13CF1E4B598D42F1AF9E7060B1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FPSCounterScript</string>
						<string name="ScriptGuid">{E3926F35-FC1C-47B9-A77E-2C56EA3373D1}</string>
						<ProtectedString name="Source"><![CDATA[local fps = 0
local rs = game:GetService'RunService'

function updateFPS()
	fps = fps + 1
end

rs.RenderStepped:connect(updateFPS)

while wait'1' do
	script.Parent.Text = fps .." FPS"
	fps = 0
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX707A492B0DD041F0ABC0020BEC7CC0E5">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Controller</string>
				<string name="ScriptGuid">{FE567043-2CE0-4C8C-AD73-CA11E90A12FD}</string>
				<ProtectedString name="Source"><![CDATA[local mouse = game.Players.LocalPlayer:GetMouse()
mouse.Icon = "rbxassetid://6674260576"

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = game.Players.LocalPlayer
local PlayerGui = LocalPlayer.PlayerGui

local ControllerUI = PlayerGui:WaitForChild("Controller")
local Canvas = PlayerGui:WaitForChild("Canvas")


local main = require(game.ReplicatedStorage.LuaGB.init)

RunService.RenderStepped:Connect(function()
	if LocalPlayer and LocalPlayer.PlayerGui and LocalPlayer.PlayerGui:FindFirstChild("Controller") then
		local LastInput = UserInputService:GetLastInputType()

		if LastInput == Enum.UserInputType.Gamepad1 then
			LocalPlayer.PlayerGui.Controller.Enabled = false
		else
			LocalPlayer.PlayerGui.Controller.Enabled = true
		end
	end
end) -- Check if controller is plugged in so we can hide the bottom screen controller.



local input_mappings = {
	["Up"] = {
		["PC"] = "Enum.KeyCode.W",
		
		["Controller"] = "Enum.KeyCode.DPadUp"
	},
	
	["Down"] = {
		["PC"] = "Enum.KeyCode.S",
		
		["Controller"] = "Enum.KeyCode.DPadDown"
	},
	
	["Left"] = {
		["PC"] = "Enum.KeyCode.A",
		
		["Controller"] = "Enum.KeyCode.DPadLeft"
	},
	
	["Right"] = {
		["PC"] = "Enum.KeyCode.D",
		
		["Controller"] = "Enum.KeyCode.DPadRight"
	},
	
	["A"] = {
		["PC"] = "Enum.KeyCode.X",
		
		["Controller"] = "Enum.KeyCode.ButtonA"
	},
	
	["B"] = {
		["PC"] = "Enum.KeyCode.Z",
		
		["Controller"] = "Enum.KeyCode.ButtonB"
	},
	
	["Start"] = {
		["PC"] = "Enum.KeyCode.Return",
		
		["Controller"] = "Enum.KeyCode.ButtonStart"
	},
	
	["Select"] = {
		["PC"] = "Enum.KeyCode.RightShift",
		
		["Controller"] = "Enum.KeyCode.ButtonSelect"
	},
	
	["Pause"] = {
		["PC"] = "Enum.KeyCode.P"
	}
}


function modifyBind(gb_button, new_bind)
	input_mappings[gb_button]["PC"] = new_bind
end

function inputDown(key)
	if (key and not key.KeyCode) then
		key = {["KeyCode"] = key}
	end
	if (not key) then
		return
	end
	if (not main.gameboy or not main.gameboy.input or not main.gameboy.input.keys) then
		return
	end
	
	local gameboy_key
	

	for gb_key, gb_keybinds in pairs(input_mappings) do
		for _, keybind in pairs(gb_keybinds) do
			if keybind == tostring(key.KeyCode) then
				gameboy_key = gb_key
			end
		end
	end
	
	if gameboy_key then
		main.gameboy.input.keys[gameboy_key] = 1
		main.gameboy.input.key_pressed(gameboy_key)
		main.gameboy.input.update()
	end
end

function inputUp(key)
	if (key and not key.KeyCode) then
		key = {["KeyCode"] = key}
	end
	if (not key) then
		return
	end
	if (not main.gameboy or not main.gameboy.input or not main.gameboy.input.keys) then
		return
	end
	if (tostring(key.KeyCode) == "Enum.KeyCode.P") then
		main.emulator_running = not main.emulator_running
	end
	
	local gameboy_key
	
	
	for gb_key, gb_keybinds in pairs(input_mappings) do
		for _, keybind in pairs(gb_keybinds) do
			if keybind == tostring(key.KeyCode) then
				gameboy_key = gb_key
			end
		end
	end

	if gameboy_key then
		main.gameboy.input.keys[gameboy_key] = 0
		main.gameboy.input.update()
	end
	
end

game:GetService("UserInputService").InputBegan:Connect(inputDown)
game:GetService("UserInputService").InputEnded:Connect(inputUp)



for _,button in pairs(ControllerUI:GetDescendants()) do
	if (button:IsA("GuiButton")) and string.find(button.Name, "Enum") then
		button.MouseButton1Down:Connect(function()
			inputDown(button.Name)
		end)
		button.MouseButton1Up:Connect(function()
			inputUp(button.Name)
		end)
	end
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ScreenGui" referent="RBXAC31688E38C14358A31D50C9A26D6C25">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutoLocalize">true</bool>
				<int name="DisplayOrder">0</int>
				<bool name="Enabled">true</bool>
				<bool name="IgnoreGuiInset">false</bool>
				<string name="Name">ImportScreen</string>
				<bool name="ResetOnSpawn">true</bool>
				<Ref name="RootLocalizationTable">null</Ref>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<token name="ZIndexBehavior">1</token>
			</Properties>
			<Item class="Frame" referent="RBXE651692027F94D6CAC03DD6BD74FFEE2">
				<Properties>
					<bool name="Active">false</bool>
					<Vector2 name="AnchorPoint">
						<X>0.5</X>
						<Y>0.5</Y>
					</Vector2>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<token name="AutomaticSize">0</token>
					<Color3 name="BackgroundColor3">
						<R>0.878431439</R>
						<G>0.972549081</G>
						<B>0.815686345</B>
					</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">
						<R>0.203921571</R>
						<G>0.407843143</G>
						<B>0.337254912</B>
					</Color3>
					<token name="BorderMode">0</token>
					<int name="BorderSizePixel">2</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<int name="LayoutOrder">0</int>
					<string name="Name">Menu</string>
					<Ref name="NextSelectionDown">null</Ref>
					<Ref name="NextSelectionLeft">null</Ref>
					<Ref name="NextSelectionRight">null</Ref>
					<Ref name="NextSelectionUp">null</Ref>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>0</XO>
						<YS>0.5</YS>
						<YO>0</YO>
					</UDim2>
					<Ref name="RootLocalizationTable">null</Ref>
					<float name="Rotation">0</float>
					<bool name="Selectable">false</bool>
					<Ref name="SelectionImageObject">null</Ref>
					<UDim2 name="Size">
						<XS>0.227272734</XS>
						<XO>0</XO>
						<YS>0.273058265</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<int64 name="SourceAssetId">-1</int64>
					<token name="Style">0</token>
					<BinaryString name="Tags"></BinaryString>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextBox" referent="RBXB4C7C5E7701942B99A5A500D89276478">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.533333361</R>
							<G>0.752941251</G>
							<B>0.43921572</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.203921571</R>
							<G>0.407843143</G>
							<B>0.337254912</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">2</int>
						<bool name="ClearTextOnFocus">true</bool>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">41</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="MultiLine">false</bool>
						<string name="Name">RomURL</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<Color3 name="PlaceholderColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<string name="PlaceholderText">Enter Rom URL...</string>
						<UDim2 name="Position">
							<XS>0.100000001</XS>
							<XO>0</XO>
							<YS>0.222222224</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<bool name="ShowNativeInput">true</bool>
						<UDim2 name="Size">
							<XS>0.800000012</XS>
							<XO>0</XO>
							<YS>0.088888891</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text"></string>
						<Color3 name="TextColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<bool name="TextEditable">true</bool>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextBox" referent="RBXF0958A5802A5417BA178246568EE7A9C">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.533333361</R>
							<G>0.752941251</G>
							<B>0.43921572</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.203921571</R>
							<G>0.407843143</G>
							<B>0.337254912</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">2</int>
						<bool name="ClearTextOnFocus">true</bool>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">41</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="MultiLine">false</bool>
						<string name="Name">RomName</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<Color3 name="PlaceholderColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<string name="PlaceholderText">Enter Rom Label...</string>
						<UDim2 name="Position">
							<XS>0.100000001</XS>
							<XO>0</XO>
							<YS>0.377777785</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<bool name="ShowNativeInput">true</bool>
						<UDim2 name="Size">
							<XS>0.800000012</XS>
							<XO>0</XO>
							<YS>0.088888891</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text"></string>
						<Color3 name="TextColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<bool name="TextEditable">true</bool>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBXC26BDF7F0A4B4813B1841ED9ED6048A8">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.533333361</R>
							<G>0.752941251</G>
							<B>0.43921572</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.203921571</R>
							<G>0.407843143</G>
							<B>0.337254912</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">2</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">41</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">RomConfirm</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.184</XS>
							<XO>0</XO>
							<YS>0.533333361</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0.632000029</XS>
							<XO>0</XO>
							<YS>0.11999999</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">Confirm</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBXF0ACE7D7521843D6BD215260DF48A253">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>0</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">true</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.533333361</R>
							<G>0.752941251</G>
							<B>0.43921572</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.203921571</R>
							<G>0.407843143</G>
							<B>0.337254912</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">2</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">41</token>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">Cancel</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.184</XS>
							<XO>0</XO>
							<YS>0.720000029</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<UDim2 name="Size">
							<XS>0.632000029</XS>
							<XO>0</XO>
							<YS>0.119999997</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">Cancel</string>
						<Color3 name="TextColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="LocalizationService" referent="RBXAB2B1487D72144DFB6FF15E753F4151B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX2482454509364EFEAE5F1984D40631F9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX556F53874D1E431DA8A53645464269BF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX93D279C753FC4B6890636A51DD2AB407">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX3E87088C09884A739C1DCF95B30DF6EE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Geometry</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX970C47201E7B427C8C08AC11FACBC6AB">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="StringValue" referent="RBXF773E2F441434A77AB8F02302A365890">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<string name="Value">{0CA8B70B-CDF7-40A8-B7F8-F4328A7E4D48}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBXBB3B33686D3D4DD6A57CD563EB4E40D0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX2C87DAD942FC4582B97CAE357F12DE34">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX992CFC14A06B4B4B92F79B401647DB17">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX81AC5AA2485C46E1A50994C44B3ED38E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXC943B1494A0B474E9D6A907AA5C176AF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXAA2454067B784025BAC56C412CE80DA3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBXCCD750E8BE0D47AFAFC3152EC330FDEC">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX09628793C42C478FBE0B174D27B1C582">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="RBXFD50F1D8CB724848B42CA3DDF6058AC2">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AnalyticsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX993F842962E14DCB8DA235E3022EF6EF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="RBXD5E822F561AC4622951795F893325F24">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBXF2FD91AF8E1A488CAE9C64B26985F443">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RawDataRequest</string>
				<string name="ScriptGuid">{6A431750-9D6C-459F-95C3-8778BA60D1C6}</string>
				<ProtectedString name="Source"><![CDATA[game.ReplicatedStorage.RawData.OnServerInvoke = function(player, url)
	local res = game:GetService("HttpService"):GetAsync(url)
	return res
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX76B4FFCAD5824D2E835ED139F482A273">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DataHandler</string>
				<string name="ScriptGuid">{42B06BB1-8458-4EDB-B38C-0F63CC612254}</string>
				<ProtectedString name="Source"><![CDATA[
local Players = game:GetService("Players")

local HttpService = game:GetService("HttpService")
local DataStoreService = game:GetService("DataStoreService")

local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")


-- DATASTORES

local ROMStore = DataStoreService:GetDataStore("ROMStorage")
local saveStateStore = DataStoreService:GetDataStore("SaveState")


function playerJoined(player)
	local rom_folder = Instance.new("Folder")
	rom_folder.Name = player.Name
	rom_folder.Parent = ServerStorage.PlayerROMs
	
	local stored_roms = ROMStore:GetAsync("ROMs_" .. player.UserId)
	if (stored_roms) then
		stored_roms = game:GetService("HttpService"):JSONDecode(stored_roms)
	else
		stored_roms = {}
	end
	
	for _, stored_rom in pairs(stored_roms) do
		local new_rom = Instance.new("StringValue")
		
		new_rom.Name = stored_rom.Name
		new_rom.Value = stored_rom.Value
	end
end

function playerLeaving(player)
	if ServerStorage.PlayerROMs:FindFirstChild(player.Name) then
		local compiled_roms = {}
		
		for _, rom in pairs(ServerStorage.PlayerROMs[player.Name]:GetChildren()) do
			table.insert(compiled_roms, {Name = rom.Name, Value = rom.Value})
		end
		
		ROMStore:SetAsync("ROMs_" .. player.UserId, HttpService:JSONEncode(compiled_roms))
		ServerStorage.PlayerROMs[player.Name]:Destroy()
	end
end


ReplicatedStorage.GetROMs.OnServerInvoke = function(player)
	local compiled_roms = {}
	
	for _, rom in pairs(ServerStorage.PlayerROMs[player.Name]:GetChildren()) do
		table.insert(compiled_roms, {Name = rom.Name, Value = rom.Value})
	end
	
	return compiled_roms
end

ReplicatedStorage.SaveROM.OnServerInvoke = function(player, rom_url, rom_label)
	if ServerStorage.PlayerROMs:FindFirstChild(player.Name) then
		local new_rom = Instance.new("StringValue")

		if (string.find(rom_label, "gb")) then
			new_rom.Name = rom_label
		else
			new_rom.Name = rom_label .. ".gb"
		end
		
		new_rom.Value = rom_url
		new_rom.Parent = ServerStorage.PlayerROMs:FindFirstChild(player.Name)
	end
end

ReplicatedStorage.SetSaveState.OnServerInvoke = function(player, stateData)
	saveStateStore:SetAsync("Player_"..player.UserId, stateData)
end

ReplicatedStorage.GetSaveState.OnServerInvoke = function(player, stateData)
	return saveStateStore:GetAsync("Player_"..player.UserId)
end

-- Get players that got put into the game before the PlayerAdded function could be called.
for _, player in pairs(Players:GetChildren()) do
	playerJoined(player)
end

Players.PlayerAdded:Connect(playerJoined)
Players.PlayerRemoving:Connect(playerLeaving)]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX7545549B1C2443B6A3D126FF76731694">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PlayerPrevention</string>
				<string name="ScriptGuid">{EFFA7F72-250F-4745-BD62-2319D23A406B}</string>
				<ProtectedString name="Source"><![CDATA[function playerAdded(player)
	player.CanLoadCharacterAppearance = false
	for _,v in pairs(game.StarterGui:GetChildren()) do
		v:Clone().Parent = player:WaitForChild("PlayerGui")
	end
end
game.Players.PlayerAdded:Connect(playerAdded)
for _,player in pairs(game.Players:GetChildren()) do
	playerAdded(player)
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBX70B56170FE614D9F97244F62B53F9611">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBXE2690052F1C444F7AC60061E36452D6D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">PlayerROMs</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="ReplicatedStorage" referent="RBX0DDA2D2C5E2244DD879B82A4684A0E5F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBXFDF03350377445489E865B82F96E5BB2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">LuaGB</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXF75A107A8EAD4E929AE94FD5CDED9C58">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">gameboy</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXD91AB8059FF94F49A6B38E7131034D37">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">graphics</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXE28D365B739E4139A8D1DA234C1E68C5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">cache</string>
							<string name="ScriptGuid">{BCF5E3BE-9E7D-4121-A53E-0DF617E34CC2}</string>
							<ProtectedString name="Source"><![CDATA[local Cache = {}

function Cache.new(graphics)
	local cache = {}

	cache.tiles = {}
	cache.tiles_h_flipped = {}
	cache.map_0 = {}
	cache.map_1 = {}
	cache.map_0_attr = {}
	cache.map_1_attr = {}
	cache.oam = {}

	cache.reset = function()
		for i = 0, 768 - 1 do
			cache.tiles[i] = {}
			cache.tiles_h_flipped[i] = {}
			for x = 0, 7 do
				cache.tiles[i][x] = {}
				cache.tiles_h_flipped[i][x] = {}
				for y = 0, 7 do
					cache.tiles[i][x][y] = 0
					cache.tiles_h_flipped[i][x][y] = 0
				end
			end
		end

		for x = 0, 31 do
			cache.map_0[x] = {}
			cache.map_1[x] = {}
			cache.map_0_attr[x] = {}
			cache.map_1_attr[x] = {}
			for y = 0, 31 do
				cache.map_0[x][y] = cache.tiles[0]
				cache.map_1[x][y] = cache.tiles[0]
				cache.map_0_attr[x][y] = {}
				cache.map_1_attr[x][y] = {}

				if graphics.gameboy.type == graphics.gameboy.types.color then
					cache.map_0_attr[x][y].palette = graphics.palette.color_bg[0]
				else
					cache.map_0_attr[x][y].palette = graphics.palette.bg
				end
				cache.map_0_attr[x][y].bank = 0
				cache.map_0_attr[x][y].horizontal_flip = false
				cache.map_0_attr[x][y].vertical_flip = false
				cache.map_0_attr[x][y].priority = false

				if graphics.gameboy.type == graphics.gameboy.types.color then
					cache.map_1_attr[x][y].palette = graphics.palette.color_bg[0]
				else
					cache.map_1_attr[x][y].palette = graphics.palette.bg
				end
				cache.map_1_attr[x][y].bank = 0
				cache.map_1_attr[x][y].horizontal_flip = false
				cache.map_1_attr[x][y].vertical_flip = false
				cache.map_1_attr[x][y].priority = false
			end
		end

		for i = 0, 39 do
			cache.oam[i] = {}
			cache.oam[i].x = 0
			cache.oam[i].y = 0
			cache.oam[i].tile = cache.tiles[0]
			cache.oam[i].upper_tile = cache.tiles[0]
			cache.oam[i].lower_tile = cache.tiles[1]
			cache.oam[i].bg_priority = false
			cache.oam[i].horizontal_flip = false
			cache.oam[i].vertical_flip = false
			if graphics.gameboy.type == graphics.gameboy.types.color then
				cache.oam[i].palette = graphics.palette.color_obj[0]
			else
				cache.oam[i].palette = graphics.palette.bg
			end
		end
	end

	cache.refreshOamEntry = function(index)
		local y = graphics.oam[0xFE00 + index * 4 + 0] - 16
		local x = graphics.oam[0xFE00 + index * 4 + 1] - 8
		local tile_index = graphics.oam[0xFE00 + index * 4 + 2]
		local flags = graphics.oam[0xFE00 + index * 4 + 3]

		cache.oam[index].x = x
		cache.oam[index].y = y
		local vram_bank = 0
		if graphics.gameboy.type == graphics.gameboy.types.color then
			vram_bank = bit32.rshift(bit32.band(0x08, flags), 3)
		end
		cache.oam[index].bg_priority = bit32.band(0x80, flags) ~= 0
		cache.oam[index].vertical_flip = bit32.band(0x40, flags) ~= 0
		cache.oam[index].horizontal_flip = bit32.band(0x20, flags) ~= 0
		if graphics.gameboy.type == graphics.gameboy.types.color then
			local palette_index = bit32.band(0x07, flags)
			cache.oam[index].palette = graphics.palette.color_obj[palette_index]
		else
			if bit32.band(0x10, flags) ~= 0 then
				cache.oam[index].palette = graphics.palette.obj1
			else
				cache.oam[index].palette = graphics.palette.obj0
			end
		end
		if cache.oam[index].horizontal_flip then
			cache.oam[index].tile =       cache.tiles_h_flipped[tile_index + (384 * vram_bank)]
			cache.oam[index].upper_tile = cache.tiles_h_flipped[bit32.band(tile_index, 0xFE) + (384 * vram_bank)]
			cache.oam[index].lower_tile = cache.tiles_h_flipped[bit32.band(tile_index, 0xFE) + 1 + (384 * vram_bank)]
		else
			cache.oam[index].tile =       cache.tiles[tile_index + (384 * vram_bank)]
			cache.oam[index].upper_tile = cache.tiles[bit32.band(tile_index, 0xFE) + (384 * vram_bank)]
			cache.oam[index].lower_tile = cache.tiles[bit32.band(tile_index, 0xFE) + 1 + (384 * vram_bank)]
		end

	end

	cache.refreshAttributes = function(map_attr, x, y, address)
		local data = graphics.vram[address + (16 * 1024)]
		if graphics.gameboy.type == graphics.gameboy.types.color then
			map_attr[x][y].palette = graphics.palette.color_bg[bit32.band(data, 0x07)]
		else
			map_attr[x][y].palette = graphics.palette.bg
		end
		map_attr[x][y].bank = bit32.rshift(bit32.band(data, 0x08), 3)
		map_attr[x][y].horizontal_flip = bit32.rshift(bit32.band(data, 0x20), 5) ~= 0
		map_attr[x][y].vertical_flip = bit32.rshift(bit32.band(data, 0x40), 6) ~= 0
		map_attr[x][y].priority = bit32.rshift(bit32.band(data, 0x80), 7) ~= 0
	end

	cache.refreshTile = function(address, bank)
		-- Update the cached tile data
		local tile_index = math.floor((address - 0x8000) / 16) + (384 * bank)
		local y = math.floor((address % 16) / 2)
		-- kill the lower bit
		address = bit32.band(address, 0xFFFE)
		local lower_bits = graphics.vram[address + (16 * 1024 * bank)]
		local upper_bits = graphics.vram[address + (16 * 1024 * bank) + 1]
		for x = 0, 7 do
			local palette_index = bit32.band(bit32.rshift(lower_bits, 7 - x), 0x1) + (bit32.band(bit32.rshift(upper_bits, 7 - x), 0x1) * 2)
			cache.tiles[tile_index][x][y] = palette_index
			cache.tiles_h_flipped[tile_index][7 - x][y] = palette_index
		end
	end

	cache.refreshTiles = function()
		for i = 0, 384 - 1 do
			for y = 0, 7 do
				cache.refreshTile(0x8000 + i * 16 + y * 2, 0)
				cache.refreshTile(0x8000 + i * 16 + y * 2, 1)
			end
		end
	end

	cache.refreshTileIndex = function(x, y, address, map, attr)
		local tile_index = graphics.vram[address + (y * 32) + x]
		if graphics.registers.tile_select == 0x9000 then
			if tile_index > 127 then
				tile_index = tile_index - 256
			end
			-- add offset to re-root at tile 256 (so effectively, we read from tile 192 - 384)
			tile_index = tile_index + 256
		end
		if attr[x][y].bank == 1 then
			tile_index = tile_index + 384
		end
		if attr[x][y].horizontal_flip then
			map[x][y] = cache.tiles_h_flipped[tile_index]
		else
			map[x][y] = cache.tiles[tile_index]
		end
	end

	cache.refreshTileMap = function(address, map, attr)
		for x = 0, 31 do
			for y = 0, 31 do
				cache.refreshTileIndex(x, y, address, map, attr)
			end
		end
	end

	cache.refreshTileMaps = function()
		cache.refreshTileMap(0x9800, cache.map_0, cache.map_0_attr)
		cache.refreshTileMap(0x9C00, cache.map_1, cache.map_1_attr)
	end

	cache.refreshTileAttributes = function()
		for x = 0, 31 do
			for y = 0, 31 do
				cache.refreshAttributes(cache.map_0_attr, x, y, 0x9800 + (y * 32) + x)
				cache.refreshAttributes(cache.map_1_attr, x, y, 0x9C00 + (y * 32) + x)
			end
		end
	end

	cache.refreshAll = function()
		cache.refreshTiles()
		cache.refreshTileAttributes()
		cache.refreshTileMaps()
	end

	return cache
end

return Cache
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX155395265F0945AC9C34041287059FFB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">init</string>
							<string name="ScriptGuid">{C151C649-4F7C-4D6D-AC88-54D8BB9C9B5D}</string>
							<ProtectedString name="Source"><![CDATA[local gameboy = game.ReplicatedStorage.LuaGB.gameboy

local Cache = require(gameboy.graphics.cache)
local Palette = require(gameboy.graphics.palette)
local Registers = require(gameboy.graphics.registers)

local Graphics = {}

function Graphics.new(modules)
	local interrupts = modules.interrupts
	local dma = modules.dma
	local io = modules.io
	local memory = modules.memory
	local timers = modules.timers
	local processor = modules.processor

	local graphics = {}

	graphics.cache = Cache.new(graphics)
	graphics.palette = Palette.new(graphics, modules)
	graphics.registers = Registers.new(graphics, modules, graphics.cache)

	--just for shortening access
	local ports = io.ports

	-- Internal Variables
	graphics.vblank_count = 0
	graphics.last_edge = 0
	graphics.next_edge = 0
	graphics.lcdstat = false

	graphics.game_screen = {}

	graphics.clear_screen = function()
		print("CLEARING SCREEN!")
		for y = 0, 143 do
			graphics.game_screen[y] = {}
			for x = 0, 159 do
				graphics.game_screen[y][x] = {255, 255, 255}
			end
		end
	end

	graphics.lcd = {}

	-- Initialize VRAM blocks in main memory
	graphics.vram = memory.generate_block(16 * 2 * 1024, 0x8000)
	graphics.vram.bank = 0
	graphics.vram_map = {}
	graphics.vram_map.mt = {}
	graphics.vram_map.mt.__index = function(table, address)
		return graphics.vram[address + (16 * 1024 * graphics.vram.bank)]
	end
	graphics.vram_map.mt.__newindex = function(table, address, value)
		graphics.vram[address + (16 * 1024 * graphics.vram.bank)] = value
		if address >= 0x8000 and address <= 0x97FF then
			graphics.cache.refreshTile(address, graphics.vram.bank)
		end
		if address >= 0x9800 and address <= 0x9BFF then
			local x = address % 32
			local y = math.floor((address - 0x9800) / 32)
			if graphics.vram.bank == 1 then
				graphics.cache.refreshAttributes(graphics.cache.map_0_attr, x, y, address)
			end
			graphics.cache.refreshTileIndex(x, y, 0x9800, graphics.cache.map_0, graphics.cache.map_0_attr)
		end
		if address >= 0x9C00 and address <= 0x9FFF then
			local x = address % 32
			local y = math.floor((address - 0x9C00) / 32)
			if graphics.vram.bank == 1 then
				graphics.cache.refreshAttributes(graphics.cache.map_1_attr, x, y, address)
			end
			graphics.cache.refreshTileIndex(x, y, 0x9C00, graphics.cache.map_1, graphics.cache.map_1_attr)
		end
	end
	setmetatable(graphics.vram_map, graphics.vram_map.mt)
	memory.map_block(0x80, 0x9F, graphics.vram_map, 0)

	graphics.oam_raw = memory.generate_block(0xA0, 0xFE00)
	graphics.oam = {}
	graphics.oam.mt = {}
	graphics.oam.mt.__index = function(table, address)
		if address <= 0xFE9F then
			return graphics.oam_raw[address]
		end
		-- out of range? So sorry, return nothing
		return 0x00
	end
	graphics.oam.mt.__newindex = function(table, address, byte)
		if address <= 0xFE9F then
			graphics.oam_raw[address] = byte
			graphics.cache.refreshOamEntry(math.floor((address - 0xFE00) / 4))
		end
		-- out of range? So sorry, discard the write
		return
	end
	setmetatable(graphics.oam, graphics.oam.mt)
	memory.map_block(0xFE, 0xFE, graphics.oam, 0)

	io.write_logic[0x4F] = function(byte)
		if graphics.gameboy.type == graphics.gameboy.types.color then
			io.ram[0x4F] = bit32.band(0x1, byte)
			graphics.vram.bank = bit32.band(0x1, byte)
		else
			-- Not sure if the write mask should apply in DMG / SGB mode
			io.ram[0x4F] = byte
		end
	end

	graphics.initialize = function(gameboy)
		graphics.gameboy = gameboy
		graphics.registers.status.SetMode(2)
		graphics.clear_screen()
		graphics.reset()
	end

	graphics.reset = function()
		graphics.cache.reset()
		graphics.palette.reset()

		-- zero out all of VRAM:
		for i = 0x8000, (0x8000 + (16 * 2 * 1024) - 1) do
			graphics.vram[i] = 0
		end

		-- zero out all of OAM
		for i = 0xFE00, 0xFE9F do
			graphics.oam[i] = 0
		end

		graphics.vblank_count = 0
		graphics.last_edge = 0
		graphics.vram.bank = 0
		graphics.lcdstat = false

		graphics.clear_screen()
		graphics.registers.status.SetMode(2)
	end

	graphics.save_state = function()
		local state = {}

		state.vram = {}
		for i = 0x8000, (0x8000 + (16 * 2 * 1024) - 1) do
			state.vram[i] = graphics.vram[i]
		end

		state.vram_bank = graphics.vram.bank

		state.oam = {}
		for i = 0xFE00, 0xFE9F do
			state.oam[i] = graphics.oam[i]
		end

		state.vblank_count = graphics.vblank_count
		state.last_edge = graphics.last_edge
		state.lcdstat = graphics.lcdstat
		state.mode = graphics.registers.status.mode

		state.palette = {}
		state.palette.bg   = graphics.palette.bg
		state.palette.obj0 = graphics.palette.obj0
		state.palette.obj1 = graphics.palette.obj1

		state.color_bg = {}
		state.color_obj = {}
		state.color_bg_raw = {}
		state.color_obj_raw = {}

		for p = 0, 7 do
			state.color_bg[p] = graphics.palette.color_bg[p]
			state.color_obj[p] = graphics.palette.color_obj[p]
		end

		for i = 0, 63 do
			state.color_bg_raw[i] = graphics.palette.color_bg_raw[i]
			state.color_obj_raw[i] = graphics.palette.color_obj_raw[i]
		end

		return state
	end

	graphics.load_state = function(state)
		for i = 0x8000, (0x8000 + (16 * 2 * 1024) - 1) do
			graphics.vram[i] = state.vram[i]
		end

		graphics.vram.bank = state.vram_bank

		for i = 0xFE00, 0xFE9F do
			graphics.oam[i] = state.oam[i]
		end
		graphics.vblank_count = state.vblank_count
		graphics.last_edge = state.last_edge
		graphics.lcdstat = state.lcdstat
		graphics.registers.status.mode = state.mode

		graphics.palette.bg   = state.palette.bg
		graphics.palette.obj0 = state.palette.obj0
		graphics.palette.obj1 = state.palette.obj1

		for p = 0, 7 do
			graphics.palette.color_bg[p] = state.color_bg[p]
			graphics.palette.color_obj[p] = state.color_obj[p]
		end

		for i = 0, 63 do
			graphics.palette.color_bg_raw[i] = state.color_bg_raw[i]
			graphics.palette.color_obj_raw[i] = state.color_obj_raw[i]
		end

		graphics.cache.refreshAll()
		io.write_logic[ports.STAT](io.ram[ports.STAT])
		io.write_logic[ports.LCDC](io.ram[ports.LCDC])
	end

	local time_at_this_mode = function()
		return timers.system_clock - graphics.last_edge
	end

	local scanline_data = {}
	scanline_data.x = 0
	scanline_data.bg_tile_x = 0
	scanline_data.bg_tile_y = 0
	scanline_data.sub_x = 0
	scanline_data.sub_y = 0
	scanline_data.active_tile = nil
	scanline_data.active_attr = nil
	scanline_data.current_map = nil
	scanline_data.current_map_attr = nil
	scanline_data.window_active = false
	scanline_data.bg_index = {}
	scanline_data.bg_priority = {}
	scanline_data.active_palette = nil

	graphics.refresh_lcdstat = function()
		local lcdstat = false
		local status = graphics.registers.status

		lcdstat =
			(status.lyc_interrupt_enabled and io.ram[ports.LY] == io.ram[ports.LYC]) or
			(status.oam_interrupt_enabled and status.mode == 2) or
			(status.vblank_interrupt_enabled and status.mode == 1) or
			(status.hblank_interrupt_enabled and status.mode == 0)

		-- If this is a *rising* edge, raise the LCDStat interrupt
		if graphics.lcdstat == false and lcdstat == true then
			interrupts.raise(interrupts.LCDStat)
		end

		graphics.lcdstat = lcdstat
	end

	io.write_logic[ports.LY] = function(byte)
		-- LY, writes reset the counter
		io.ram[ports.LY] = 0
		graphics.refresh_lcdstat()
	end

	io.write_logic[ports.LYC] = function(byte)
		-- LY, writes reset the counter
		io.ram[ports.LYC] = byte
		graphics.refresh_lcdstat()
	end

	-- HBlank: Period between scanlines
	local handle_mode = {}
	handle_mode[0] = function()
		if timers.system_clock - graphics.last_edge > 204 then
			graphics.last_edge = graphics.last_edge + 204
			io.ram[ports.LY] = io.ram[ports.LY] + 1
			if io.ram[ports.LY] == io.ram[ports.LYC] then
				-- set the LY compare bit
				io.ram[ports.STAT] = bit32.bor(io.ram[ports.STAT], 0x4)
			else
				-- clear the LY compare bit
				io.ram[ports.STAT] = bit32.band(io.ram[ports.STAT], 0xFB)
			end

			if io.ram[ports.LY] >= 144 then
				graphics.registers.status.SetMode(1)
				graphics.vblank_count = graphics.vblank_count + 1
				interrupts.raise(interrupts.VBlank)
			else
				graphics.registers.status.SetMode(2)
			end

			graphics.refresh_lcdstat()
		else
			graphics.next_edge = graphics.last_edge + 204
		end
	end

	--VBlank: nothing to do except wait for the next frame
	handle_mode[1] = function()
		if timers.system_clock - graphics.last_edge > 456 then
			graphics.last_edge = graphics.last_edge + 456
			io.ram[ports.LY] = io.ram[ports.LY] + 1
			graphics.refresh_lcdstat()
		else
			graphics.next_edge = graphics.last_edge + 456
		end

		if io.ram[ports.LY] >= 154 then
			io.ram[ports.LY] = 0
			graphics.initialize_frame()
			graphics.registers.status.SetMode(2)
			graphics.refresh_lcdstat()
		end

		if io.ram[ports.LY] == io.ram[ports.LYC] then
			-- set the LY compare bit
			io.ram[ports.STAT] = bit32.bor(io.ram[ports.STAT], 0x4)
		else
			-- clear the LY compare bit
			io.ram[ports.STAT] = bit32.band(io.ram[ports.STAT], 0xFB)
		end
	end

	-- OAM Read: OAM cannot be accessed
	handle_mode[2] = function()
		if timers.system_clock - graphics.last_edge > 80 then
			graphics.last_edge = graphics.last_edge + 80
			graphics.initialize_scanline()
			graphics.registers.status.SetMode(3)
			graphics.refresh_lcdstat()
		else
			graphics.next_edge = graphics.last_edge + 80
		end
	end
	-- VRAM Read: Neither VRAM, OAM, nor CGB palettes can be read
	handle_mode[3] = function()
		local duration = timers.system_clock - graphics.last_edge
		graphics.draw_next_pixels(duration)
		if timers.system_clock - graphics.last_edge > 172 then
			graphics.last_edge = graphics.last_edge + 172
			graphics.draw_sprites_into_scanline(io.ram[ports.LY], scanline_data.bg_index, scanline_data.bg_priority)
			graphics.registers.status.SetMode(0)
			-- If enabled, fire an HBlank interrupt
			graphics.refresh_lcdstat()
			-- If the hblank dma is active, copy the next block
			dma.do_hblank()
		else
			graphics.next_edge = graphics.last_edge + 172
		end
	end

	graphics.update = function()
		if graphics.registers.display_enabled then
			handle_mode[graphics.registers.status.mode]()
		else
			-- erase our clock debt, so we don't do stupid timing things when the
			-- display is enabled again later
			graphics.last_edge = timers.system_clock
			graphics.next_edge = timers.system_clock
			graphics.registers.status.SetMode(0)
			io.ram[ports.LY] = 0
			graphics.refresh_lcdstat()
		end
	end

	local function plot_pixel(buffer, x, y, r, g, b)
		buffer[y][x][1] = r
		buffer[y][x][2] = g
		buffer[y][x][3] = b
	end

	local frame_data = {}
	frame_data.window_pos_y = 0
	frame_data.window_draw_y = 0

	graphics.initialize_frame = function()
		-- latch WY at the beginning of the *frame*
		frame_data.window_pos_y = io.ram[ports.WY]
		frame_data.window_draw_y = 0
	end

	graphics.initialize_scanline = function()
		scanline_data.x = 0

		scanline_data.bg_tile_x = math.floor(io.ram[ports.SCX] / 8)
		scanline_data.bg_tile_y = math.floor((io.ram[ports.LY] + io.ram[ports.SCY]) / 8)
		if scanline_data.bg_tile_y >= 32 then
			scanline_data.bg_tile_y = scanline_data.bg_tile_y - 32
		end

		scanline_data.sub_x = io.ram[ports.SCX] % 8
		scanline_data.sub_y = (io.ram[ports.LY] + io.ram[ports.SCY]) % 8

		scanline_data.current_map = graphics.registers.background_tilemap
		scanline_data.current_map_attr = graphics.registers.background_attr

		scanline_data.active_attr = scanline_data.current_map_attr[scanline_data.bg_tile_x][scanline_data.bg_tile_y]
		scanline_data.active_tile = scanline_data.current_map[scanline_data.bg_tile_x][scanline_data.bg_tile_y]
		scanline_data.window_active = false
	end

	graphics.switch_to_window = function()
		local ly = io.ram[ports.LY]
		local w_x = io.ram[ports.WX] - 7
		if graphics.registers.window_enabled and scanline_data.x >= w_x and ly >= frame_data.window_pos_y then
			-- switch to window map
			scanline_data.current_map = graphics.registers.window_tilemap
			scanline_data.current_map_attr = graphics.registers.window_attr
			scanline_data.bg_tile_x = math.floor((scanline_data.x - w_x) / 8)
			scanline_data.bg_tile_y = math.floor(frame_data.window_draw_y / 8)
			scanline_data.sub_x = (scanline_data.x - w_x) % 8
			scanline_data.sub_y = (frame_data.window_draw_y) % 8
			frame_data.window_draw_y = frame_data.window_draw_y + 1
			if frame_data.window_draw_y > 143 then
				frame_data.window_draw_y = 143
			end

			scanline_data.active_attr = scanline_data.current_map_attr[scanline_data.bg_tile_x][scanline_data.bg_tile_y]
			scanline_data.active_tile = scanline_data.current_map[scanline_data.bg_tile_x][scanline_data.bg_tile_y]
			scanline_data.window_active = true
		end
	end

	graphics.draw_next_pixels = function(duration)
		local ly = io.ram[ports.LY]
		local game_screen = graphics.game_screen

		while scanline_data.x < duration and scanline_data.x < 160 do
			local dx = scanline_data.x
			if not scanline_data.window_active then
				graphics.switch_to_window()
			end

			local bg_index = 0 --default, in case no background is enabled
			if graphics.registers.background_enabled then
				-- DRAW BG PIXEL HERE
				local sub_x = scanline_data.sub_x
				local sub_y = scanline_data.sub_y
				bg_index = scanline_data.active_tile[sub_x][sub_y]
				local active_palette = scanline_data.active_attr.palette[bg_index]
				game_screen[ly][dx][1] = active_palette[1]
				game_screen[ly][dx][2] = active_palette[2]
				game_screen[ly][dx][3] = active_palette[3]
			end

			scanline_data.bg_index[scanline_data.x] = bg_index
			scanline_data.bg_priority[scanline_data.x] = scanline_data.active_attr.priority

			scanline_data.x = scanline_data.x  + 1
			scanline_data.sub_x = scanline_data.sub_x  + 1
			if scanline_data.sub_x > 7 then
				-- fetch next tile
				scanline_data.sub_x = 0
				scanline_data.bg_tile_x = scanline_data.bg_tile_x + 1
				if scanline_data.bg_tile_x >= 32 then
					scanline_data.bg_tile_x = scanline_data.bg_tile_x - 32
				end
				if not scanline_data.window_active then
					scanline_data.sub_y = (ly + io.ram[ports.SCY]) % 8
					scanline_data.bg_tile_y = math.floor((ly + io.ram[ports.SCY]) / 8)
					if scanline_data.bg_tile_y >= 32 then
						scanline_data.bg_tile_y = scanline_data.bg_tile_y - 32
					end
				end

				local tile_attr = scanline_data.current_map_attr[scanline_data.bg_tile_x][scanline_data.bg_tile_y]
				if tile_attr.vertical_flip then
					scanline_data.sub_y = 7 - scanline_data.sub_y
				end

				scanline_data.active_attr = scanline_data.current_map_attr[scanline_data.bg_tile_x][scanline_data.bg_tile_y]
				scanline_data.active_tile = scanline_data.current_map[scanline_data.bg_tile_x][scanline_data.bg_tile_y]
			end
		end
	end

	graphics.getIndexFromTilemap = function(map, tile_data, x, y)
		local tile_x = bit32.rshift(x, 3)
		local tile_y = bit32.rshift(y, 3)
		local tile_index = map[tile_x][tile_y]

		local subpixel_x = x - (tile_x * 8)
		local subpixel_y = y - (tile_y * 8)

		if tile_data == 0x9000 then
			if tile_index > 127 then
				tile_index = tile_index - 256
			end
			-- add offset to re-root at tile 256 (so effectively, we read from tile 192 - 384)
			tile_index = tile_index + 256
		end

		if graphics.gameboy.type == graphics.gameboy.types.color then
			local map_attr = graphics.cache.map_0_attr
			if map == graphics.cache.map_1 then
				map_attr = graphics.cache.map_1_attr
			end
			local tile_attributes = map_attr[tile_x][tile_y]
			tile_index = tile_index + tile_attributes.bank * 384

			if tile_attributes.horizontal_flip == true then
				subpixel_x = (7 - subpixel_x)
			end

			if tile_attributes.vertical_flip == true then
				subpixel_y = (7 - subpixel_y)
			end
		end

		return graphics.cache.tiles[tile_index][subpixel_x][subpixel_y]
	end

	graphics.draw_sprites_into_scanline = function(scanline, bg_index, bg_priority)
		if not graphics.registers.sprites_enabled then
			return
		end
		local active_sprites = {}
		local sprite_size = 8
		if graphics.registers.large_sprites then
			sprite_size = 16
		end

		-- Collect up to the 10 highest priority sprites in a list.
		-- Sprites have priority first by their X coordinate, then by their index
		-- in the list.
		local i = 0
		while i < 40 do
			-- is this sprite being displayed on this scanline? (respect to Y coordinate)
			local sprite_y = graphics.cache.oam[i].y
			local sprite_lower = sprite_y
			local sprite_upper = sprite_y + sprite_size
			if scanline >= sprite_lower and scanline < sprite_upper then
				if #active_sprites < 10 then
					table.insert(active_sprites, i)
				else
					-- There are more than 10 sprites in the table, so we need to pick
					-- a candidate to vote off the island (possibly this one)
					local lowest_priority = i
					local lowest_priotity_index = nil
					for j = 1, #active_sprites do
						local lowest_x = graphics.cache.oam[lowest_priority].x
						local candidate_x = graphics.cache.oam[active_sprites[j]].x
						if candidate_x > lowest_x then
							lowest_priority = active_sprites[j]
							lowest_priority_index = j
						end
					end
					if lowest_priority_index then
						active_sprites[lowest_priority_index] = i
					end
				end
			end
			i = i + 1
		end

		-- now, for every sprite in the list, display it on the current scanline
		for i = #active_sprites, 1, -1 do
			local sprite = graphics.cache.oam[active_sprites[i]]

			local sub_y = 16 - ((sprite.y + 16) - scanline)
			if sprite.vertical_flip then
				sub_y = sprite_size - 1 - sub_y
			end

			local tile = sprite.tile
			if sprite_size == 16 then
				tile = sprite.upper_tile
				if sub_y >= 8 then
					tile = sprite.lower_tile
					sub_y = sub_y - 8
				end
			end

			local game_screen = graphics.game_screen

			for x = 0, 7 do
				local display_x = sprite.x + x
				if display_x >= 0 and display_x < 160 then
					local sub_x = x
					if x_flipped then
						sub_x = 7 - x
					end
					local subpixel_index = tile[sub_x][sub_y]
					if subpixel_index > 0 then
						if (bg_priority[display_x] == false and not sprite.bg_priority) or bg_index[display_x] == 0 or graphics.registers.oam_priority then
							local subpixel_color = sprite.palette[subpixel_index]
							game_screen[scanline][display_x][1] = subpixel_color[1]
							game_screen[scanline][display_x][2] = subpixel_color[2]
							game_screen[scanline][display_x][3] = subpixel_color[3]
						end
					end
				end
			end
		end
		if #active_sprites > 0 then
		end
	end

	return graphics
end

return Graphics
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX25D9A82E8E654B4192592F958BB769DA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">palette</string>
							<string name="ScriptGuid">{15770DCE-BD51-4287-98DF-EC76E57AA33E}</string>
							<ProtectedString name="Source"><![CDATA[local Palette = {}

function Palette.new(graphics, modules)
	local io = modules.io
	local ports = io.ports

	local palette = {}

	local dmg_colors = {}
	dmg_colors[0] = {255, 255, 255}
	dmg_colors[1] = {192, 192, 192}
	dmg_colors[2] = {128, 128, 128}
	dmg_colors[3] = {0, 0, 0}
	

	palette.dmg_colors = dmg_colors

	palette.set_dmg_colors = function(pal_0, pal_1, pal_2, pal_3)
		dmg_colors[0] = pal_0
		dmg_colors[1] = pal_1
		dmg_colors[2] = pal_2
		dmg_colors[3] = pal_3
	end

	palette.bg =   {}
	palette.obj0 = {}
	palette.obj1 = {}

	palette.color_bg = {}
	palette.color_obj = {}
	palette.color_bg_raw = {}
	palette.color_obj_raw = {}

	palette.reset = function()
		for i = 0, 3 do
			palette.bg[i] = dmg_colors[i]
			palette.obj0[i] = dmg_colors[i]
			palette.obj1[i] = dmg_colors[i]
		end

		for p = 0, 7 do
			palette.color_bg[p] = {}
			palette.color_obj[p] = {}
			for i = 0, 3 do
				palette.color_bg[p][i] = {255, 255, 255}
				palette.color_obj[p][i] = {255, 255, 255}
			end
		end

		for i = 0, 63 do
			palette.color_bg_raw[i] = 0
			palette.color_obj_raw[i] = 0
		end
	end

	palette.reset()

	local getColorFromIndex = function(index, palette)
		palette = palette or 0xE4
		while index > 0 do
			palette = bit32.rshift(palette, 2)
			index = index - 1
		end
		return dmg_colors[bit32.band(palette, 0x3)]
	end

	-- DMG palettes
	io.write_logic[ports.BGP] = function(byte)
		io.ram[ports.BGP] = byte
		for i = 0, 3 do
			palette.bg[i] = getColorFromIndex(i, byte)
		end
		graphics.update()
	end

	io.write_logic[ports.OBP0] = function(byte)
		io.ram[ports.OBP0] = byte
		for i = 0, 3 do
			palette.obj0[i] = getColorFromIndex(i, byte)
		end
		graphics.update()
	end

	io.write_logic[ports.OBP1] = function(byte)
		io.ram[ports.OBP1] = byte
		for i = 0, 3 do
			palette.obj1[i] = getColorFromIndex(i, byte)
		end
		graphics.update()
	end

	palette.color_bg_index = 0
	palette.color_bg_auto_increment = false
	palette.color_obj_index = 0
	palette.color_obj_auto_increment = false

	-- Color Palettes
	io.write_logic[0x68] = function(byte)
		io.ram[0x68] = byte
		palette.color_bg_index = bit32.band(byte, 0x3F)
		palette.color_bg_auto_increment = bit32.band(byte, 0x80) ~= 0
	end

	io.write_logic[0x69] = function(byte)
		palette.color_bg_raw[palette.color_bg_index] = byte

		-- Update the palette cache for this byte pair
		local low_byte = palette.color_bg_raw[bit32.band(palette.color_bg_index, 0xFE)]
		local high_byte = palette.color_bg_raw[bit32.band(palette.color_bg_index, 0xFE) + 1]
		local rgb5_color = bit32.lshift(high_byte, 8) + low_byte
		local r = bit32.band(rgb5_color, 0x001F) * 8
		local g = bit32.rshift(bit32.band(rgb5_color, 0x03E0), 5) * 8
		local b = bit32.rshift(bit32.band(rgb5_color, 0x7C00), 10) * 8
		local palette_index = math.floor(palette.color_bg_index / 8)
		local color_index = math.floor((palette.color_bg_index % 8) / 2)
		palette.color_bg[palette_index][color_index] = {r, g, b}

		if palette.color_bg_auto_increment then
			palette.color_bg_index = palette.color_bg_index + 1
			if palette.color_bg_index > 63 then
				palette.color_bg_index = 0
			end
		end
	end

	io.read_logic[0x69] = function()
		return palette.color_bg_raw[palette.color_bg_index]
	end

	io.write_logic[0x6A] = function(byte)
		io.ram[0x6A] = byte
		palette.color_obj_index = bit32.band(byte, 0x3F)
		palette.color_obj_auto_increment = bit32.band(byte, 0x80) ~= 0
	end

	io.write_logic[0x6B] = function(byte)
		palette.color_obj_raw[palette.color_obj_index] = byte

		-- Update the palette cache for this byte pair
		local low_byte = palette.color_obj_raw[bit32.band(palette.color_obj_index, 0xFE)]
		local high_byte = palette.color_obj_raw[bit32.band(palette.color_obj_index, 0xFE) + 1]
		local rgb5_color = bit32.lshift(high_byte, 8) + low_byte
		local r = bit32.band(rgb5_color, 0x001F) * 8
		local g = bit32.rshift(bit32.band(rgb5_color, 0x03E0), 5) * 8
		local b = bit32.rshift(bit32.band(rgb5_color, 0x7C00), 10) * 8
		local palette_index = math.floor(palette.color_obj_index / 8)
		local color_index = math.floor((palette.color_obj_index % 8) / 2)
		palette.color_obj[palette_index][color_index] = {r, g, b}

		if palette.color_obj_auto_increment then
			palette.color_obj_index = palette.color_obj_index + 1
			if palette.color_obj_index > 63 then
				palette.color_obj_index = 0
			end
		end
	end

	io.read_logic[0x6B] = function()
		return palette.color_obj_raw[palette.color_obj_index]
	end

	return palette
end

return Palette
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1EFB208C46D2400481138C27C87F1BFD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">registers</string>
							<string name="ScriptGuid">{FA9DE1DC-03FD-4FC3-8A5C-547692097148}</string>
							<ProtectedString name="Source"><![CDATA[local Registers = {}

function Registers.new(graphics, modules, cache)
	local io = modules.io
	local ports = io.ports

	local registers = {}

	registers.display_enabled = true
	registers.window_tilemap = cache.map_0
	registers.window_attr = cache.map_0_attr
	registers.window_enabled = true
	registers.tile_select = 0x9000
	registers.background_tilemap = cache.map_0
	registers.background_attr = cache.map_0_attr
	registers.large_sprites = false
	registers.sprites_enabled = true
	registers.background_enabled = true
	registers.oam_priority = false

	io.write_logic[ports.LCDC] = function(byte)
		io.ram[ports.LCDC] = byte

		-- Unpack all the bit flags into lua variables, for great sanity
		registers.display_enabled = bit32.band(0x80, byte) ~= 0
		registers.window_enabled  = bit32.band(0x20, byte) ~= 0
		registers.large_sprites   = bit32.band(0x04, byte) ~= 0
		registers.sprites_enabled = bit32.band(0x02, byte) ~= 0

		if graphics.gameboy.type == graphics.gameboy.types.color then
			registers.oam_priority = bit32.band(0x01, byte) == 0
		else
			registers.background_enabled = bit32.band(0x01, byte) ~= 0
		end

		if bit32.band(0x40, byte) ~= 0 then
			registers.window_tilemap = cache.map_1
			registers.window_attr = cache.map_1_attr
		else
			registers.window_tilemap = cache.map_0
			registers.window_attr = cache.map_0_attr
		end

		if bit32.band(0x10, byte) ~= 0 then
			if registers.tile_select == 0x9000 then
				-- refresh our tile indices, they'll all need recalculating for the new offset
				registers.tile_select = 0x8000
				cache.refreshTileMaps()
			end
		else
			if registers.tile_select == 0x8000 then
				-- refresh our tile indices, they'll all need recalculating for the new offset
				registers.tile_select = 0x9000
				cache.refreshTileMaps()
			end
		end

		if bit32.band(0x08, byte) ~= 0 then
			registers.background_tilemap = cache.map_1
			registers.background_attr = cache.map_1_attr
		else
			registers.background_tilemap = cache.map_0
			registers.background_attr = cache.map_0_attr
		end
	end

	local status = {}
	registers.status = status

	status.mode = 2

	status.SetMode = function(mode)
		status.mode = mode
		io.ram[ports.STAT] = bit32.band(io.ram[ports.STAT], 0xFC) + bit32.band(mode, 0x3)
	end

	status.lyc_interrupt_enabled = false
	status.oam_interrupt_enabled = false
	status.vblank_interrupt_enabled = false
	status.hblank_interrupt_enabled = false

	io.write_logic[ports.STAT] = function(byte)
		io.ram[ports.STAT] = bit32.band(byte, 0x78)
		status.lyc_interrupt_enabled = bit32.band(byte, 0x40) ~= 0
		status.oam_interrupt_enabled = bit32.band(byte, 0x20) ~= 0
		status.vblank_interrupt_enabled = bit32.band(byte, 0x10) ~= 0
		status.hblank_interrupt_enabled = bit32.band(byte, 0x08) ~= 0
	end

	return registers
end

return Registers
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX378AA707A12A4045807DBB22543CC5B7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">mbc</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX1733168AF9894C67828B92949200F38A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">mbc1</string>
							<string name="ScriptGuid">{00E06D01-2022-4A88-9EA3-AA66ADE5F325}</string>
							<ProtectedString name="Source"><![CDATA[local Mbc1 = {}

function Mbc1.new()
	local mbc1 = {}
	mbc1.raw_data = {}
	mbc1.external_ram = {}
	mbc1.header = {}
	mbc1.rom_bank = 1
	mbc1.ram_bank = 0
	mbc1.mode = 0 --0 = ROM bank mode, 1 = RAM bank mode
	mbc1.ram_enable = false
	mbc1.mt = {}
	mbc1.mt.__index = function(table, address)
		-- Lower 16k: return the first bank, always
		if address <= 0x3FFF then
			return mbc1.raw_data[address]
		end
		-- Upper 16k: return the currently selected bank
		if address >= 0x4000 and address <= 0x7FFF then
			local rom_bank = mbc1.rom_bank
			if mbc1.mode == 0 then
				rom_bank = rom_bank + bit32.lshift(mbc1.ram_bank, 5)
			end
			return mbc1.raw_data[(rom_bank * 16 * 1024) + (address - 0x4000)]
		end

		if address >= 0xA000 and address <= 0xBFFF and mbc1.ram_enable then
			local ram_bank = 0
			if mbc1.mode == 1 then
				ram_bank = mbc1.ram_bank
			end
			return mbc1.external_ram[(address - 0xA000) + (ram_bank * 8 * 1024)]
		end
		return 0x00
	end
	mbc1.mt.__newindex = function(table, address, value)
		if address <= 0x1FFF then
			if bit32.band(0x0A, value) == 0x0A then
				mbc1.ram_enable = true
			else
				mbc1.ram_enable = false
			end
			return
		end
		if address >= 0x2000 and address <= 0x3FFF then
			-- Select the lower 5 bits of the ROM bank
			-- HARDWARE BUG: bank 0 is translated into bank 1 for weird reasons
			value = bit32.band(value, 0x1F)
			if value == 0 then
				value = 1
			end
			mbc1.rom_bank = value
			return
		end
		if address >= 0x4000 and address <= 0x5FFF then
			mbc1.ram_bank = bit32.band(value, 0x03)
			return
		end
		if address >= 0x6000 and address <= 0x7FFF then
			mbc1.mode = bit32.band(value, 0x01)
			return
		end

		-- Handle actually writing to External RAM
		if address >= 0xA000 and address <= 0xBFFF and mbc1.ram_enable then
			local ram_bank = 0
			if mbc1.mode == 1 then
				ram_bank = mbc1.ram_bank
			end
			mbc1.external_ram[(address - 0xA000) + (ram_bank * 8 * 1024)] = value
			mbc1.external_ram.dirty = true
			return
		end
	end

	mbc1.reset = function(self)
		self.rom_bank = 1
		self.ram_bank = 0
		self.mode = 0
		self.ram_enable = false
	end

	mbc1.save_state = function(self)
		return {
			rom_bank = self.rom_bank,
			ram_bank = self.ram_bank,
			mode = self.mode,
			ram_enable = self.ram_enable}
	end

	mbc1.load_state = function(self, state_data)
		self:reset()

		self.rom_bank = state_data.rom_bank
		self.ram_bank = state_data.ram_bank
		self.mode = state_data.mode
		self.ram_enable = state_data.ram_enable
	end

	setmetatable(mbc1, mbc1.mt)

	return mbc1
end

return Mbc1
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFDA0C7E352B845F9BA4A1437C8A8F330">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">mbc2</string>
							<string name="ScriptGuid">{784B3294-1806-465B-9D50-F3E972EE43A0}</string>
							<ProtectedString name="Source"><![CDATA[local Mbc2 = {}

function Mbc2.new()
	local mbc2 = {}
	mbc2.raw_data = {}
	mbc2.external_ram = {}
	mbc2.header = {}
	mbc2.rom_bank = 1
	mbc2.ram_enable = false
	mbc2.mt = {}
	mbc2.mt.__index = function(table, address)
		-- Lower 16k: return the first bank, always
		if address <= 0x3FFF then
			return mbc2.raw_data[address]
		end
		-- Upper 16k: return the currently selected bank
		if address >= 0x4000 and address <= 0x7FFF then
			local rom_bank = mbc2.rom_bank
			return mbc2.raw_data[(rom_bank * 16 * 1024) + (address - 0x4000)]
		end

		if address >= 0xA000 and address <= 0xA1FF and mbc2.ram_enable then
			-- For MBC2, only the lower 4 bits of each RAM byte are available for use
			return bit32.band(0x0F, mbc2.external_ram[(address - 0xA000)])
		end

		return 0x00
	end
	mbc2.mt.__newindex = function(table, address, value)
		if address <= 0x1FFF and bit32.band(address, 0x0100) == 0 then
			if bit32.band(0x0A, value) == 0x0A then
				mbc2.ram_enable = true
			else
				mbc2.ram_enable = false
			end
			return
		end
		if address >= 0x2000 and address <= 0x3FFF and bit32.band(address, 0x0100) ~= 0 then
			-- Select the ROM bank (4 bits)
			value = bit32.band(value, 0x0F)
			if value == 0 then
				value = 1
			end
			mbc2.rom_bank = value
			return
		end

		-- Handle actually writing to External RAM
		if address >= 0xA000 and address <= 0xBFFF and mbc2.ram_enable then
			mbc2.external_ram[(address - 0xA000)] = bit32.band(0x0F, value)
			mbc2.external_ram.dirty = true
			return
		end
	end

	mbc2.reset = function(self)
		self.rom_bank = 1
		self.ram_enable = false
	end

	mbc2.save_state = function(self)
		return {rom_bank = self.rom_bank, ram_enable = self.ram_enable}
	end

	mbc2.load_state = function(self, state_data)
		self:reset()

		self.rom_bank = state_data.rom_bank
		self.ram_enable = state_data.ram_enable
	end

	setmetatable(mbc2, mbc2.mt)

	return mbc2
end

return Mbc2
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4C883667345C448D89CA03EDA2B0ACE1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">mbc3</string>
							<string name="ScriptGuid">{25CD4E50-1F46-4136-AB68-28FBDACDDEB0}</string>
							<ProtectedString name="Source"><![CDATA[local Mbc3 = {}

local gameboy = game.ReplicatedStorage.LuaGB.gameboy
local RTC = require(gameboy.rtc)


function Mbc3.new()
	local mbc3 = {}
	mbc3.raw_data = {}
	mbc3.external_ram = {}
	mbc3.header = {}
	mbc3.rom_bank = 0
	mbc3.ram_bank = 0
	mbc3.ram_enable = false
	mbc3.rtc_enable = false
	mbc3.rtc_select = 0x08
	mbc3.rtc = RTC.new()
	mbc3.mt = {}
	mbc3.rtc:latch_rtc()
	mbc3.mt.__index = function(table, address)
		-- Lower 16k: return the first bank, always
		if address <= 0x3FFF then
			return mbc3.raw_data[address]
		end
		-- Upper 16k: return the currently selected bank
		if address >= 0x4000 and address <= 0x7FFF then
			local rom_bank = mbc3.rom_bank
			return mbc3.raw_data[(rom_bank * 16 * 1024) + (address - 0x4000)]
		end

		if address >= 0xA000 and address <= 0xBFFF and mbc3.ram_enable then
			local ram_bank = mbc3.ram_bank
			if (ram_bank >= 0x08 and ram_bank <= 0x0C) then
				return mbc3.rtc:get_register(mbc3.rtc.rambank_selected)
			else
				return mbc3.external_ram[(address - 0xA000) + (ram_bank * 8 * 1024)]
			end
		end
		return 0x00
	end
	mbc3.mt.__newindex = function(table, address, value)
		if address <= 0x1FFF then
			if bit32.band(0x0A, value) == 0x0A then
				mbc3.ram_enable = true
			else
				mbc3.ram_enable = false
			end
			return
		end
		if address >= 0x2000 and address <= 0x3FFF then
			-- Select the lower 7 bits of the ROM bank
			value = bit32.band(value, 0x7F)
			if value == 0 then
				value = 1
			end
			mbc3.rom_bank = value
			return
		end
		if address >= 0x4000 and address <= 0x5FFF then
			mbc3.rtc_enable = false
			if value <= 0x03 then
				mbc3.ram_bank = bit32.band(value, 0x03)
				return
			end
			if value >= 0x08 and value <= 0x0C then
				mbc3.rtc_enable = true
				mbc3.rtc_select = value
				return
			end
		end
		if address >= 0x6000 and address <= 0x8000 then
			mbc3.rtc:write_command(value)
			return
		end
		

		-- Handle actually writing to External RAM
		if address >= 0xA000 and address <= 0xC000 and mbc3.ram_enable then
			if (mbc3.rtc_select <= 0x03) then
				local ram_bank = mbc3.ram_bank
				mbc3.external_ram[(address - 0xA000) + (ram_bank * 8 * 1024)] = value
				mbc3.external_ram.dirty = true
			elseif mbc3.rtc_select >= 0x08 and mbc3.rtc_select <= 0x0c then
				mbc3.rtc:set_register(mbc3.rtc_select, value)
			else
				print("Invalid RAM bank selected.")
			end

			return
		end
	end

	mbc3.reset = function(self)
		self.rom_bank = 1
		self.ram_bank = 0
		self.ram_enable = false
		self.rtc_enable = false
		self.rtc_select = 0x08
	end

	mbc3.save_state = function(self)
		return {
			rom_bank = self.rom_bank,
			ram_bank = self.ram_bank,
			ram_enable = self.ram_enable,
			rtc_enable = self.rtc_enable,
			rtc_select = self.rtc_enable}
	end

	mbc3.load_state = function(self, state_data)
		self:reset()

		self.rom_bank = state_data.rom_bank
		self.ram_bank = state_data.ram_bank
		self.ram_enable = state_data.ram_enable
		self.rtc_enable = state_data.rtc_enable
		self.rtc_select = state_data.rtc_select
	end

	setmetatable(mbc3, mbc3.mt)

	return mbc3
end

return Mbc3
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXAA4F39BC211A45F5B664D32D315D8502">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">mbc5</string>
							<string name="ScriptGuid">{05D6D2C9-CD26-41E5-BEE5-8A2BCB5AA22D}</string>
							<ProtectedString name="Source"><![CDATA[local Mbc5 = {}

function Mbc5.new()
	local mbc5 = {}
	mbc5.raw_data = {}
	mbc5.external_ram = {}
	mbc5.header = {}
	mbc5.rom_bank = 0
	mbc5.ram_bank = 0
	mbc5.ram_enable = false
	mbc5.rumble_pak = false
	mbc5.rumbling = false
	mbc5.mt = {}
	mbc5.mt.__index = function(table, address)
		-- Lower 16k: return the first bank, always
		if address <= 0x3FFF then
			return mbc5.raw_data[address]
		end
		-- Upper 16k: return the currently selected bank
		if address >= 0x4000 and address <= 0x7FFF then
			local rom_bank = mbc5.rom_bank
			return mbc5.raw_data[(rom_bank * 16 * 1024) + (address - 0x4000)]
		end

		if address >= 0xA000 and address <= 0xBFFF and mbc5.ram_enable then
			local ram_bank = mbc5.ram_bank
			return mbc5.external_ram[(address - 0xA000) + (ram_bank * 8 * 1024)]
		end
		return 0x00
	end
	mbc5.mt.__newindex = function(table, address, value)
		if address <= 0x1FFF then
			if bit32.band(0x0A, value) == 0x0A then
				mbc5.ram_enable = true
			else
				mbc5.ram_enable = false
			end
			return
		end
		if address >= 0x2000 and address <= 0x2FFF then
			-- Write the lower 8 bits of the ROM bank
			mbc5.rom_bank = bit32.band(mbc5.rom_bank, 0xFF00) + value
			return
		end
		if address >= 0x3000 and address <= 0x3FFF then
			if mbc5.header.rom_size > (4096 * 1024) then
				-- This is a >4MB game, so set the high bit of the bank select
				mbc5.rom_bank = bit32.band(mbc5.rom_bank, 0xFF) + bit32.lshift(bit32.band(value, 0x01), 8)
			else
				-- This is a <= 4MB game. Do nothing!
			end
			return
		end
		if address >= 0x4000 and address <= 0x5FFF then
			local ram_mask = 0x0F
			if mbc5.rumble_pak then
				ram_mask = 0x7
			end
			mbc5.ram_bank = bit32.band(value, ram_mask)
			if bit32.band(value, 0x08) ~= 0 and mbc5.rumbling == false then
				--print("Rumble on!")
				mbc5.rumbling = true
			end
			if bit32.band(value, 0x08) ~= 0 and mbc5.rumbling == true then
				--print("Rumble off!")
				mbc5.rumbling = false
			end
			return
		end

		-- Handle actually writing to External RAM
		if address >= 0xA000 and address <= 0xBFFF and mbc5.ram_enable then
			local ram_bank = mbc5.ram_bank
			mbc5.external_ram[(address - 0xA000) + (ram_bank * 8 * 1024)] = value
			mbc5.external_ram.dirty = true
			return
		end
	end

	mbc5.reset = function(self)
		self.rom_bank = 1
		self.ram_bank = 0
		self.ram_enable = false
	end

	mbc5.save_state = function(self)
		return {
			rom_bank = self.rom_bank,
			ram_bank = self.ram_bank,
			ram_enable = self.ram_enable,
			rumble_pak = self.rumble_pak}
	end

	mbc5.load_state = function(self, state_data)
		self:reset()

		self.rom_bank = state_data.rom_bank
		self.ram_bank = state_data.ram_bank
		self.ram_enable = state_data.ram_enable
		self.rumble_pak = state_data.rumble_pak
		self.rumbling = false
	end

	setmetatable(mbc5, mbc5.mt)

	return mbc5
end

return Mbc5
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF732EE8FD46043D588D9101A070D42C6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">none</string>
							<string name="ScriptGuid">{240F0A84-C535-459E-8BE4-8C1A1206753D}</string>
							<ProtectedString name="Source"><![CDATA[local MbcNone = {}

function MbcNone.new()
	-- Very simple: Map the entire 32k cartridge into lower memory, and be done with it.
	local mbc_none = {}
	mbc_none.mt = {}
	mbc_none.raw_data = {}
	mbc_none.external_ram = {}
	mbc_none.header = {}
	mbc_none.mt.__index = function(table, address)
		return mbc_none.raw_data[address]
	end
	mbc_none.mt.__newindex = function(table, address, value)
		--do nothing!
		return
	end

	mbc_none.load_state = function(self)
		-- Do nothing! This MBC has no state.
	end

	mbc_none.save_state = function(self)
		-- Return nothing! No state to save with this MBC.
		return nil
	end

	mbc_none.reset = function(self, state)
		-- Do nothing! This MBC has no state.
	end

	setmetatable(mbc_none, mbc_none.mt)

	return mbc_none
end

return MbcNone
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXD6A7C8F464124ABFA0310C0958929D8D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">z80</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3CD7BD95DE144C38949754FF2747A7A2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">arithmetic</string>
							<string name="ScriptGuid">{5BF906B8-F3C8-49FD-AF62-E9A7E14E2FCF}</string>
							<ProtectedString name="Source"><![CDATA[local lshift = bit32.lshift
local rshift = bit32.rshift
local band = bit32.band
local bxor = bit32.bxor
local bor = bit32.bor
local bnor = bit32.bnor

function apply(opcodes, opcode_cycles, z80, memory)
	local read_at_hl = z80.read_at_hl
	local set_at_hl = z80.set_at_hl
	local read_nn = z80.read_nn
	local reg = z80.registers
	local flags = reg.flags

	local read_byte = memory.read_byte
	local write_byte = memory.write_byte

	local add_to_a = function(value)
		-- half-carry
		flags.h = band(reg.a, 0xF) + band(value, 0xF) > 0xF

		local sum = reg.a + value

		-- carry (and overflow correction)
		flags.c = sum > 0xFF

		reg.a = band(sum, 0xFF)

		flags.z = reg.a == 0
		flags.n = false
	end

	local adc_to_a = function(value)
		-- half-carry
		local carry = 0
		if flags.c then
			carry = 1
		end
		flags.h = band(reg.a, 0xF) + band(value, 0xF) + carry > 0xF
		local sum = reg.a + value + carry

		-- carry (and overflow correction)
		flags.c = sum > 0xFF
		reg.a = band(sum, 0xFF)

		flags.z = reg.a == 0
		flags.n = false
	end

	-- add A, r
	opcodes[0x80] = function() add_to_a(reg.b) end
	opcodes[0x81] = function() add_to_a(reg.c) end
	opcodes[0x82] = function() add_to_a(reg.d) end
	opcodes[0x83] = function() add_to_a(reg.e) end
	opcodes[0x84] = function() add_to_a(reg.h) end
	opcodes[0x85] = function() add_to_a(reg.l) end
	opcode_cycles[0x86] = 8
	opcodes[0x86] = function() add_to_a(read_at_hl()) end
	opcodes[0x87] = function() add_to_a(reg.a) end

	-- add A, nn
	opcode_cycles[0xC6] = 8
	opcodes[0xC6] = function() add_to_a(read_nn()) end

	-- adc A, r
	opcodes[0x88] = function() adc_to_a(reg.b) end
	opcodes[0x89] = function() adc_to_a(reg.c) end
	opcodes[0x8A] = function() adc_to_a(reg.d) end
	opcodes[0x8B] = function() adc_to_a(reg.e) end
	opcodes[0x8C] = function() adc_to_a(reg.h) end
	opcodes[0x8D] = function() adc_to_a(reg.l) end
	opcode_cycles[0x8E] = 8
	opcodes[0x8E] = function() adc_to_a(read_at_hl()) end
	opcodes[0x8F] = function() adc_to_a(reg.a) end

	-- adc A, nn
	opcode_cycles[0xCE] = 8
	opcodes[0xCE] = function() adc_to_a(read_nn()) end

	sub_from_a = function(value)
		-- half-carry
		flags.h = band(reg.a, 0xF) - band(value, 0xF) < 0
		reg.a = reg.a - value

		-- carry (and overflow correction)
		flags.c = reg.a < 0 or reg.a > 0xFF
		reg.a = band(reg.a, 0xFF)

		flags.z = reg.a == 0
		flags.n = true
	end

	sbc_from_a = function(value)
		local carry = 0
		if flags.c then
			carry = 1
		end
		-- half-carry
		flags.h = band(reg.a, 0xF) - band(value, 0xF) - carry < 0

		local difference = reg.a - value - carry

		-- carry (and overflow correction)
		flags.c = difference < 0 or difference > 0xFF
		reg.a = band(difference, 0xFF)

		flags.z = reg.a == 0
		flags.n = true
	end

	-- sub A, r
	opcodes[0x90] = function() sub_from_a(reg.b) end
	opcodes[0x91] = function() sub_from_a(reg.c) end
	opcodes[0x92] = function() sub_from_a(reg.d) end
	opcodes[0x93] = function() sub_from_a(reg.e) end
	opcodes[0x94] = function() sub_from_a(reg.h) end
	opcodes[0x95] = function() sub_from_a(reg.l) end
	opcode_cycles[0x96] = 8
	opcodes[0x96] = function() sub_from_a(read_at_hl()) end
	opcodes[0x97] = function() sub_from_a(reg.a) end

	-- sub A, nn
	opcode_cycles[0xD6] = 8
	opcodes[0xD6] = function() sub_from_a(read_nn()) end

	-- sbc A, r
	opcodes[0x98] = function() sbc_from_a(reg.b) end
	opcodes[0x99] = function() sbc_from_a(reg.c) end
	opcodes[0x9A] = function() sbc_from_a(reg.d) end
	opcodes[0x9B] = function() sbc_from_a(reg.e) end
	opcodes[0x9C] = function() sbc_from_a(reg.h) end
	opcodes[0x9D] = function() sbc_from_a(reg.l) end
	opcode_cycles[0x9E] = 8
	opcodes[0x9E] = function() sbc_from_a(read_at_hl()) end
	opcodes[0x9F] = function() sbc_from_a(reg.a) end

	-- sbc A, nn
	opcode_cycles[0xDE] = 8
	opcodes[0xDE] = function() sbc_from_a(read_nn()) end

	-- daa
	-- BCD adjustment, correct implementation details located here:
	-- http://www.z80.info/z80syntx.htm#DAA
	opcodes[0x27] = function()
		local a = reg.a
		if not flags.n then
			-- Addition Mode, adjust BCD for previous addition-like instruction
			if band(0xF, a) > 0x9 or flags.h then
				a = a + 0x6
			end
			if a > 0x9F or flags.c then
				a = a + 0x60
			end
		else
			-- Subtraction mode! Adjust BCD for previous subtraction-like instruction
			if flags.h then
				a = band(a - 0x6, 0xFF)
			end
			if flags.c then
				a = a - 0x60
			end
		end
		-- Always reset H and Z
		flags.h = false
		flags.z = false

		-- If a is greater than 0xFF, set the carry flag
		if band(0x100, a) == 0x100 then
			flags.c = true
		end
		-- Note: Do NOT clear the carry flag otherwise. This is how hardware
		-- behaves, yes it's weird.

		reg.a = band(a, 0xFF)
		-- Update zero flag based on A's contents
		flags.z = reg.a == 0
	end

	add_to_hl = function(value)
		-- half carry
		flags.h = band(reg.hl(), 0xFFF) + band(value, 0xFFF) > 0xFFF
		local sum = reg.hl() + value

		-- carry
		flags.c = sum > 0xFFFF or sum < 0x0000
		reg.set_hl(band(sum, 0xFFFF))
		flags.n = false
	end

	-- add HL, rr
	opcode_cycles[0x09] = 8
	opcode_cycles[0x19] = 8
	opcode_cycles[0x29] = 8
	opcode_cycles[0x39] = 8
	opcodes[0x09] = function() add_to_hl(reg.bc()) end
	opcodes[0x19] = function() add_to_hl(reg.de()) end
	opcodes[0x29] = function() add_to_hl(reg.hl()) end
	opcodes[0x39] = function() add_to_hl(reg.sp) end

	-- inc rr
	opcode_cycles[0x03] = 8
	opcodes[0x03] = function()
		reg.set_bc(band(reg.bc() + 1, 0xFFFF))
	end

	opcode_cycles[0x13] = 8
	opcodes[0x13] = function()
		reg.set_de(band(reg.de() + 1, 0xFFFF))
	end

	opcode_cycles[0x23] = 8
	opcodes[0x23] = function()
		reg.set_hl(band(reg.hl() + 1, 0xFFFF))
	end

	opcode_cycles[0x33] = 8
	opcodes[0x33] = function()
		reg.sp = band(reg.sp + 1, 0xFFFF)
	end

	-- dec rr
	opcode_cycles[0x0B] = 8
	opcodes[0x0B] = function()
		reg.set_bc(band(reg.bc() - 1, 0xFFFF))
	end

	opcode_cycles[0x1B] = 8
	opcodes[0x1B] = function()
		reg.set_de(band(reg.de() - 1, 0xFFFF))
	end

	opcode_cycles[0x2B] = 8
	opcodes[0x2B] = function()
		reg.set_hl(band(reg.hl() - 1, 0xFFFF))
	end

	opcode_cycles[0x3B] = 8
	opcodes[0x3B] = function()
		reg.sp = band(reg.sp - 1, 0xFFFF)
	end

	-- add SP, dd
	opcode_cycles[0xE8] = 16
	opcodes[0xE8] = function()
		local offset = read_nn()
		-- offset comes in as unsigned 0-255, so convert it to signed -128 - 127
		if band(offset, 0x80) ~= 0 then
			offset = offset + 0xFF00
		end

		-- half carry
		--if band(reg.sp, 0xFFF) + offset > 0xFFF or band(reg.sp, 0xFFF) + offset < 0 then
		flags.h = band(reg.sp, 0xF) + band(offset, 0xF) > 0xF
		-- carry
		flags.c = band(reg.sp, 0xFF) + band(offset, 0xFF) > 0xFF

		reg.sp = reg.sp + offset
		reg.sp = band(reg.sp, 0xFFFF)

		flags.z = false
		flags.n = false
	end
end

return apply
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEE1D6AEA0DCA472DB84379B8644968F8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">bitwise</string>
							<string name="ScriptGuid">{71FA55A5-F268-4794-8D1A-F9E72E12A343}</string>
							<ProtectedString name="Source"><![CDATA[local lshift = bit32.lshift
local band = bit32.band
local band = bit32.band
local bxor = bit32.bxor
local bor = bit32.bor
local bnor = bit32.bnor

function apply(opcodes, opcode_cycles, z80, memory)
	local read_at_hl = z80.read_at_hl
	local set_at_hl = z80.set_at_hl
	local read_nn = z80.read_nn
	local reg = z80.registers
	local flags = reg.flags

	local read_byte = memory.read_byte
	local write_byte = memory.write_byte

	and_a_with = function(value)
		reg.a = band(reg.a, value)
		flags.z = reg.a == 0
		flags.n = false
		flags.h = true
		flags.c = false
	end

	-- and A, r
	opcodes[0xA0] = function() and_a_with(reg.b) end
	opcodes[0xA1] = function() and_a_with(reg.c) end
	opcodes[0xA2] = function() and_a_with(reg.d) end
	opcodes[0xA3] = function() and_a_with(reg.e) end
	opcodes[0xA4] = function() and_a_with(reg.h) end
	opcodes[0xA5] = function() and_a_with(reg.l) end
	opcode_cycles[0xA6] = 8
	opcodes[0xA6] = function() and_a_with(read_at_hl()) end
	opcodes[0xA7] = function()
		--reg.a = band(reg.a, value)
		flags.z = reg.a == 0
		flags.n = false
		flags.h = true
		flags.c = false
	end

	-- and A, nn
	opcode_cycles[0xE6] = 8
	opcodes[0xE6] = function() and_a_with(read_nn()) end

	xor_a_with = function(value)
		reg.a = bxor(reg.a, value)
		flags.z = reg.a == 0
		flags.n = false
		flags.h = false
		flags.c = false
	end

	-- xor A, r
	opcodes[0xA8] = function() xor_a_with(reg.b) end
	opcodes[0xA9] = function() xor_a_with(reg.c) end
	opcodes[0xAA] = function() xor_a_with(reg.d) end
	opcodes[0xAB] = function() xor_a_with(reg.e) end
	opcodes[0xAC] = function() xor_a_with(reg.h) end
	opcodes[0xAD] = function() xor_a_with(reg.l) end
	opcode_cycles[0xAE] = 8
	opcodes[0xAE] = function() xor_a_with(read_at_hl()) end
	opcodes[0xAF] = function()
		reg.a = 0
		flags.z = true
		flags.n = false
		flags.h = false
		flags.c = false
	end

	-- xor A, nn
	opcode_cycles[0xEE] = 8
	opcodes[0xEE] = function() xor_a_with(read_nn()) end

	or_a_with = function(value)
		reg.a = bor(reg.a, value)
		flags.z = reg.a == 0
		flags.n = false
		flags.h = false
		flags.c = false
	end

	-- or A, r
	opcodes[0xB0] = function() or_a_with(reg.b) end
	opcodes[0xB1] = function() or_a_with(reg.c) end
	opcodes[0xB2] = function() or_a_with(reg.d) end
	opcodes[0xB3] = function() or_a_with(reg.e) end
	opcodes[0xB4] = function() or_a_with(reg.h) end
	opcodes[0xB5] = function() or_a_with(reg.l) end
	opcode_cycles[0xB6] = 8
	opcodes[0xB6] = function() or_a_with(read_at_hl()) end
	opcodes[0xB7] = function()
		flags.z = reg.a == 0
		flags.n = false
		flags.h = false
		flags.c = false
	end

	-- or A, nn
	opcode_cycles[0xF6] = 8
	opcodes[0xF6] = function() or_a_with(read_nn()) end

	-- cpl
	opcodes[0x2F] = function()
		reg.a = bxor(reg.a, 0xFF)
		flags.n = true
		flags.h = true
	end
end

return apply
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5146AA792A2D41FFAE7C5A8D12A7DE96">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">call</string>
							<string name="ScriptGuid">{3F3FBEDE-E0EE-4606-B40E-E455BE5B3E06}</string>
							<ProtectedString name="Source"><![CDATA[local lshift = bit32.lshift
local rshift = bit32.rshift
local band = bit32.band
local bxor = bit32.bxor
local bor = bit32.bor
local bnor = bit32.bnor

function apply(opcodes, opcode_cycles, z80, memory, interrupts)
	local read_nn = z80.read_nn
	local reg = z80.registers
	local flags = reg.flags

	local read_byte = memory.read_byte
	local write_byte = memory.write_byte

	local call_nnnn = function()
		local lower = read_nn()
		local upper = read_nn() * 256
		-- at this point, reg.pc points at the next instruction after the call,
		-- so store the current PC to the stack

		reg.sp = (reg.sp + 0xFFFF) % 0x10000
		write_byte(reg.sp, rshift(reg.pc, 8))
		reg.sp = (reg.sp + 0xFFFF) % 0x10000
		write_byte(reg.sp, reg.pc % 0x100)

		reg.pc = upper + lower
	end

	-- call nn
	opcode_cycles[0xCD] = 24
	opcodes[0xCD] = function()
		call_nnnn()
	end

	-- call nz, nnnn
	opcode_cycles[0xC4] = 12
	opcodes[0xC4] = function()
		if not flags.z then
			call_nnnn()
			z80.add_cycles(12)
		else
			reg.pc = reg.pc + 2
		end
	end

	-- call nc, nnnn
	opcode_cycles[0xD4] = 12
	opcodes[0xD4] = function()
		if not flags.c then
			call_nnnn()
			z80.add_cycles(12)
		else
			reg.pc = reg.pc + 2
		end
	end

	-- call z, nnnn
	opcode_cycles[0xCC] = 12
	opcodes[0xCC] = function()
		if flags.z then
			call_nnnn()
			z80.add_cycles(12)
		else
			reg.pc = reg.pc + 2
		end
	end

	-- call c, nnnn
	opcode_cycles[0xDC] = 12
	opcodes[0xDC] = function()
		if flags.c then
			call_nnnn()
			z80.add_cycles(12)
		else
			reg.pc = reg.pc + 2
		end
	end

	local ret = function()
		local lower = read_byte(reg.sp)
		reg.sp = band(0xFFFF, reg.sp + 1)
		local upper = lshift(read_byte(reg.sp), 8)
		reg.sp = band(0xFFFF, reg.sp + 1)
		reg.pc = upper + lower
		z80.add_cycles(12)
	end

	-- ret
	opcodes[0xC9] = function() ret() end

	-- ret nz
	opcode_cycles[0xC0] = 8
	opcodes[0xC0] = function()
		if not flags.z then
			ret()
		end
	end

	-- ret nc
	opcode_cycles[0xD0] = 8
	opcodes[0xD0] = function()
		if not flags.c then
			ret()
		end
	end

	-- ret z
	opcode_cycles[0xC8] = 8
	opcodes[0xC8] = function()
		if flags.z then
			ret()
		end
	end

	-- ret c
	opcode_cycles[0xD8] = 8
	opcodes[0xD8] = function()
		if flags.c then
			ret()
		end
	end

	-- reti
	opcodes[0xD9] = function()
		ret()
		interrupts.enable()
		z80.service_interrupt()
	end

	-- note: used only for the RST instructions below
	local function call_address(address)
		-- reg.pc points at the next instruction after the call,
		-- so store the current PC to the stack
		reg.sp = band(0xFFFF, reg.sp - 1)
		write_byte(reg.sp, rshift(band(reg.pc, 0xFF00), 8))
		reg.sp = band(0xFFFF, reg.sp - 1)
		write_byte(reg.sp, band(reg.pc, 0xFF))

		reg.pc = address
	end

	-- rst N
	opcode_cycles[0xC7] = 16
	opcodes[0xC7] = function() call_address(0x00) end

	opcode_cycles[0xCF] = 16
	opcodes[0xCF] = function() call_address(0x08) end

	opcode_cycles[0xD7] = 16
	opcodes[0xD7] = function() call_address(0x10) end

	opcode_cycles[0xDF] = 16
	opcodes[0xDF] = function() call_address(0x18) end

	opcode_cycles[0xE7] = 16
	opcodes[0xE7] = function() call_address(0x20) end

	opcode_cycles[0xEF] = 16
	opcodes[0xEF] = function() call_address(0x28) end

	opcode_cycles[0xF7] = 16
	opcodes[0xF7] = function() call_address(0x30) end

	opcode_cycles[0xFF] = 16
	opcodes[0xFF] = function() call_address(0x38) end
end

return apply
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2EB0B99DF3FA4E2E8469206072C72002">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">cp</string>
							<string name="ScriptGuid">{29F98401-912F-4B53-8DF9-3631BBB429DF}</string>
							<ProtectedString name="Source"><![CDATA[local lshift = bit32.lshift
local band = bit32.band

function apply(opcodes, opcode_cycles, z80, memory)
	local read_at_hl = z80.read_at_hl
	local set_at_hl = z80.set_at_hl
	local read_nn = z80.read_nn
	local reg = z80.registers
	local flags = reg.flags

	local read_byte = memory.read_byte
	local write_byte = memory.write_byte

	cp_with_a = function(value)
		-- half-carry
		flags.h = (reg.a % 0x10) - (value % 0x10) < 0

		local temp = reg.a - value

		-- carry (and overflow correction)
		flags.c = temp < 0 or temp > 0xFF
		temp  = (temp + 0x100) % 0x100

		flags.z = temp == 0
		flags.n = true
	end

	-- cp A, r
	opcodes[0xB8] = function() cp_with_a(reg.b) end
	opcodes[0xB9] = function() cp_with_a(reg.c) end
	opcodes[0xBA] = function() cp_with_a(reg.d) end
	opcodes[0xBB] = function() cp_with_a(reg.e) end
	opcodes[0xBC] = function() cp_with_a(reg.h) end
	opcodes[0xBD] = function() cp_with_a(reg.l) end
	opcode_cycles[0xBE] = 8
	opcodes[0xBE] = function() cp_with_a(read_at_hl()) end
	opcodes[0xBF] = function() cp_with_a(reg.a) end

	-- cp A, nn
	opcode_cycles[0xFE] = 8
	opcodes[0xFE] = function() cp_with_a(read_nn()) end
end

return apply
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX263411B397734245AC898E02643B955E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">inc_dec</string>
							<string name="ScriptGuid">{4E20D4ED-8DC1-4D04-AE9F-0E4ED974F51E}</string>
							<ProtectedString name="Source"><![CDATA[local lshift = bit32.lshift
local band = bit32.band

function apply(opcodes, opcode_cycles, z80, memory)
	local reg = z80.registers
	local flags = reg.flags

	local read_byte = memory.read_byte
	local write_byte = memory.write_byte

	set_inc_flags = function(value)
		flags.z = value == 0
		flags.h = value % 0x10 == 0x0
		flags.n = false
	end

	set_dec_flags = function(value)
		flags.z = value == 0
		flags.h = value % 0x10 == 0xF
		flags.n = true
	end

	-- inc r
	opcodes[0x04] = function() reg.b = band(reg.b + 1, 0xFF); set_inc_flags(reg.b) end
	opcodes[0x0C] = function() reg.c = band(reg.c + 1, 0xFF); set_inc_flags(reg.c) end
	opcodes[0x14] = function() reg.d = band(reg.d + 1, 0xFF); set_inc_flags(reg.d) end
	opcodes[0x1C] = function() reg.e = band(reg.e + 1, 0xFF); set_inc_flags(reg.e) end
	opcodes[0x24] = function() reg.h = band(reg.h + 1, 0xFF); set_inc_flags(reg.h) end
	opcodes[0x2C] = function() reg.l = band(reg.l + 1, 0xFF); set_inc_flags(reg.l) end
	opcode_cycles[0x34] = 12
	opcodes[0x34] = function()
		write_byte(reg.hl(), band(read_byte(reg.hl()) + 1, 0xFF))
		set_inc_flags(read_byte(reg.hl()))
	end
	opcodes[0x3C] = function() reg.a = band(reg.a + 1, 0xFF); set_inc_flags(reg.a) end

	-- dec r
	opcodes[0x05] = function() reg.b = band(reg.b - 1, 0xFF); set_dec_flags(reg.b) end
	opcodes[0x0D] = function() reg.c = band(reg.c - 1, 0xFF); set_dec_flags(reg.c) end
	opcodes[0x15] = function() reg.d = band(reg.d - 1, 0xFF); set_dec_flags(reg.d) end
	opcodes[0x1D] = function() reg.e = band(reg.e - 1, 0xFF); set_dec_flags(reg.e) end
	opcodes[0x25] = function() reg.h = band(reg.h - 1, 0xFF); set_dec_flags(reg.h) end
	opcodes[0x2D] = function() reg.l = band(reg.l - 1, 0xFF); set_dec_flags(reg.l) end
	opcode_cycles[0x35] = 12
	opcodes[0x35] = function()
		write_byte(reg.hl(), band(read_byte(reg.hl()) - 1, 0xFF))
		set_dec_flags(read_byte(reg.hl()))
	end
	opcodes[0x3D] = function() reg.a = band(reg.a - 1, 0xFF); set_dec_flags(reg.a) end
end

return apply
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX25EB8B9DB5494850AC48DFC8EFD57156">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">init</string>
							<string name="ScriptGuid">{99668368-32F7-4CE8-9CB2-3C8DD715E316}</string>
							<ProtectedString name="Source"><![CDATA[local lshift = bit32.lshift
local rshift = bit32.rshift
local band = bit32.band
local bxor = bit32.bxor
local bor = bit32.bor
local bnot = bit32.bnot

local gameboy = game.ReplicatedStorage.LuaGB.gameboy


local apply_arithmetic = require(gameboy.z80.arithmetic)
local apply_bitwise = require(gameboy.z80.bitwise)
local apply_call = require(gameboy.z80.call)
local apply_cp = require(gameboy.z80.cp)
local apply_inc_dec = require(gameboy.z80.inc_dec)
local apply_jp = require(gameboy.z80.jp)
local apply_ld = require(gameboy.z80.ld)
local apply_rl_rr_cb = require(gameboy.z80.rl_rr_cb)
local apply_stack = require(gameboy.z80.stack)

local Registers = require(gameboy.z80.registers)

local Z80 = {}

function Z80.new(modules)
	local z80 = {}

	local interrupts = modules.interrupts
	local io = modules.io
	local memory = modules.memory
	local timers = modules.timers

	-- local references, for shorter code
	local read_byte = memory.read_byte
	local write_byte = memory.write_byte

	z80.registers = Registers.new()
	local reg = z80.registers
	local flags = reg.flags

	-- Intentionally bad naming convention: I am NOT typing "registers"
	-- a bazillion times. The exported symbol uses the full name as a
	-- reasonable compromise.
	z80.halted = 0

	local add_cycles_normal = function(cycles)
		timers.system_clock = timers.system_clock + cycles
	end

	local add_cycles_double = function(cycles)
		timers.system_clock = timers.system_clock + cycles / 2
	end

	z80.add_cycles = add_cycles_normal

	z80.double_speed = false

	z80.reset = function(gameboy)
		-- Initialize registers to what the GB's
		-- iternal state would be after executing
		-- BIOS code

		flags.z = true
		flags.n = false
		flags.h = true
		flags.c = true

		if gameboy.type == gameboy.types.color then
			reg.a = 0x11
		else
			reg.a = 0x01
		end

		reg.b = 0x00
		reg.c = 0x13
		reg.d = 0x00
		reg.e = 0xD8
		reg.h = 0x01
		reg.l = 0x4D
		reg.pc = 0x100 --entrypoint for GB games
		reg.sp = 0xFFFE

		z80.halted = 0

		z80.double_speed = false
		z80.add_cycles = add_cycles_normal
		timers:set_normal_speed()
	end

	z80.save_state = function()
		local state = {}
		state.double_speed = z80.double_speed
		state.registers = z80.registers
		state.halted = z80.halted
		return state
	end

	z80.load_state = function(state)
		-- Note: doing this explicitly for safety, so as
		-- not to replace the table with external, possibly old / wrong structure
		flags.z = state.registers.flags.z
		flags.n = state.registers.flags.n
		flags.h = state.registers.flags.h
		flags.c = state.registers.flags.c

		z80.registers.a = state.registers.a
		z80.registers.b = state.registers.b
		z80.registers.c = state.registers.c
		z80.registers.d = state.registers.d
		z80.registers.e = state.registers.e
		z80.registers.h = state.registers.h
		z80.registers.l = state.registers.l
		z80.registers.pc = state.registers.pc
		z80.registers.sp = state.registers.sp

		z80.double_speed = state.double_speed
		if z80.double_speed then
			timers:set_double_speed()
		else
			timers:set_normal_speed()
		end
		z80.halted = state.halted
	end

	io.write_mask[0x4D] = 0x01

	local opcodes = {}
	local opcode_cycles = {}
	local opcode_names = {}

	-- Initialize the opcode_cycles table with 4 as a base cycle, so we only
	-- need to care about variations going forward
	for i = 0x00, 0xFF do
		opcode_cycles[i] = 4
	end

	function z80.read_at_hl()
		return memory.block_map[reg.h * 0x100][reg.h * 0x100 + reg.l]
	end

	function z80.set_at_hl(value)
		memory.block_map[reg.h * 0x100][reg.h * 0x100 + reg.l] = value
	end

	function z80.read_nn()
		local nn = read_byte(reg.pc)
		reg.pc = reg.pc + 1
		return nn
	end

	local read_at_hl = z80.read_at_hl
	local set_at_hl = z80.set_at_hl
	local read_nn = z80.read_nn

	apply_arithmetic(opcodes, opcode_cycles, z80, memory)
	apply_bitwise(opcodes, opcode_cycles, z80, memory)
	apply_call(opcodes, opcode_cycles, z80, memory, interrupts)
	apply_cp(opcodes, opcode_cycles, z80, memory)
	apply_inc_dec(opcodes, opcode_cycles, z80, memory)
	apply_jp(opcodes, opcode_cycles, z80, memory)
	apply_ld(opcodes, opcode_cycles, z80, memory)
	apply_rl_rr_cb(opcodes, opcode_cycles, z80, memory)
	apply_stack(opcodes, opcode_cycles, z80, memory)

	-- ====== GMB CPU-Controlcommands ======
	-- ccf
	opcodes[0x3F] = function()
		flags.c = not flags.c
		flags.n = false
		flags.h = false
	end

	-- scf
	opcodes[0x37] = function()
		flags.c = true
		flags.n = false
		flags.h = false
	end

	-- nop
	opcodes[0x00] = function() end

	-- halt
	opcodes[0x76] = function()
		--if interrupts_enabled == 1 then
		--print("Halting!")
		z80.halted = 1
		--else
		--print("Interrupts not enabled! Not actually halting...")
		--end
	end

	-- stop
	opcodes[0x10] = function()
		-- The stop opcode should always, for unknown reasons, be followed
		-- by an 0x00 data byte. If it isn't, this may be a sign that the
		-- emulator has run off the deep end, and this isn't a real STOP
		-- instruction.
		-- TODO: Research real hardware's behavior in these cases
		local stop_value = read_nn()
		if stop_value == 0x00 then
			print("STOP instruction not followed by NOP!")
			--halted = 1
		else
			print("Unimplemented WEIRDNESS after 0x10")
		end

		if band(io.ram[0x4D], 0x01) ~= 0 then
			--speed switch!
			print("Switching speeds!")
			if z80.double_speed then
				z80.add_cycles = add_cycles_normal
				z80.double_speed = false
				io.ram[0x4D] = band(io.ram[0x4D], 0x7E) + 0x00
				timers:set_normal_speed()
				print("Switched to Normal Speed")
			else
				z80.add_cycles = add_cycles_double
				z80.double_speed = true
				io.ram[0x4D] = band(io.ram[0x4D], 0x7E) + 0x80
				timers:set_double_speed()
				print("Switched to Double Speed")
			end
		end
	end

	-- di
	opcodes[0xF3] = function()
		interrupts.disable()
		--print("Disabled interrupts with DI")
	end
	-- ei
	opcodes[0xFB] = function()
		interrupts.enable()
		--print("Enabled interrupts with EI")
		z80.service_interrupt()
	end

	z80.service_interrupt = function()
		local fired = band(io.ram[0xFF], io.ram[0x0F])
		if fired ~= 0 then
			z80.halted = 0
			if interrupts.enabled ~= 0 then
				-- First, disable interrupts to prevent nesting routines (unless the program explicitly re-enables them later)
				interrupts.disable()

				-- Now, figure out which interrupt this is, and call the corresponding
				-- interrupt vector
				local vector = 0x40
				local count = 0
				while band(fired, 0x1) == 0 and count < 5 do
					vector = vector + 0x08
					fired = rshift(fired, 1)
					count = count + 1
				end
				-- we need to clear the corresponding bit first, to avoid infinite loops
				io.ram[0x0F] = bxor(lshift(0x1, count), io.ram[0x0F])

				reg.sp = band(0xFFFF, reg.sp - 1)
				write_byte(reg.sp, rshift(band(reg.pc, 0xFF00), 8))
				reg.sp = band(0xFFFF, reg.sp - 1)
				write_byte(reg.sp, band(reg.pc, 0xFF))

				reg.pc = vector

				z80.add_cycles(12)
				return true
			end
		end
		return false
	end

	-- register this as a callback with the interrupts module
	interrupts.service_handler = z80.service_interrupt

	-- For any opcodes that at this point are undefined,
	-- go ahead and "define" them with the following panic
	-- function
	local function undefined_opcode()
		local opcode = read_byte(band(reg.pc - 1, 0xFFFF))
		print(string.format("Unhandled opcode!: %x", opcode))
	end

	for i = 0, 0xFF do
		if not opcodes[i] then
			opcodes[i] = undefined_opcode
		end
	end

	z80.process_instruction = function()
		--  If the processor is currently halted, then do nothing.
		if z80.halted == 0 then
			local opcode = read_byte(reg.pc)
			-- Advance to one byte beyond the opcode
			reg.pc = band(reg.pc + 1, 0xFFFF)
			-- Run the instruction
			opcodes[opcode]()

			-- add a base clock of 4 to every instruction
			-- NOPE, working on removing add_cycles, pull from the opcode_cycles
			-- table instead
			z80.add_cycles(opcode_cycles[opcode])
		else
			-- Base cycles of 4 when halted, for sanity
			z80.add_cycles(4)
		end

		return true
	end

	return z80
end

return Z80
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX479450820985434CBD78A29B70BC3A14">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">jp</string>
							<string name="ScriptGuid">{D57B7504-9C30-413A-B092-9752415253DA}</string>
							<ProtectedString name="Source"><![CDATA[
local lshift = bit32.lshift
local rshift = bit32.rshift
local band = bit32.band
local bxor = bit32.bxor
local bor = bit32.bor
local bnor = bit32.bnor

function apply(opcodes, opcode_cycles, z80, memory)
	local read_nn = z80.read_nn
	local reg = z80.registers
	local flags = reg.flags

	local read_byte = memory.read_byte
	local write_byte = memory.write_byte

	-- ====== GMB Jumpcommands ======
	local jump_to_nnnn = function()
		local lower = read_nn()
		local upper = lshift(read_nn(), 8)
		reg.pc = upper + lower
	end

	-- jp nnnn
	opcode_cycles[0xC3] = 16
	opcodes[0xC3] = function()
		jump_to_nnnn()
	end

	-- jp HL
	opcodes[0xE9] = function()
		reg.pc = reg.hl()
	end

	-- jp nz, nnnn
	opcode_cycles[0xC2] = 16
	opcodes[0xC2] = function()
		if not flags.z then
			jump_to_nnnn()
		else
			reg.pc = reg.pc + 2
			z80.add_cycles(-4)
		end
	end

	-- jp nc, nnnn
	opcode_cycles[0xD2] = 16
	opcodes[0xD2] = function()
		if not flags.c then
			jump_to_nnnn()
		else
			reg.pc = reg.pc + 2
			z80.add_cycles(-4)
		end
	end

	-- jp z, nnnn
	opcode_cycles[0xCA] = 16
	opcodes[0xCA] = function()
		if flags.z then
			jump_to_nnnn()
		else
			reg.pc = reg.pc + 2
			z80.add_cycles(-4)
		end
	end

	-- jp c, nnnn
	opcode_cycles[0xDA] = 16
	opcodes[0xDA] = function()
		if flags.c then
			jump_to_nnnn()
		else
			reg.pc = reg.pc + 2
			z80.add_cycles(-4)
		end
	end

	local function jump_relative_to_nn()
		local offset = read_nn()
		if offset > 127 then
			offset = offset - 256
		end
		reg.pc = (reg.pc + offset) % 0x10000
	end

	-- jr nn
	opcode_cycles[0x18] = 12
	opcodes[0x18] = function()
		jump_relative_to_nn()
	end

	-- jr nz, nn
	opcode_cycles[0x20] = 12
	opcodes[0x20] = function()
		if not flags.z then
			jump_relative_to_nn()
		else
			reg.pc = reg.pc + 1
			z80.add_cycles(-4)
		end
	end

	-- jr nc, nn
	opcode_cycles[0x30] = 12
	opcodes[0x30] = function()
		if not flags.c then
			jump_relative_to_nn()
		else
			reg.pc = reg.pc + 1
			z80.add_cycles(-4)
		end
	end

	-- jr z, nn
	opcode_cycles[0x28] = 12
	opcodes[0x28] = function()
		if flags.z then
			jump_relative_to_nn()
		else
			reg.pc = reg.pc + 1
			z80.add_cycles(-4)
		end
	end

	-- jr c, nn
	opcode_cycles[0x38] = 12
	opcodes[0x38] = function()
		if flags.c then
			jump_relative_to_nn()
		else
			reg.pc = reg.pc + 1
			z80.add_cycles(-4)
		end
	end
end

return apply
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD0D4CF1B804D4C75A703330E4BD71AB4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ld</string>
							<string name="ScriptGuid">{1E66ED1D-7959-4D14-AE01-D81F8C733A9E}</string>
							<ProtectedString name="Source"><![CDATA[
local lshift = bit32.lshift
local rshift = bit32.rshift
local band = bit32.band

function apply(opcodes, opcode_cycles, z80, memory)
	local read_at_hl = z80.read_at_hl
	local set_at_hl = z80.set_at_hl
	local read_nn = z80.read_nn
	local reg = z80.registers

	local read_byte = memory.read_byte
	local write_byte = memory.write_byte

	-- ld r, r
	opcodes[0x40] = function() reg.b = reg.b end
	opcodes[0x41] = function() reg.b = reg.c end
	opcodes[0x42] = function() reg.b = reg.d end
	opcodes[0x43] = function() reg.b = reg.e end
	opcodes[0x44] = function() reg.b = reg.h end
	opcodes[0x45] = function() reg.b = reg.l end
	opcode_cycles[0x46] = 8
	opcodes[0x46] = function() reg.b = read_at_hl() end
	opcodes[0x47] = function() reg.b = reg.a end

	opcodes[0x48] = function() reg.c = reg.b end
	opcodes[0x49] = function() reg.c = reg.c end
	opcodes[0x4A] = function() reg.c = reg.d end
	opcodes[0x4B] = function() reg.c = reg.e end
	opcodes[0x4C] = function() reg.c = reg.h end
	opcodes[0x4D] = function() reg.c = reg.l end
	opcode_cycles[0x4E] = 8
	opcodes[0x4E] = function() reg.c = read_at_hl() end
	opcodes[0x4F] = function() reg.c = reg.a end

	opcodes[0x50] = function() reg.d = reg.b end
	opcodes[0x51] = function() reg.d = reg.c end
	opcodes[0x52] = function() reg.d = reg.d end
	opcodes[0x53] = function() reg.d = reg.e end
	opcodes[0x54] = function() reg.d = reg.h end
	opcodes[0x55] = function() reg.d = reg.l end
	opcode_cycles[0x56] = 8
	opcodes[0x56] = function() reg.d = read_at_hl() end
	opcodes[0x57] = function() reg.d = reg.a end

	opcodes[0x58] = function() reg.e = reg.b end
	opcodes[0x59] = function() reg.e = reg.c end
	opcodes[0x5A] = function() reg.e = reg.d end
	opcodes[0x5B] = function() reg.e = reg.e end
	opcodes[0x5C] = function() reg.e = reg.h end
	opcodes[0x5D] = function() reg.e = reg.l end
	opcode_cycles[0x5E] = 8
	opcodes[0x5E] = function() reg.e = read_at_hl() end
	opcodes[0x5F] = function() reg.e = reg.a end

	opcodes[0x60] = function() reg.h = reg.b end
	opcodes[0x61] = function() reg.h = reg.c end
	opcodes[0x62] = function() reg.h = reg.d end
	opcodes[0x63] = function() reg.h = reg.e end
	opcodes[0x64] = function() reg.h = reg.h end
	opcodes[0x65] = function() reg.h = reg.l end
	opcode_cycles[0x66] = 8
	opcodes[0x66] = function() reg.h = read_at_hl() end
	opcodes[0x67] = function() reg.h = reg.a end

	opcodes[0x68] = function() reg.l = reg.b end
	opcodes[0x69] = function() reg.l = reg.c end
	opcodes[0x6A] = function() reg.l = reg.d end
	opcodes[0x6B] = function() reg.l = reg.e end
	opcodes[0x6C] = function() reg.l = reg.h end
	opcodes[0x6D] = function() reg.l = reg.l end
	opcode_cycles[0x6E] = 8
	opcodes[0x6E] = function() reg.l = read_at_hl() end
	opcodes[0x6F] = function() reg.l = reg.a end

	opcode_cycles[0x70] = 8
	opcodes[0x70] = function() set_at_hl(reg.b) end

	opcode_cycles[0x71] = 8
	opcodes[0x71] = function() set_at_hl(reg.c) end

	opcode_cycles[0x72] = 8
	opcodes[0x72] = function() set_at_hl(reg.d) end

	opcode_cycles[0x73] = 8
	opcodes[0x73] = function() set_at_hl(reg.e) end

	opcode_cycles[0x74] = 8
	opcodes[0x74] = function() set_at_hl(reg.h) end

	opcode_cycles[0x75] = 8
	opcodes[0x75] = function() set_at_hl(reg.l) end

	-- 0x76 is HALT, we implement that elsewhere

	opcode_cycles[0x77] = 8
	opcodes[0x77] = function() set_at_hl(reg.a) end

	opcodes[0x78] = function() reg.a = reg.b end
	opcodes[0x79] = function() reg.a = reg.c end
	opcodes[0x7A] = function() reg.a = reg.d end
	opcodes[0x7B] = function() reg.a = reg.e end
	opcodes[0x7C] = function() reg.a = reg.h end
	opcodes[0x7D] = function() reg.a = reg.l end
	opcode_cycles[0x7E] = 8
	opcodes[0x7E] = function() reg.a = read_at_hl() end
	opcodes[0x7F] = function() reg.a = reg.a end

	-- ld r, n
	opcode_cycles[0x06] = 8
	opcodes[0x06] = function() reg.b = read_nn() end

	opcode_cycles[0x0E] = 8
	opcodes[0x0E] = function() reg.c = read_nn() end

	opcode_cycles[0x16] = 8
	opcodes[0x16] = function() reg.d = read_nn() end

	opcode_cycles[0x1E] = 8
	opcodes[0x1E] = function() reg.e = read_nn() end

	opcode_cycles[0x26] = 8
	opcodes[0x26] = function() reg.h = read_nn() end

	opcode_cycles[0x2E] = 8
	opcodes[0x2E] = function() reg.l = read_nn() end

	opcode_cycles[0x36] = 12
	opcodes[0x36] = function() set_at_hl(read_nn()) end

	opcode_cycles[0x3E] = 8
	opcodes[0x3E] = function() reg.a = read_nn() end

	-- ld A, (xx)
	opcode_cycles[0x0A] = 8
	opcodes[0x0A] = function()
		reg.a = read_byte(reg.bc())
	end

	opcode_cycles[0x1A] = 8
	opcodes[0x1A] = function()
		reg.a = read_byte(reg.de())
	end

	opcode_cycles[0xFA] = 16
	opcodes[0xFA] = function()
		local lower = read_nn()
		local upper = lshift(read_nn(), 8)
		reg.a = read_byte(upper + lower)
	end

	-- ld (xx), A
	opcode_cycles[0x02] = 8
	opcodes[0x02] = function()
		write_byte(reg.bc(), reg.a)
	end

	opcode_cycles[0x12] = 8
	opcodes[0x12] = function()
		write_byte(reg.de(), reg.a)
	end

	opcode_cycles[0xEA] = 16
	opcodes[0xEA] = function()
		local lower = read_nn()
		local upper = lshift(read_nn(), 8)
		write_byte(upper + lower, reg.a)
	end

	-- ld a, (FF00 + nn)
	opcode_cycles[0xF0] = 12
	opcodes[0xF0] = function()
		reg.a = read_byte(0xFF00 + read_nn())
	end

	-- ld (FF00 + nn), a
	opcode_cycles[0xE0] = 12
	opcodes[0xE0] = function()
		write_byte(0xFF00 + read_nn(), reg.a)
	end

	-- ld a, (FF00 + C)
	opcode_cycles[0xF2] = 8
	opcodes[0xF2] = function()
		reg.a = read_byte(0xFF00 + reg.c)
	end

	-- ld (FF00 + C), a
	opcode_cycles[0xE2] = 8
	opcodes[0xE2] = function()
		write_byte(0xFF00 + reg.c, reg.a)
	end
	
	-- link cable implementation
	opcode_cycles[0xFF01] = 8 -- Serial R/W
	opcodes[0xFF01] = function()
		print(read_byte(0xFF01 + reg.c))
		write_byte(0xFF01 + reg.c, reg.a)
	end
	
	opcode_cycles[0xFF02] = 8 -- Serial Transfer Control R/W
	opcodes[0xFF02] = function()
		print(read_byte(0xFF02 + reg.c))
	end

	-- ldi (HL), a
	opcode_cycles[0x22] = 8
	opcodes[0x22] = function()
		set_at_hl(reg.a)
		reg.set_hl(band(reg.hl() + 1, 0xFFFF))
	end

	-- ldi a, (HL)
	opcode_cycles[0x2A] = 8
	opcodes[0x2A] = function()
		reg.a = read_at_hl()
		reg.set_hl(band(reg.hl() + 1, 0xFFFF))
	end

	-- ldd (HL), a
	opcode_cycles[0x32] = 8
	opcodes[0x32] = function()
		set_at_hl(reg.a)
		reg.set_hl(band(reg.hl() - 1, 0xFFFF))
	end

	-- ldd a, (HL)
	opcode_cycles[0x3A] = 8
	opcodes[0x3A] = function()
		reg.a = read_at_hl()
		reg.set_hl(band(reg.hl() - 1, 0xFFFF))
	end

	-- ====== GMB 16-bit load commands ======
	-- ld BC, nnnn
	opcode_cycles[0x01] = 12
	opcodes[0x01] = function()
		reg.c = read_nn()
		reg.b = read_nn()
	end

	-- ld DE, nnnn
	opcode_cycles[0x11] = 12
	opcodes[0x11] = function()
		reg.e = read_nn()
		reg.d = read_nn()
	end

	-- ld HL, nnnn
	opcode_cycles[0x21] = 12
	opcodes[0x21] = function()
		reg.l = read_nn()
		reg.h = read_nn()
	end

	-- ld SP, nnnn
	opcode_cycles[0x31] = 12
	opcodes[0x31] = function()
		local lower = read_nn()
		local upper = lshift(read_nn(), 8)
		reg.sp = band(0xFFFF, upper + lower)
	end

	-- ld SP, HL
	opcode_cycles[0xF9] = 8
	opcodes[0xF9] = function()
		reg.sp = reg.hl()
	end

	-- ld HL, SP + dd
	opcode_cycles[0xF8] = 12
	opcodes[0xF8] = function()
		-- cheat
		local old_sp = reg.sp
		opcodes[0xE8]()
		reg.set_hl(reg.sp)
		reg.sp = old_sp
	end

	-- ====== GMB Special Purpose / Relocated Commands ======
	-- ld (nnnn), SP
	opcode_cycles[0x08] = 20
	opcodes[0x08] = function()
		local lower = read_nn()
		local upper = lshift(read_nn(), 8)
		local address = upper + lower
		write_byte(address, band(reg.sp, 0xFF))
		write_byte(band(address + 1, 0xFFFF), rshift(band(reg.sp, 0xFF00), 8))
	end
end

return apply
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX10F22ACC4C9147D0809751E4C245B312">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">registers</string>
							<string name="ScriptGuid">{4C42D996-EF35-4529-BA0E-202CAB943B9D}</string>
							<ProtectedString name="Source"><![CDATA[
local lshift = bit32.lshift
local band = bit32.band
local rshift = bit32.rshift

local Registers = {}

function Registers.new()
	local registers = {}
	local reg = registers

	reg.a = 0
	reg.b = 0
	reg.c = 0
	reg.d = 0
	reg.e = 0
	reg.flags = {z=false,n=false,h=false,c=false}
	reg.h = 0
	reg.l = 0
	reg.pc = 0
	reg.sp = 0

	reg.f = function()
		local value = 0
		if reg.flags.z then
			value = value + 0x80
		end
		if reg.flags.n then
			value = value + 0x40
		end
		if reg.flags.h then
			value = value + 0x20
		end
		if reg.flags.c then
			value = value + 0x10
		end
		return value
	end

	reg.set_f = function(value)
		reg.flags.z = band(value, 0x80) ~= 0
		reg.flags.n = band(value, 0x40) ~= 0
		reg.flags.h = band(value, 0x20) ~= 0
		reg.flags.c = band(value, 0x10) ~= 0
	end

	reg.af = function()
		return lshift(reg.a, 8) + reg.f()
	end

	reg.bc = function()
		return lshift(reg.b, 8) + reg.c
	end

	reg.de = function()
		return lshift(reg.d, 8) + reg.e
	end

	reg.hl = function()
		return lshift(reg.h, 8) + reg.l
	end

	reg.set_bc = function(value)
		reg.b = rshift(band(value, 0xFF00), 8)
		reg.c = band(value, 0xFF)
	end

	reg.set_de = function(value)
		reg.d = rshift(band(value, 0xFF00), 8)
		reg.e = band(value, 0xFF)
	end

	reg.set_hl = function(value)
		reg.h = rshift(band(value, 0xFF00), 8)
		reg.l = band(value, 0xFF)
	end

	return registers
end

return Registers
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5F1DC7AE083B4AC8BEEEF69603E4D639">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">rl_rr_cb</string>
							<string name="ScriptGuid">{C24379CF-3954-4669-AF7C-3DB516DFF850}</string>
							<ProtectedString name="Source"><![CDATA[
local lshift = bit32.lshift
local rshift = bit32.rshift
local band = bit32.band
local bxor = bit32.bxor
local bor = bit32.bor
local bnor = bit32.bnor

function apply(opcodes, opcode_cycles, z80, memory)
	local read_nn = z80.read_nn
	local reg = z80.registers
	local flags = reg.flags

	local read_byte = memory.read_byte
	local write_byte = memory.write_byte

	local add_cycles = z80.add_cycles

	-- ====== GMB Rotate and Shift Commands ======
	local reg_rlc = function(value)
		value = lshift(value, 1)
		-- move what would be bit 8 into the carry
		flags.c = band(value, 0x100) ~= 0
		value = band(value, 0xFF)
		-- also copy the carry into bit 0
		if flags.c then
			value = value + 1
		end
		flags.z = value == 0
		flags.h = false
		flags.n = false
		return value
	end

	local reg_rl = function(value)
		value = lshift(value, 1)
		-- move the carry into bit 0
		if flags.c then
			value = value + 1
		end
		-- now move what would be bit 8 into the carry
		flags.c = band(value, 0x100) ~= 0
		value = band(value, 0xFF)

		flags.z = value == 0
		flags.h = false
		flags.n = false
		return value
	end

	local reg_rrc = function(value)
		-- move bit 0 into the carry
		flags.c = band(value, 0x1) ~= 0
		value = rshift(value, 1)
		-- also copy the carry into bit 7
		if flags.c then
			value = value + 0x80
		end
		flags.z = value == 0
		flags.h = false
		flags.n = false
		return value
	end

	local reg_rr = function(value)
		-- first, copy the carry into bit 8 (!!)
		if flags.c then
			value = value + 0x100
		end
		-- move bit 0 into the carry
		flags.c = band(value, 0x1) ~= 0
		value = rshift(value, 1)
		-- for safety, this should be a nop?
		-- value = band(value, 0xFF)
		flags.z = value == 0
		flags.h = false
		flags.n = false
		return value
	end

	-- rlc a
	opcodes[0x07] = function() reg.a = reg_rlc(reg.a); flags.z = false end

	-- rl a
	opcodes[0x17] = function() reg.a = reg_rl(reg.a); flags.z = false end

	-- rrc a
	opcodes[0x0F] = function() reg.a = reg_rrc(reg.a); flags.z = false end

	-- rr a
	opcodes[0x1F] = function() reg.a = reg_rr(reg.a); flags.z = false end

	-- ====== CB: Extended Rotate and Shift ======

	cb = {}

	-- rlc r
	cb[0x00] = function() reg.b = reg_rlc(reg.b); add_cycles(4) end
	cb[0x01] = function() reg.c = reg_rlc(reg.c); add_cycles(4) end
	cb[0x02] = function() reg.d = reg_rlc(reg.d); add_cycles(4) end
	cb[0x03] = function() reg.e = reg_rlc(reg.e); add_cycles(4) end
	cb[0x04] = function() reg.h = reg_rlc(reg.h); add_cycles(4) end
	cb[0x05] = function() reg.l = reg_rlc(reg.l); add_cycles(4) end
	cb[0x06] = function() write_byte(reg.hl(), reg_rlc(read_byte(reg.hl()))); add_cycles(12) end
	cb[0x07] = function() reg.a = reg_rlc(reg.a); add_cycles(4) end

	-- rl r
	cb[0x10] = function() reg.b = reg_rl(reg.b); add_cycles(4) end
	cb[0x11] = function() reg.c = reg_rl(reg.c); add_cycles(4) end
	cb[0x12] = function() reg.d = reg_rl(reg.d); add_cycles(4) end
	cb[0x13] = function() reg.e = reg_rl(reg.e); add_cycles(4) end
	cb[0x14] = function() reg.h = reg_rl(reg.h); add_cycles(4) end
	cb[0x15] = function() reg.l = reg_rl(reg.l); add_cycles(4) end
	cb[0x16] = function() write_byte(reg.hl(), reg_rl(read_byte(reg.hl()))); add_cycles(12) end
	cb[0x17] = function() reg.a = reg_rl(reg.a); add_cycles(4) end

	-- rrc r
	cb[0x08] = function() reg.b = reg_rrc(reg.b); add_cycles(4) end
	cb[0x09] = function() reg.c = reg_rrc(reg.c); add_cycles(4) end
	cb[0x0A] = function() reg.d = reg_rrc(reg.d); add_cycles(4) end
	cb[0x0B] = function() reg.e = reg_rrc(reg.e); add_cycles(4) end
	cb[0x0C] = function() reg.h = reg_rrc(reg.h); add_cycles(4) end
	cb[0x0D] = function() reg.l = reg_rrc(reg.l); add_cycles(4) end
	cb[0x0E] = function() write_byte(reg.hl(), reg_rrc(read_byte(reg.hl()))); add_cycles(12) end
	cb[0x0F] = function() reg.a = reg_rrc(reg.a); add_cycles(4) end

	-- rl r
	cb[0x18] = function() reg.b = reg_rr(reg.b); add_cycles(4) end
	cb[0x19] = function() reg.c = reg_rr(reg.c); add_cycles(4) end
	cb[0x1A] = function() reg.d = reg_rr(reg.d); add_cycles(4) end
	cb[0x1B] = function() reg.e = reg_rr(reg.e); add_cycles(4) end
	cb[0x1C] = function() reg.h = reg_rr(reg.h); add_cycles(4) end
	cb[0x1D] = function() reg.l = reg_rr(reg.l); add_cycles(4) end
	cb[0x1E] = function() write_byte(reg.hl(), reg_rr(read_byte(reg.hl()))); add_cycles(12) end
	cb[0x1F] = function() reg.a = reg_rr(reg.a); add_cycles(4) end

	local reg_sla = function(value)
		-- copy bit 7 into carry
		flags.c = band(value, 0x80) == 0x80
		value = band(lshift(value, 1), 0xFF)
		flags.z = value == 0
		flags.h = false
		flags.n = false
		add_cycles(4)
		return value
	end

	local reg_srl = function(value)
		-- copy bit 0 into carry
		flags.c = band(value, 0x1) == 1
		value = rshift(value, 1)
		flags.z = value == 0
		flags.h = false
		flags.n = false
		add_cycles(4)
		return value
	end

	local reg_sra = function(value)
		local arith_value = reg_srl(value)
		-- if bit 6 is set, copy it to bit 7
		if band(arith_value, 0x40) ~= 0 then
			arith_value = arith_value + 0x80
		end
		add_cycles(4)
		return arith_value
	end

	local reg_swap = function(value)
		value = rshift(band(value, 0xF0), 4) + lshift(band(value, 0xF), 4)
		flags.z = value == 0
		flags.n = false
		flags.h = false
		flags.c = false
		add_cycles(4)
		return value
	end

	-- sla r
	cb[0x20] = function() reg.b = reg_sla(reg.b) end
	cb[0x21] = function() reg.c = reg_sla(reg.c) end
	cb[0x22] = function() reg.d = reg_sla(reg.d) end
	cb[0x23] = function() reg.e = reg_sla(reg.e) end
	cb[0x24] = function() reg.h = reg_sla(reg.h) end
	cb[0x25] = function() reg.l = reg_sla(reg.l) end
	cb[0x26] = function() write_byte(reg.hl(), reg_sla(read_byte(reg.hl()))); add_cycles(8) end
	cb[0x27] = function() reg.a = reg_sla(reg.a) end

	-- swap r (high and low nybbles)
	cb[0x30] = function() reg.b = reg_swap(reg.b) end
	cb[0x31] = function() reg.c = reg_swap(reg.c) end
	cb[0x32] = function() reg.d = reg_swap(reg.d) end
	cb[0x33] = function() reg.e = reg_swap(reg.e) end
	cb[0x34] = function() reg.h = reg_swap(reg.h) end
	cb[0x35] = function() reg.l = reg_swap(reg.l) end
	cb[0x36] = function() write_byte(reg.hl(), reg_swap(read_byte(reg.hl()))); add_cycles(8) end
	cb[0x37] = function() reg.a = reg_swap(reg.a) end

	-- sra r
	cb[0x28] = function() reg.b = reg_sra(reg.b); add_cycles(-4) end
	cb[0x29] = function() reg.c = reg_sra(reg.c); add_cycles(-4) end
	cb[0x2A] = function() reg.d = reg_sra(reg.d); add_cycles(-4) end
	cb[0x2B] = function() reg.e = reg_sra(reg.e); add_cycles(-4) end
	cb[0x2C] = function() reg.h = reg_sra(reg.h); add_cycles(-4) end
	cb[0x2D] = function() reg.l = reg_sra(reg.l); add_cycles(-4) end
	cb[0x2E] = function() write_byte(reg.hl(), reg_sra(read_byte(reg.hl()))); add_cycles(4) end
	cb[0x2F] = function() reg.a = reg_sra(reg.a); add_cycles(-4) end

	-- srl r
	cb[0x38] = function() reg.b = reg_srl(reg.b) end
	cb[0x39] = function() reg.c = reg_srl(reg.c) end
	cb[0x3A] = function() reg.d = reg_srl(reg.d) end
	cb[0x3B] = function() reg.e = reg_srl(reg.e) end
	cb[0x3C] = function() reg.h = reg_srl(reg.h) end
	cb[0x3D] = function() reg.l = reg_srl(reg.l) end
	cb[0x3E] = function() write_byte(reg.hl(), reg_srl(read_byte(reg.hl()))); add_cycles(8) end
	cb[0x3F] = function() reg.a = reg_srl(reg.a) end

	-- ====== GMB Singlebit Operation Commands ======
	local reg_bit = function(value, bit)
		flags.z = band(value, lshift(0x1, bit)) == 0
		flags.n = false
		flags.h = true
		return
	end

	opcodes[0xCB] = function()
		local cb_op = read_nn()
		add_cycles(4)
		if cb[cb_op] ~= nil then
			--revert the timing; this is handled automatically by the various functions
			add_cycles(-4)
			cb[cb_op]()
			return
		end
		local high_half_nybble = rshift(band(cb_op, 0xC0), 6)
		local reg_index = band(cb_op, 0x7)
		local bit = rshift(band(cb_op, 0x38), 3)
		if high_half_nybble == 0x1 then
			-- bit n,r
			if reg_index == 0 then reg_bit(reg.b, bit) end
			if reg_index == 1 then reg_bit(reg.c, bit) end
			if reg_index == 2 then reg_bit(reg.d, bit) end
			if reg_index == 3 then reg_bit(reg.e, bit) end
			if reg_index == 4 then reg_bit(reg.h, bit) end
			if reg_index == 5 then reg_bit(reg.l, bit) end
			if reg_index == 6 then reg_bit(read_byte(reg.hl()), bit); add_cycles(4) end
			if reg_index == 7 then reg_bit(reg.a, bit) end
		end
		if high_half_nybble == 0x2 then
			-- res n, r
			-- note: this is REALLY stupid, but it works around some floating point
			-- limitations in Lua.
			if reg_index == 0 then reg.b = band(reg.b, bxor(reg.b, lshift(0x1, bit))) end
			if reg_index == 1 then reg.c = band(reg.c, bxor(reg.c, lshift(0x1, bit))) end
			if reg_index == 2 then reg.d = band(reg.d, bxor(reg.d, lshift(0x1, bit))) end
			if reg_index == 3 then reg.e = band(reg.e, bxor(reg.e, lshift(0x1, bit))) end
			if reg_index == 4 then reg.h = band(reg.h, bxor(reg.h, lshift(0x1, bit))) end
			if reg_index == 5 then reg.l = band(reg.l, bxor(reg.l, lshift(0x1, bit))) end
			if reg_index == 6 then write_byte(reg.hl(), band(read_byte(reg.hl()), bxor(read_byte(reg.hl()), lshift(0x1, bit)))); add_cycles(8) end
			if reg_index == 7 then reg.a = band(reg.a, bxor(reg.a, lshift(0x1, bit))) end
		end

		if high_half_nybble == 0x3 then
			-- set n, r
			if reg_index == 0 then reg.b = bor(lshift(0x1, bit), reg.b) end
			if reg_index == 1 then reg.c = bor(lshift(0x1, bit), reg.c) end
			if reg_index == 2 then reg.d = bor(lshift(0x1, bit), reg.d) end
			if reg_index == 3 then reg.e = bor(lshift(0x1, bit), reg.e) end
			if reg_index == 4 then reg.h = bor(lshift(0x1, bit), reg.h) end
			if reg_index == 5 then reg.l = bor(lshift(0x1, bit), reg.l) end
			if reg_index == 6 then write_byte(reg.hl(), bor(lshift(0x1, bit), read_byte(reg.hl()))); add_cycles(8) end
			if reg_index == 7 then reg.a = bor(lshift(0x1, bit), reg.a) end
		end
	end
end

return apply
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXBA0E4899FE0D45B09579FF5E2D4AE0A9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">stack</string>
							<string name="ScriptGuid">{066D0796-0BA2-49C1-81EF-1EDAD8860CAC}</string>
							<ProtectedString name="Source"><![CDATA[local band = bit32.band
local lshift = bit32.lshift
local rshift = bit32.rshift

function apply(opcodes, opcode_cycles, z80, memory)
	local reg = z80.registers

	local read_byte = memory.read_byte
	local write_byte = memory.write_byte

	-- push BC
	opcode_cycles[0xC5] = 16
	opcodes[0xC5] = function()
		reg.sp = band(0xFFFF, reg.sp - 1)
		write_byte(reg.sp, reg.b)
		reg.sp = band(0xFFFF, reg.sp - 1)
		write_byte(reg.sp, reg.c)
	end

	-- push DE
	opcode_cycles[0xD5] = 16
	opcodes[0xD5] = function()
		reg.sp = band(0xFFFF, reg.sp - 1)
		write_byte(reg.sp, reg.d)
		reg.sp = band(0xFFFF, reg.sp - 1)
		write_byte(reg.sp, reg.e)
	end

	-- push HL
	opcode_cycles[0xE5] = 16
	opcodes[0xE5] = function()
		reg.sp = band(0xFFFF, reg.sp - 1)
		write_byte(reg.sp, reg.h)
		reg.sp = band(0xFFFF, reg.sp - 1)
		write_byte(reg.sp, reg.l)
	end

	-- push AF
	opcode_cycles[0xF5] = 16
	opcodes[0xF5] = function()
		reg.sp = band(0xFFFF, reg.sp - 1)
		write_byte(reg.sp, reg.a)
		reg.sp = band(0xFFFF, reg.sp - 1)
		write_byte(reg.sp, reg.f())
	end

	-- pop BC
	opcode_cycles[0xC1] = 12
	opcodes[0xC1] = function()
		reg.c = read_byte(reg.sp)
		reg.sp = band(0xFFFF, reg.sp + 1)
		reg.b = read_byte(reg.sp)
		reg.sp = band(0xFFFF, reg.sp + 1)
	end

	-- pop DE
	opcode_cycles[0xD1] = 12
	opcodes[0xD1] = function()
		reg.e = read_byte(reg.sp)
		reg.sp = band(0xFFFF, reg.sp + 1)
		reg.d = read_byte(reg.sp)
		reg.sp = band(0xFFFF, reg.sp + 1)
	end

	-- pop HL
	opcode_cycles[0xE1] = 12
	opcodes[0xE1] = function()
		reg.l = read_byte(reg.sp)
		reg.sp = band(0xFFFF, reg.sp + 1)
		reg.h = read_byte(reg.sp)
		reg.sp = band(0xFFFF, reg.sp + 1)
	end

	-- pop AF
	opcode_cycles[0xF1] = 12
	opcodes[0xF1] = function()
		reg.set_f(read_byte(reg.sp))
		reg.sp = band(0xFFFF, reg.sp + 1)
		reg.a = read_byte(reg.sp)
		reg.sp = band(0xFFFF, reg.sp + 1)
	end
end

return apply
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX3CB79D21DCEC468EA08C89D6B8FC13D8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">audio</string>
						<string name="ScriptGuid">{85C46E73-D061-4719-8E9B-0F7227284076}</string>
						<ProtectedString name="Source"><![CDATA[local Audio = {}

function Audio.new(modules)
	local io = modules.io
	local timers = modules.timers
	local ports = io.ports

	local audio = {}

	-- Note: for simplicity, we sample at 44100 Hz. Deal. I'll not bother
	-- to implement any other sampling frequencies until this is more stable.

	audio.buffer = {}
	audio.tone1 = {}
	audio.tone2 = {}
	audio.wave3 = {}
	audio.noise4 = {}

	local next_sample = 0
	local next_sample_cycle = 0

	audio.reset = function()
		audio.tone1.debug_disabled = false
		audio.tone1.period = 128 -- in cycles
		audio.tone1.volume_initial = 0
		audio.tone1.volume_direction = 1
		audio.tone1.volume_step_length = 0 -- in cycles
		audio.tone1.max_length = 0          -- in cycles
		audio.tone1.continuous = false
		audio.tone1.duty_length = .75       -- percentage, from 0-1
		audio.tone1.wave_pattern = 0
		audio.tone1.base_cycle = 0
		audio.tone1.frequency_last_update = 0 -- in cycles
		audio.tone1.wave_duty_counter = 0
		audio.tone1.period_counter = 0
		audio.tone1.frequency_target = 0
		audio.tone1.frequency_shadow = 0
		audio.tone1.frequency_shift_time = 0 -- in cycles, 0 == disabled
		audio.tone1.frequency_shift_counter = 0 -- should be reset on trigger
		audio.tone1.frequency_shift_direction = 1
		audio.tone1.frequency_shift_amount = 0
		audio.tone1.active = false

		audio.tone2.debug_disabled = false
		audio.tone2.period = 128 -- in cycles
		audio.tone2.volume_initial = 0
		audio.tone2.volume_direction = 1
		audio.tone2.volume_step_length = 0 -- in cycles
		audio.tone2.max_length = 0          -- in cycles
		audio.tone2.continuous = false
		audio.tone2.duty_length = .75       -- percentage, from 0-1
		audio.tone2.wave_pattern = 0
		audio.tone2.base_cycle = 0
		audio.tone2.frequency_last_update = 0 -- in cycles
		audio.tone2.period_counter = 0
		audio.tone2.wave_duty_counter = 0
		audio.tone2.frequency_shadow = 0
		audio.tone2.active = false

		audio.wave3.debug_disabled = false
		audio.wave3.enabled = false
		audio.wave3.max_length = 0 -- in cycles
		audio.wave3.volume_shift = 0
		audio.wave3.period = 0 -- in cycles
		audio.wave3.continuous = false
		audio.wave3.base_cycle = 0
		audio.wave3.frequency_last_update = 0 -- in cycles
		audio.wave3.period_counter = 0
		audio.wave3.sample_index = 0
		audio.wave3.frequency_shadow = 0
		audio.wave3.active = false

		audio.noise4.debug_disabled = false
		audio.noise4.volume_initial = 0
		audio.noise4.volume_direction = 1
		audio.noise4.volume_step_length = 0 -- in cycles
		audio.noise4.max_length = 0          -- in cycles
		audio.noise4.continuous = false
		audio.noise4.base_cycle = 0
		audio.noise4.polynomial_period = 16
		audio.noise4.polynomial_lfsr = 0x7FFF -- 15 bits
		audio.noise4.polynomial_last_shift = 0 -- in cycles
		audio.noise4.polynomial_wide = true
		audio.noise4.active = false

		next_sample = 0
		next_sample_cycle = 0

		-- initialize audio registers
		-- pulled from: http://bgb.bircd.org/pandocs.htm#powerupsequence
		io.ram[0x10] = 0x80
		io.ram[0x11] = 0xBF
		io.ram[0x12] = 0xF3
		io.ram[0x14] = 0xBF
		io.ram[0x16] = 0x3F
		io.ram[0x17] = 0x00
		io.ram[0x19] = 0xBF
		io.ram[0x1A] = 0x7F
		io.ram[0x1B] = 0xFF
		io.ram[0x1C] = 0x9F
		io.ram[0x1E] = 0xBF
		io.ram[0x20] = 0xFF
		io.ram[0x21] = 0x00
		io.ram[0x22] = 0x00
		io.ram[0x23] = 0xBF
		io.ram[0x24] = 0x77
		io.ram[0x25] = 0xF3
		io.ram[0x26] = 0xF1
	end

	audio.initialize = function()
		for i = 0, 32768 do
			audio.buffer[i] = 0
		end

		audio.reset()
	end

	audio.save_state = function()
		local state = {}
		state.next_sample_cycle = next_sample_cycle
		return state
	end

	audio.load_state = function(state)
		next_sample_cycle = state.next_sample_cycle
	end

	local wave_patterns = {}
	wave_patterns[0] = .125
	wave_patterns[1] = .25
	wave_patterns[2] = .50
	wave_patterns[3] = .75

	local wave_pattern_tables = {}
	wave_pattern_tables[0] = {0,0,0,0,0,0,0,1}
	wave_pattern_tables[1] = {1,0,0,0,0,0,0,1}
	wave_pattern_tables[2] = {1,0,0,0,0,1,1,1}
	wave_pattern_tables[3] = {0,1,1,1,1,1,1,0}

	io.read_logic[0x26] = function()
		local high_nybble = bit32.band(0xF0, io.ram[0x26])
		local low_nybble = 0
		if audio.tone1.active then
			low_nybble = low_nybble + 0x01
		end
		if audio.tone2.active then
			low_nybble = low_nybble + 0x02
		end
		if audio.wave3.active then
			low_nybble = low_nybble + 0x04
		end
		if audio.noise4.active then
			low_nybble = low_nybble + 0x08
		end
		return high_nybble + low_nybble
	end

	io.write_logic[ports.NR10] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR10] = byte
		local sweep_time = bit32.rshift(bit32.band(byte, 0x70), 4)
		audio.tone1.frequency_shift_time = sweep_time * 32768
		if bit32.band(byte, 0x08) ~= 0 then
			audio.tone1.frequency_shift_direction = -1
		else
			audio.tone1.frequency_shift_direction = 1
		end
		audio.tone1.frequency_shift_amount = bit32.band(byte, 0x07)
	end

	-- Channel 1 Sound Length / Wave Pattern Duty
	io.write_logic[ports.NR11] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR11] = byte
		local wave_pattern = bit32.rshift(bit32.band(byte, 0xC0), 6)
		audio.tone1.duty_length = wave_patterns[wave_pattern]
		audio.tone1.wave_pattern = wave_pattern
		local length_data = bit32.band(byte, 0x3F)
		local length_cycles = (64 - length_data) * 16384
		audio.tone1.max_length = length_cycles
	end

	-- Channel 1 Volume Envelope
	io.write_logic[ports.NR12] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR12] = byte
		audio.tone1.volume_initial = bit32.rshift(bit32.band(byte, 0xF0), 4)
		local direction = bit32.band(byte, 0x08)
		if direction > 0 then
			audio.tone1.volume_direction = 1
		else
			audio.tone1.volume_direction = -1
		end
		local envelope_step_data = bit32.band(byte, 0x07)
		local envelope_step_cycles = envelope_step_data * 65536
		audio.tone1.volume_step_length = envelope_step_cycles
	end

	-- Channel 1 Frequency - Low Bits
	io.write_logic[ports.NR13] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR13] = byte
		local freq_high = bit32.lshift(bit32.band(io.ram[ports.NR14], 0x07), 8)
		local freq_low = byte
		local freq_value = freq_high + freq_low
		audio.tone1.period = 32 * (2048 - freq_value)
		audio.tone1.frequency_shadow = freq_value
	end

	-- Channel 1 Frequency and Trigger - High Bits
	io.write_logic[ports.NR14] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR14] = byte
		local restart = (bit32.band(byte, 0x80) ~= 0)
		local continuous = (bit32.band(byte, 0x40) == 0)
		local freq_high = bit32.lshift(bit32.band(byte, 0x07), 8)
		local freq_low = io.ram[ports.NR13]
		local freq_value = freq_high + freq_low

		audio.tone1.period = 32 * (2048 - freq_value)
		audio.tone1.continuous = continuous
		if restart then
			audio.tone1.base_cycle = timers.system_clock
			audio.tone1.active = true
		end
		audio.tone1.frequency_shadow = freq_value
		audio.tone1.period_conter = (2048 - freq_value)
		audio.tone1.frequency_shift_counter = 0
	end

	-- Channel 2 Sound Length / Wave Pattern Duty
	io.write_logic[ports.NR21] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR21] = byte
		local wave_pattern = bit32.rshift(bit32.band(byte, 0xC0), 6)
		audio.tone2.duty_length = wave_patterns[wave_pattern]
		audio.tone2.wave_pattern = wave_pattern
		local length_data = bit32.band(byte, 0x3F)
		local length_cycles = (64 - length_data) * 16384
		audio.tone2.max_length = length_cycles
	end

	-- Channel 2 Volume Envelope
	io.write_logic[ports.NR22] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR22] = byte
		audio.tone2.volume_initial = bit32.rshift(bit32.band(byte, 0xF0), 4)
		local direction = bit32.band(byte, 0x08)
		if direction > 0 then
			audio.tone2.volume_direction = 1
		else
			audio.tone2.volume_direction = -1
		end
		local envelope_step_data = bit32.band(byte, 0x07)
		local envelope_step_cycles = envelope_step_data * 65536
		audio.tone2.volume_step_length = envelope_step_cycles
	end

	-- Channel 2 Frequency - Low Bits
	io.write_logic[ports.NR23] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR23] = byte
		local freq_high = bit32.lshift(bit32.band(io.ram[ports.NR24], 0x07), 8)
		local freq_low = byte
		local freq_value = freq_high + freq_low
		audio.tone2.period = 32 * (2048 - freq_value)
		audio.tone2.frequency_shadow = freq_value
	end

	-- Channel 2 Frequency and Trigger - High Bits
	io.write_logic[ports.NR24] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR24] = byte
		local restart = (bit32.band(byte, 0x80) ~= 0)
		local continuous = (bit32.band(byte, 0x40) == 0)
		local freq_high = bit32.lshift(bit32.band(byte, 0x07), 8)
		local freq_low = io.ram[ports.NR23]
		local freq_value = freq_high + freq_low

		audio.tone2.period = 32 * (2048 - freq_value)
		audio.tone2.period_conter = (2048 - freq_value)
		audio.tone2.frequency_shadow = freq_value
		audio.tone2.continuous = continuous
		if restart then
			audio.tone2.base_cycle = timers.system_clock
			audio.tone2.active = true
		end
	end

	-- Channel 3 Enabled
	io.write_logic[ports.NR30] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR30] = byte
		audio.wave3.enabled = bit32.band(byte, 0x80) ~= 0
	end

	-- Channel 3 Length
	io.write_logic[ports.NR31] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR31] = byte
		local length_cycles = (256 - byte) * 4096
		audio.wave3.max_length = length_cycles
	end

	-- Channel 3 Volume
	local volume_shift_mappings = {}
	volume_shift_mappings[0] = 4
	volume_shift_mappings[1] = 0
	volume_shift_mappings[2] = 1
	volume_shift_mappings[3] = 2
	io.write_logic[ports.NR32] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR32] = byte
		local volume_select = bit32.rshift(bit32.band(byte, 0x60), 5)
		audio.wave3.volume_shift = volume_shift_mappings[volume_select]
	end

	-- Channel 3 Frequency - Low Bits
	io.write_logic[ports.NR33] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR33] = byte
		local freq_high = bit32.lshift(bit32.band(io.ram[ports.NR34], 0x07), 8)
		local freq_low = byte
		local freq_value = freq_high + freq_low
		audio.wave3.period = 64 * (2048 - freq_value)
		audio.wave3.frequency_shadow = freq_value
	end

	-- Channel 3 Frequency and Trigger - High Bits
	io.write_logic[ports.NR34] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR34] = byte
		local restart = (bit32.band(byte, 0x80) ~= 0)
		local continuous = (bit32.band(byte, 0x40) == 0)
		local freq_high = bit32.lshift(bit32.band(byte, 0x07), 8)
		local freq_low = io.ram[ports.NR33]
		local freq_value = freq_high + freq_low

		audio.wave3.period = 64 * (2048 - freq_value)
		audio.wave3.period_conter = (2048 - freq_value)
		audio.wave3.frequency_shadow = freq_value
		audio.wave3.continuous = continuous
		if restart then
			audio.wave3.base_cycle = timers.system_clock
			audio.wave3.sample_index = 0
			audio.wave3.active = true
		end
	end

	-- Channel 4 Length
	io.write_logic[ports.NR41] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR41] = byte
		local wave_pattern = bit32.rshift(bit32.band(byte, 0xC0), 6)
		audio.noise4.duty_length = wave_patterns[wave_pattern]
		local length_data = bit32.band(byte, 0x3F)
		local length_cycles = (64 - length_data) * 16384
		audio.noise4.max_length = length_cycles
	end

	-- Channel 4 Volume Envelope
	io.write_logic[ports.NR42] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR42] = byte
		audio.noise4.volume_initial = bit32.rshift(bit32.band(byte, 0xF0), 4)
		local direction = bit32.band(byte, 0x08)
		if direction > 0 then
			audio.noise4.volume_direction = 1
		else
			audio.noise4.volume_direction = -1
		end
		local envelope_step_data = bit32.band(byte, 0x07)
		local envelope_step_cycles = envelope_step_data * 65536
		audio.noise4.volume_step_length = envelope_step_cycles
	end

	local polynomial_divisors = {}
	polynomial_divisors[0] = 8
	polynomial_divisors[1] = 16
	polynomial_divisors[2] = 32
	polynomial_divisors[3] = 48
	polynomial_divisors[4] = 64
	polynomial_divisors[5] = 80
	polynomial_divisors[6] = 96
	polynomial_divisors[7] = 112

	-- Channel 4 Polynomial Counter
	io.write_logic[ports.NR43] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR43] = byte
		local shift_clock_frequency = bit32.rshift(bit32.band(byte, 0xF0), 4)
		local wide_step = bit32.band(byte, 0x08) == 0
		local dividing_ratio = polynomial_divisors[bit32.band(byte, 0x07)]

		-- Maybe?
		audio.noise4.polynomial_period = bit32.lshift(dividing_ratio, shift_clock_frequency)
		audio.noise4.polynomial_wide = wide_step
	end

	-- Channel 4 Trigger
	io.write_logic[ports.NR44] = function(byte)
		audio.generate_pending_samples()
		io.ram[ports.NR44] = byte
		local restart = (bit32.band(byte, 0x80) ~= 0)
		local continuous = (bit32.band(byte, 0x40) == 0)

		audio.noise4.continuous = continuous
		if restart then
			audio.noise4.base_cycle = timers.system_clock
			-- Reset the LSFR to all 1's
			audio.noise4.polynomial_lfsr = 0x7FFF
			audio.noise4.active = true
		end
	end

	audio.tone1.update_frequency_shift = function(clock_cycle)
		local tone1 = audio.tone1
		-- A shift_time of 0 disables frequency shifting entirely
		if tone1.frequency_shift_time > 0 then
			local next_edge = tone1.base_cycle + tone1.frequency_shift_time * tone1.frequency_shift_counter
			if clock_cycle >= next_edge then
				local adjustment = bit32.rshift(tone1.frequency_shadow, tone1.frequency_shift_amount) * tone1.frequency_shift_direction
				tone1.frequency_shadow = tone1.frequency_shadow + adjustment
				if tone1.frequency_shadow >= 2048 then
					tone1.frequency_shadow = 2047
					tone1.active = false
				end
				tone1.period = 32 * (2048 - tone1.frequency_shadow)
				tone1.frequency_shift_counter = tone1.frequency_shift_counter + 1
			end
		end
	end

	audio.noise4.update_lfsr = function(clock_cycle)
		--print(clock_cycle - audio.noise4.polynomial_last_shift)
		--print(audio.noise4.polynomial_period)
		while clock_cycle - audio.noise4.polynomial_last_shift > audio.noise4.polynomial_period do
			local lfsr = audio.noise4.polynomial_lfsr
			-- Grab the lowest two bits in LSFR and XOR them together
			local bit0 = bit32.band(lfsr, 0x1)
			local bit1 = bit32.rshift(bit32.band(lfsr, 0x2), 1)
			local xor = bit32.bxor(bit0, bit1)
			-- Shift LSFR down by one
			lfsr = bit32.rshift(lfsr, 1)
			-- Place the XOR'd bit into the high bit (14) always
			xor = bit32.lshift(xor, 14)
			lfsr = bit32.bor(xor, lfsr)
			if not audio.noise4.polynomial_wide then
				-- place the XOR'd bit into bit 6 as well
				xor = bit32.rshift(xor, 8)
				lfsr = bit32.bor(xor, bit32.band(lfsr, 0x7FBF))
			end
			audio.noise4.polynomial_last_shift = audio.noise4.polynomial_last_shift + audio.noise4.polynomial_period
			audio.noise4.polynomial_lfsr = lfsr
		end
	end

	audio.tone1.generate_sample = function(clock_cycle)
		audio.tone1.update_frequency_shift(clock_cycle)
		local tone1 = audio.tone1
		local duration = clock_cycle - tone1.base_cycle
		if tone1.continuous or (duration <= tone1.max_length) then
			local volume = tone1.volume_initial
			if tone1.volume_step_length > 0 then
				volume = volume + tone1.volume_direction * math.floor(duration / tone1.volume_step_length)
			end
			if volume > 0 then
				if volume > 0xF then
					volume = 0xF
				end

				while clock_cycle > tone1.frequency_last_update + 4 do
					tone1.period_counter = tone1.period_counter - 1
					if tone1.period_counter <= 0 then
						tone1.period_counter = (2048 - tone1.frequency_shadow)
						tone1.wave_duty_counter = tone1.wave_duty_counter + 1
						if tone1.wave_duty_counter >= 8 then
							tone1.wave_duty_counter = 0
						end
					end
					tone1.frequency_last_update = tone1.frequency_last_update + 4
				end

				if wave_pattern_tables[tone1.wave_pattern][tone1.wave_duty_counter + 1] == 0 then
					return volume / 0xF * -1
				else
					return volume / 0xF
				end
			end
		else
			audio.tone1.active = false
		end
		return 0
	end

	audio.tone2.generate_sample = function(clock_cycle)
		local tone2 = audio.tone2
		local duration = clock_cycle - tone2.base_cycle
		if tone2.continuous or (duration <= tone2.max_length) then
			local volume = tone2.volume_initial
			if tone2.volume_step_length > 0 then
				volume = volume + tone2.volume_direction * math.floor(duration / tone2.volume_step_length)
			end
			if volume > 0 then
				if volume > 0xF then
					volume = 0xF
				end

				while clock_cycle > tone2.frequency_last_update + 4 do
					tone2.period_counter = tone2.period_counter - 1
					if tone2.period_counter <= 0 then
						tone2.period_counter = (2048 - tone2.frequency_shadow)
						tone2.wave_duty_counter = tone2.wave_duty_counter + 1
						if tone2.wave_duty_counter >= 8 then
							tone2.wave_duty_counter = 0
						end
					end
					tone2.frequency_last_update = tone2.frequency_last_update + 4
				end

				if wave_pattern_tables[tone2.wave_pattern][tone2.wave_duty_counter + 1] == 0 then
					return volume / 0xF * -1
				else
					return volume / 0xF
				end
			end
		else
			tone2.active = false
		end
		return 0
	end

	audio.wave3.generate_sample = function(clock_cycle)
		local wave3 = audio.wave3
		local duration = clock_cycle - wave3.base_cycle
		if wave3.enabled then
			if wave3.continuous or (duration <= wave3.max_length) then
				--local period = wave3.period
				--local period_progress = (duration % period) / (period)
				--local sample_index = math.floor(period_progress * 32)
				while clock_cycle > wave3.frequency_last_update + 2 do
					wave3.period_counter = wave3.period_counter - 1
					if wave3.period_counter <= 0 then
						wave3.period_counter = (2048 - wave3.frequency_shadow)
						wave3.sample_index = wave3.sample_index + 1
						if wave3.sample_index >= 32 then
							wave3.sample_index = 0
						end
					end
					wave3.frequency_last_update = wave3.frequency_last_update + 2
				end

				local byte_index = bit32.rshift(wave3.sample_index, 1)
				local sample = io.ram[0x30 + byte_index]
				-- If this is an even numbered sample, shift the high nybble
				-- to the lower nybble
				if wave3.sample_index % 2 == 0 then
					sample = bit32.rshift(sample, 4)
				end
				-- Regardless, mask out the lower nybble; this becomes our sample to play
				sample = bit32.band(sample, 0x0F)
				-- Shift the sample based on the volume parameter
				sample = bit32.rshift(sample, wave3.volume_shift)
				-- This sample will be from 0-15, we need to adjust it so that it's from -1  to 1
				sample = (sample - 8) / 8
				return sample
			else
				wave3.active = false
			end
		else
			wave3.active = false
		end
		return 0
	end

	audio.noise4.generate_sample = function(clock_cycle)
		audio.noise4.update_lfsr(clock_cycle)
		local noise4 = audio.noise4
		local duration = clock_cycle - noise4.base_cycle
		if noise4.continuous or (duration <= noise4.max_length) then
			local volume = noise4.volume_initial
			if noise4.volume_step_length > 0 then
				volume = volume + noise4.volume_direction * math.floor(duration / noise4.volume_step_length)
			end
			if volume > 0 then
				if volume > 0xF then
					volume = 0xF
				end
				-- Output high / low is based on the INVERTED low bit of LFSR
				if bit32.band(noise4.polynomial_lfsr, 0x1) == 0 then
					return volume / 0xF
				else
					return volume / 0xF * -1
				end
			end
		else
			noise4.active = false
		end
		return 0
	end

	audio.__on_buffer_full = function(buffer) end

	audio.debug = {}
	audio.debug.current_sample = 0
	audio.debug.max_samples = 128
	audio.debug.tone1 = {}
	audio.debug.tone2 = {}
	audio.debug.wave3 = {}
	audio.debug.noise4 = {}
	audio.debug.final = {}
	for i = 0, audio.debug.max_samples do
		audio.debug.tone1[i] = 0
		audio.debug.tone2[i] = 0
		audio.debug.wave3[i] = 0
		audio.debug.noise4[i] = 0
		audio.debug.final[i] = 0
	end

	audio.save_debug_samples = function(tone1, tone2, wave3, noise4, final)
		local debug = audio.debug
		debug.tone1[debug.current_sample] = tone1
		debug.tone2[debug.current_sample] = tone2
		debug.wave3[debug.current_sample] = wave3
		debug.noise4[debug.current_sample] = noise4
		debug.final[debug.current_sample] = final
		debug.current_sample = debug.current_sample + 1
		if debug.current_sample >= debug.max_samples then
			debug.current_sample = 0
		end
	end

	audio.debug.enabled = false

	audio.generate_pending_samples = function()
		while next_sample_cycle < timers.system_clock do
			local tone1  = audio.tone1.generate_sample(next_sample_cycle)
			local tone2  = audio.tone2.generate_sample(next_sample_cycle)
			local wave3  = audio.wave3.generate_sample(next_sample_cycle)
			local noise4 = audio.noise4.generate_sample(next_sample_cycle)

			local sample_left = 0
			local sample_right = 0

			local channels_enabled = io.ram[ports.NR51]
			if bit32.band(channels_enabled, 0x80) ~= 0 and not audio.noise4.debug_disabled then
				sample_right = sample_right + noise4
			end
			if bit32.band(channels_enabled, 0x40) ~= 0 and not audio.wave3.debug_disabled  then
				sample_right = sample_right + wave3
			end
			if bit32.band(channels_enabled, 0x20) ~= 0 and not audio.tone2.debug_disabled  then
				sample_right = sample_right + tone2
			end
			if bit32.band(channels_enabled, 0x10) ~= 0 and not audio.tone1.debug_disabled  then
				sample_right = sample_right + tone1
			end

			if bit32.band(channels_enabled, 0x08) ~= 0 and not audio.noise4.debug_disabled  then
				sample_left = sample_left + noise4
			end
			if bit32.band(channels_enabled, 0x04) ~= 0 and not audio.wave3.debug_disabled  then
				sample_left = sample_left + wave3
			end
			if bit32.band(channels_enabled, 0x02) ~= 0 and not audio.tone2.debug_disabled  then
				sample_left = sample_left + tone2
			end
			if bit32.band(channels_enabled, 0x01) ~= 0 and not audio.tone1.debug_disabled  then
				sample_left = sample_left + tone1
			end

			sample_right = sample_right / 4
			sample_left = sample_left / 4

			if audio.debug.enabled then
				-- Debug in mono
				audio.save_debug_samples(tone1, tone2, wave3, noise4, (tone1 + tone2 + wave3 + noise4) / 4)
			end

			-- Left/Right Channel Volume
			local right_volume = bit32.rshift(bit32.band(io.ram[ports.NR50], 0x70), 4)
			local left_volume = bit32.band(io.ram[ports.NR50], 0x07)

			sample_right = sample_right * right_volume / 7
			sample_left = sample_left * left_volume / 7

			audio.buffer[next_sample] = sample_left
			next_sample = next_sample + 1
			audio.buffer[next_sample] = sample_right
			next_sample = next_sample + 1
			if next_sample >= 1024 then
				audio.__on_buffer_full(audio.buffer)
				next_sample = 0
			end
			next_sample_cycle = next_sample_cycle + 128 --number of clocks per sample at 32 KHz
		end
	end

	audio.on_buffer_full = function(callback)
		audio.__on_buffer_full = callback
	end

	audio.update = function()
		audio.generate_pending_samples()
	end

	return audio
end

return Audio
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDAA983947D544CD7891490C381C923B7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">cartridge</string>
						<string name="ScriptGuid">{4D0BCB7B-8249-489F-AC9C-6218472DF1A0}</string>
						<ProtectedString name="Source"><![CDATA[local gameboy = game.ReplicatedStorage.LuaGB.gameboy
local rom_header = require(gameboy.rom_header)

local MbcNone = require(gameboy.mbc.none)
local Mbc1 = require(gameboy.mbc.mbc1)
local Mbc2 = require(gameboy.mbc.mbc2)
local Mbc3 = require(gameboy.mbc.mbc3)
local Mbc5 = require(gameboy.mbc.mbc5)
local RTC = require(gameboy.rtc)

local Cartridge = {}

function Cartridge.new(modules)
	local cartridge = {}

	local io = modules.io
	local memory = modules.memory
	local ports = io.ports
	
	local rtc = RTC.new()
	
	local mbc_none = MbcNone.new()
	local mbc1 = Mbc1.new()
	local mbc2 = Mbc2.new()
	local mbc3 = Mbc3.new()
	local mbc5 = Mbc5.new()

	cartridge.external_ram = memory.generate_block(128 * 1024)
	cartridge.external_ram.dirty = false

	local mbc_mappings = {}
	mbc_mappings[0x00] = {mbc=mbc_none, options={}}
	mbc_mappings[0x01] = {mbc=mbc1, options={}}
	mbc_mappings[0x02] = {mbc=mbc1, options={}}
	mbc_mappings[0x03] = {mbc=mbc1, options={}}

	mbc_mappings[0x05] = {mbc=mbc2, options={}}
	mbc_mappings[0x06] = {mbc=mbc2, options={}}

	mbc_mappings[0x0F] = {mbc=mbc3, options={}}
	mbc_mappings[0x10] = {mbc=mbc3, options={}}
	mbc_mappings[0x12] = {mbc=mbc3, options={}}
	mbc_mappings[0x11] = {mbc=mbc3, options={}}
	mbc_mappings[0x13] = {mbc=mbc3, options={}}

	mbc_mappings[0x19] = {mbc=mbc5, options={}}
	mbc_mappings[0x1A] = {mbc=mbc5, options={}}
	mbc_mappings[0x1B] = {mbc=mbc5, options={}}
	mbc_mappings[0x1C] = {mbc=mbc5, options={rumble_pak=true}}
	mbc_mappings[0x1D] = {mbc=mbc5, options={rumble_pak=true}}
	mbc_mappings[0x1E] = {mbc=mbc5, options={rumble_pak=true}}

	cartridge.initialize = function(gameboy)
		cartridge.gameboy = gameboy
	end

	cartridge.load = function(file_data, size)
		print("Reading cartridge into memory...")
		cartridge.raw_data = {}
		for i = 0, size - 1 do
			cartridge.raw_data[i] = file_data:byte(i + 1)
		end
		print("Read " .. math.ceil(#cartridge.raw_data / 1024) .. " kB")
		cartridge.header = rom_header.parse_cartridge_header(cartridge.raw_data)
		rom_header.print_cartridge_header(cartridge.header)

		if mbc_mappings[cartridge.header.mbc_type] then
			local MBC = mbc_mappings[cartridge.header.mbc_type].mbc
			for k, v in pairs(mbc_mappings[cartridge.header.mbc_type].options) do
				MBC[k] = v
			end
			print("Using mapper: ", cartridge.header.mbc_name)
			MBC.raw_data = cartridge.raw_data
			MBC.external_ram = cartridge.external_ram
			MBC.header = cartridge.header
			-- Cart ROM
			memory.map_block(0x00, 0x7F, MBC)
			-- External RAM
			memory.map_block(0xA0, 0xBF, MBC, 0x0000)
		else
			local MBC = mbc_mappings[0x00].mbc
			print("Unsupported MBC type! Defaulting to ROM ONLY, game will probably not boot.")
			MBC.raw_data = cartridge.raw_data
			MBC.external_ram = cartridge.external_ram
			memory.map_block(0x00, 0x7F, MBC)
			memory.map_block(0xA0, 0xBF, MBC, 0x0000)
		end

		-- select a gameboy type based on the cart header
		if cartridge.header.color then
			cartridge.gameboy.type = cartridge.gameboy.types.color
		else
			cartridge.gameboy.type = cartridge.gameboy.types.dmg
		end

		-- Add a guard to cartridge.raw_data, such that any out-of-bounds reads return 0x00
		cartridge.raw_data.mt = {}
		cartridge.raw_data.mt.__index = function(table, address)
			-- Data doesn't exist? Tough luck; return 0x00
			return 0x00
		end

		setmetatable(cartridge.raw_data, cartridge.raw_data.mt)
	end

	cartridge.reset = function()
		if cartridge.header then
			-- Simulates a power cycle, resetting selected banks and other variables
			if mbc_mappings[cartridge.header.mbc_type] then
				mbc_mappings[cartridge.header.mbc_type].mbc:reset()
			else
				-- Calling this for logical completeness, but
				-- mbc_mappings[0x00] is actually type none,
				-- whose reset function is a no-op
				mbc_mappings[0x00].mbc:reset()
			end
		end

		-- TODO: Figure out if we care enough to reset
		-- External RAM here, for games which don't have
		-- a BATTERY in their cartridge type
	end

	cartridge.save_state = function()
		-- Note: for NOW, don't worry about the cartridge
		-- header, and assume a cart swap has not happened
		if mbc_mappings[cartridge.header.mbc_type] then
			return mbc_mappings[cartridge.header.mbc_type].mbc:save_state()
		else
			mbc_mappings[0x00].mbc:save_state()
		end
	end

	cartridge.load_state = function(state_data)
		-- Note: for NOW, don't worry about the cartridge
		-- header, and assume a cart swap has not happened
		if mbc_mappings[cartridge.header.mbc_type] then
			return mbc_mappings[cartridge.header.mbc_type].mbc:load_state(state_data)
		else
			mbc_mappings[0x00].mbc:load_state(state_data)
		end
	end

	return cartridge
end

return Cartridge
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7382A35EE1154CFEBACE17BB76E8596E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">dma</string>
						<string name="ScriptGuid">{86E35824-2126-4B4B-9BB4-BA4E7AF070D7}</string>
						<ProtectedString name="Source"><![CDATA[local Dma = {}

function Dma.new(modules)
	local dma = {}

	local io = modules.io
	local memory = modules.memory
	local timers = modules.timers
	local ports = io.ports

	dma.source = 0
	dma.destination = 0x8000
	dma.current = 0
	dma.length = 0
	dma.hblank = false
	dma.running = false

	dma.do_hblank = function()
		if dma.hblank then
			for i = 0, 0x10 - 1 do
				memory[dma.destination + i] = memory[dma.source + i]
			end
			dma.source = dma.source + 0x10;
			dma.destination = dma.destination + 0x10;
			dma.length = dma.length - 0x10;
			--print(string.format("HBlank Transfer of 0x10 bytes from %04X to %04X", dma.source, dma.destination))
			if dma.length <= 0 then
				dma.hblank = false
				io.ram[0x55] = 0xFF;
				--print("HBlank transfer finished!");
			else
				io.ram[0x55] = (dma.length / 0x10) - 1;
			end
			-- TODO: Implement clock delay for hblank DMA transfers
		end
	end

	io.write_logic[ports.DMA] = function(byte)
		-- DMA Transfer. Copies data from 0x0000 + 0x100 * byte, into OAM data
		local destmap = memory.block_map[0xfe00]
		local sourcemap = memory.block_map[byte * 0x100]
		local source = 0x0000 + 0x100 * byte
		local destination = 0xFE00
		while destination <= 0xFE9F do
			destmap[destination] = sourcemap[source]
			destination = destination + 1
			source = source + 1
		end
		-- TODO: Implement memory access cooldown; real hardware requires
		-- programs to call DMA transfer from High RAM and then wait there
		-- for several clocks while it finishes.
	end

	io.write_logic[0x51] = function(byte)
		-- DMA source HIGH Byte
		dma.source = bit32.lshift(byte, 8) + bit32.band(dma.source, 0xFF)
	end

	io.write_logic[0x52] = function(byte)
		-- DMA source LOW byte (lower 4 bits ignored, forces alignment to 0x10
		dma.source = bit32.band(dma.source, 0xFF00) + bit32.band(byte, 0xF0)
	end

	io.write_logic[0x53] = function(byte)
		-- DMA destination HIGH byte (upper 3 bits ignored, forced to reside within 0x8000 - 0x9FFF)
		dma.destination = 0x8000 + bit32.lshift(bit32.band(byte, 0x1F), 8) + bit32.band(dma.destination, 0xFF)
	end

	io.write_logic[0x54] = function(byte)
		-- DMA destination LOW byte (lower 4 bits ignored, forces alignment to 0x10
		dma.destination = bit32.band(dma.destination, 0xFF00) + bit32.band(byte, 0xF0)
	end

	io.write_logic[0x55] = function(byte)
		--dma.source = bit32.lshift(io.ram[0x51], 8) + bit32.band(io.ram[0x52], 0xF0)
		--dma.destination = bit32.lshift(bit32.band(io.ram[0x53], 0x1F), 8) + bit32.band(io.ram[0x54], 0xF0) + 0x8000
		dma.length = (bit32.band(byte, 0x7F) + 1) * 16
		if bit32.band(byte, 0x80) ~= 0 then
			dma.hblank = true
			io.ram[0x55] = bit32.band(byte, 0x7F)
			--print(string.format("HBlank DMA from 0x%04X to 0x%04X with length 0x%04X", dma.source, dma.destination, dma.length))
			-- is the screen off, or are we in the middle of hblank? If so, copy a block right away
			current_mode = bit32.band(io.ram[ports.STAT], 0x3)
			display_disabled = bit32.band(io.ram[ports.LCDC], 0x80) == 0
			if current_mode == 0 or display_disabled then
				dma.do_hblank()
			end
		else
			if dma.hblank then
				--print("Stopped an HBlank DMA in progress!")
				-- Terminate the hblank DMA in progress. Do NOT start a general purpose DMA on this write.
				dma.hblank = false
				io.ram[0x55] = bit32.bor(io.ram[0x55], 0x80);
				return
			end
			dma.hblank = false
			-- process the DMA now, adjust clock too. (cheat, basically.)
			for i = 0, dma.length - 1 do
				memory[dma.destination + i] = memory[dma.source + i]
			end
			dma.destination = dma.destination + dma.length

			timers.system_clock = timers.system_clock + dma.length / 2
			io.ram[0x55] = 0xFF
			--print(string.format("General Purpose DMA From: %04X -> %04X Length: %04X", dma.source, dma.destination, dma.length))
		end
	end

	return dma
end

return Dma
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB6A137BCFC014CB2A6E623F6EB7E4519">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">init</string>
						<string name="ScriptGuid">{8E33F481-D7B7-4A5E-8679-D2510662A4A5}</string>
						<ProtectedString name="Source"><![CDATA[local Gameboy = {}

local gameboy = game.ReplicatedStorage.LuaGB.gameboy

Gameboy.audio = require(gameboy.audio)
Gameboy.cartridge = require(gameboy.cartridge)
Gameboy.dma = require(gameboy.dma)
Gameboy.graphics = require(gameboy.graphics.init)
Gameboy.input = require(gameboy.input)
Gameboy.interrupts = require(gameboy.interrupts)
Gameboy.io = require(gameboy.io)
Gameboy.memory = require(gameboy.memory)
Gameboy.timers = require(gameboy.timers)
Gameboy.processor = require(gameboy.z80.init)

function Gameboy:initialize()
	self.audio.initialize()
	self.graphics.initialize(self)
	self.cartridge.initialize(self)

	self:reset()
end

Gameboy.types = {}
Gameboy.types.dmg = 0
Gameboy.types.sgb = 1
Gameboy.types.color = 2

Gameboy.type = Gameboy.types.color

function Gameboy:reset()
	-- Resets the gameboy's internal state to just after the power-on and boot sequence
	-- (Does NOT unload the cartridge)

	-- Note: IO needs to come first here, as some subsequent modules
	-- manipulate IO registers during reset / initialization
	self.audio.reset()
	self.io.reset(self)
	self.memory.reset()
	self.cartridge.reset()
	self.graphics.reset() -- Note to self: this needs to come AFTER resetting IO
	self.timers:reset()
	self.processor.reset(self)

	self.interrupts.enabled = 1
end

function Gameboy:save_state()
	local state = {}
	state.audio = self.audio.save_state()
	state.cartridge = self.cartridge.save_state()
	state.io = self.io.save_state()
	state.memory = self.memory.save_state()
	state.graphics = self.graphics.save_state()
	state.timers = self.timers:save_state()
	state.processor = self.processor.save_state()

	-- Note: the underscore
	state.interrupts_enabled = self.interrupts.enabled
	return state
end

function Gameboy:load_state(state)
	self.audio.load_state(state.audio)
	self.cartridge.load_state(state.cartridge)
	self.io.load_state(state.io)
	self.memory.load_state(state.memory)
	self.graphics.load_state(state.graphics)
	self.timers:load_state(state.timers)
	self.processor.load_state(state.processor)

	-- Note: the underscore
	self.interrupts.enabled = state.interrupts_enabled
end

function Gameboy:step()
	self.timers:update()
	if self.timers.system_clock > self.graphics.next_edge then
		self.graphics.update()
	end
	self.processor.process_instruction()
	return
end

function Gameboy:run_until_vblank()
	local instructions = 0
	while self.io.ram[self.io.ports.LY] == 144 and instructions < 100000 do
		self:step()
		instructions = instructions + 1
	end
	while self.io.ram[self.io.ports.LY] ~= 144 and instructions < 100000  do
		self:step()
		instructions = instructions + 1
	end
	self.audio.update()
end

function Gameboy:run_until_hblank()
	local old_scanline = self.io.ram[self.io.ports.LY]
	local instructions = 0
	while old_scanline == self.io.ram[self.io.ports.LY] and instructions < 100000 do
		self:step()
		instructions = instructions + 1
	end
	self.audio.update()
end

local call_opcodes = {[0xCD]=true, [0xC4]=true, [0xD4]=true, [0xCC]=true, [0xDC]=true}
local rst_opcodes = {[0xC7]=true, [0xCF]=true, [0xD7]=true, [0xDF]=true, [0xE7]=true, [0xEF]=true, [0xF7]=true, [0xFF]=true}

function Gameboy:step_over()
	-- Make sure the *current* opcode is a CALL / RST
	local instructions = 0
	local pc = self.processor.registers.pc
	local opcode = self.memory[pc]
	if call_opcodes[opcode] then
		local return_address = bit32.band(pc + 3, 0xFFFF)
		while self.processor.registers.pc ~= return_address and instructions < 10000000 do
			self:step()
			instructions = instructions + 1
		end
		return
	end
	if rst_opcodes[opcode] then
		local return_address = bit32.band(pc + 1, 0xFFFF)
		while self.processor.registers.pc ~= return_address and instructions < 10000000 do
			self:step()
			instructions = instructions + 1
		end
		return
	end
	print("Not a CALL / RST opcode! Bailing.")
end

local ret_opcodes = {[0xC9]=true, [0xC0]=true, [0xD0]=true, [0xC8]=true, [0xD8]=true, [0xD9]=true}

function Gameboy:run_until_ret()
	local instructions = 0
	while ret_opcodes[self.memory[self.processor.registers.pc]] ~= true and instructions < 10000000 do
		self:step()
		instructions = instructions + 1
	end
end

local gameboy_defaults = {}
for k, v in pairs(Gameboy) do
	gameboy_defaults[k] = v
end

Gameboy.new = function(overrides)
	local new_gameboy = {}
	for k, v in pairs(gameboy_defaults) do
		if overrides[k] then
			new_gameboy[k] = overrides[k]
		else
			new_gameboy[k] = gameboy_defaults[k]
		end
	end

	new_gameboy.memory = new_gameboy.memory.new(new_gameboy)

	new_gameboy.io = new_gameboy.io.new(new_gameboy)

	new_gameboy.interrupts = new_gameboy.interrupts.new(new_gameboy)

	new_gameboy.timers = new_gameboy.timers.new(new_gameboy)

	new_gameboy.audio = new_gameboy.audio.new(new_gameboy)
	new_gameboy.cartridge = new_gameboy.cartridge.new(new_gameboy)
	new_gameboy.dma = new_gameboy.dma.new(new_gameboy)
	new_gameboy.graphics = new_gameboy.graphics.new(new_gameboy)
	new_gameboy.input = new_gameboy.input.new(new_gameboy)
	new_gameboy.processor = new_gameboy.processor.new(new_gameboy)

	new_gameboy:initialize()

	return new_gameboy
end

return Gameboy
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX152F9401242C4BD0B3C9BDA63E841EBF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">input</string>
						<string name="ScriptGuid">{DF43BADD-0B35-4D88-B3BD-FC8612F8C4D1}</string>
						<ProtectedString name="Source"><![CDATA[local Input = {}

function Input.new(modules)
	local memory = modules.memory
	local io = modules.io

	local input = {}

	input.keys = {}
	input.keys.Left = 0
	input.keys.Right = 0
	input.keys.Up = 0
	input.keys.Down = 0
	input.keys.A = 0
	input.keys.B = 0
	input.keys.Start = 0
	input.keys.Select = 0
	
	input.key_pressed = function() end
	
	input.update = function()
		local d_pad_bits = input.keys.Right +
			bit32.lshift(input.keys.Left, 1) +
			bit32.lshift(input.keys.Up, 2) +
			bit32.lshift(input.keys.Down, 3)
		local button_bits = input.keys.A +
			bit32.lshift(input.keys.B, 1) +
			bit32.lshift(input.keys.Select, 2) +
			bit32.lshift(input.keys.Start, 3)

		local active_bits = 0
		if bit32.band(io.ram[io.ports.JOYP], 0x20) == 0 then
			active_bits = bit32.bor(active_bits, button_bits)
		end
		if bit32.band(io.ram[io.ports.JOYP], 0x10) == 0 then
			active_bits = bit32.bor(active_bits, d_pad_bits)
		end
		active_bits = bit32.bnot(active_bits)

		io.ram[io.ports.JOYP] = bit32.bor(0xC0, bit32.band(io.ram[io.ports.JOYP], 0x30), bit32.band(active_bits, 0x0F))
	end

	local snes_packet_names = {}
	snes_packet_names[0x00] = "PAL 01"
	snes_packet_names[0x01] = "PAL 23"
	snes_packet_names[0x02] = "PAL 03"
	snes_packet_names[0x03] = "PAL 12"
	snes_packet_names[0x04] = "ATTR_BLK"
	snes_packet_names[0x05] = "ATTR_LIN"
	snes_packet_names[0x06] = "ATTR_DIV"
	snes_packet_names[0x07] = "ATTR_CHR"
	snes_packet_names[0x08] = "SOUND"
	snes_packet_names[0x09] = "SOU_TRN"
	snes_packet_names[0x0A] = "PAL_SET"
	snes_packet_names[0x0B] = "PAL_TRN"
	snes_packet_names[0x0C] = "ATRC_EN"
	snes_packet_names[0x0D] = "TEST_EN"
	snes_packet_names[0x0E] = "ICON_EN"
	snes_packet_names[0x0F] = "DATA_SND"
	snes_packet_names[0x10] = "DATA_TRN"
	snes_packet_names[0x11] = "MLT_REG"
	snes_packet_names[0x12] = "JUMP"
	snes_packet_names[0x13] = "CHR_TRN"
	snes_packet_names[0x14] = "PCT_TRN"
	snes_packet_names[0x15] = "ATTR_TRN"
	snes_packet_names[0x16] = "ATTR_SET"
	snes_packet_names[0x17] = "MASK_EN"
	snes_packet_names[0x18] = "OBJ_TRN"

	local decode_snes_command = function(command_bits)
		local command_bytes = {}
		for i = 0, 15 do
			command_bytes[i] = 0
			for b = 0, 7 do
				command_bytes[i] = command_bytes[i] + bit32.lshift(command_bits[8 * i + b], 8)
				command_bytes[i] = bit32.rshift(command_bytes[i], 1)

			end
		end

		local command = bit32.rshift(bit32.band(command_bytes[0], 0xF8), 3)
		local packet_length = bit32.band(command_bytes[0], 0x7)
		local parameters = {}
		for i = 1, 15 do
			parameters[i] = command_bytes[i]
		end
		return command, packet_length, parameters
	end

	local last_write = 0
	local command_bits = {}
	local command_started = false
	local command_index = 0

	local hex = function(str)
		return string.format("$%02X", str)
	end

	-- Register hooks for input-related registers
	io.write_logic[io.ports.JOYP] = function(byte)
		io.ram[io.ports.JOYP] = bit32.band(byte, 0x30)
		input.update()

		local pulse = bit32.rshift(bit32.band(byte, 0x30), 4)
		if command_started then
			if (pulse == 0x1 or pulse == 0x2) and last_write == 0x3 then
				if pulse == 0x2 then
					command_bits[command_index] = 0
				end
				if pulse == 0x1 then
					command_bits[command_index] = 1
				end
				command_index = command_index + 1
				if command_index > 128 then
					if command_bits[128] ~= 0 then
						print("Invalid command! 129th bit was not 0")
					end
					local command, length, parameters = decode_snes_command(command_bits)
					local command_name = snes_packet_names[command] or "UNKNOWN!!"
					print("SNES Command: " .. command_name .. " [" .. hex(command) .. "] Length: " .. length)
					local hex_params = hex(parameters[1])
					for i = 2, 15 do
						hex_params = hex_params .. " " .. hex(parameters[i])
					end
					print("SNES Parameters: ", hex_params)
					command_started = false
				end
			end
		else
			-- Check to see if we are starting a new command
			if pulse == 0x3 and last_write == 0x0 then
				command_started = true
				command_index = 0
			end
		end

		last_write = pulse
	end

	return input
end

return Input
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX346DA2AD2FDB421FA3405BB1B987C86D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">interrupts</string>
						<string name="ScriptGuid">{FE8C0D64-9833-41BA-A6FC-79AD0F66F82C}</string>
						<ProtectedString name="Source"><![CDATA[local Interrupts = {}

function Interrupts.new(modules)
	local interrupts = {}

	local io = modules.io

	interrupts.VBlank = 0x1
	interrupts.LCDStat = 0x2
	interrupts.Timer = 0x4
	interrupts.Serial = 0x8
	interrupts.Joypad = 0x16

	interrupts.enabled = 1

	interrupts.service_handler = function() end

	interrupts.enable = function()
		interrupts.enabled = 1
	end

	interrupts.disable = function()
		interrupts.enabled = 0
	end

	function interrupts.raise(bitmask)
		io.ram[0x0F] = bit32.band(bit32.bor(io.ram[0x0F], bitmask), 0x1F)
		interrupts.service_handler()
	end

	io.write_logic[io.ports.IF] = function(byte)
		io.ram[io.ports.IF] = byte
		if byte ~= 0 then
			interrupts.service_handler()
		end
	end

	io.write_logic[io.ports.IE] = function(byte)
		io.ram[io.ports.IE] = byte
		if byte ~= 0 then
			interrupts.service_handler()
		end
	end

	return interrupts
end

return Interrupts
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXEC6D9E6DF6FA44BFAD7AF875B392B171">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">io</string>
						<string name="ScriptGuid">{C9D2E070-213F-40CB-AD11-8A9E0ED60E48}</string>
						<ProtectedString name="Source"><![CDATA[local Io = {}

function Io.new(modules)
	local io = {}

	local memory = modules.memory

	local ports = {}
	-- Port names pulled from Pan Docs, starting here:
	-- http://bgb.bircd.org/pandocs.htm#videodisplay

	-- LCD Control
	ports.LCDC = 0x40

	-- LCD Status
	ports.STAT = 0x41

	-- BG Scroll
	ports.SCY = 0x42
	ports.SCX = 0x43
	
	-- Link Cable (i just have these bits here, i will probably never get them to work.)
	ports.LCONTROL = 0xFF02
	ports.LDATA = 0xFF01
	
	-- Current Scanline (LCDC Y-coordinate)
	ports.LY = 0x44
	-- LCD Compare, scanline on which a STAT interrupt is requested
	ports.LYC = 0x45

	-- B&W Palettes
	ports.BGP = 0x47
	ports.OBP0 = 0x48
	ports.OBP1 = 0x49

	-- Window Scroll
	ports.WY = 0x4A
	ports.WX = 0x4B

	-- Color-mode Palettes
	ports.BGPI = 0x68
	ports.BGPD = 0x69
	ports.OBPI = 0x6A
	ports.OBPD = 0x6B

	-- Color-mode VRAM Bank
	ports.VBK = 0x4F

	-- DMA Transfer Start (Write Only)
	ports.DMA = 0x46

	-- Joypad
	ports.JOYP = 0x00

	-- Timers
	ports.DIV = 0x04
	ports.TIMA = 0x05
	ports.TMA = 0x06
	ports.TAC = 0x07

	-- Interrupts
	ports.IE = 0xFF
	ports.IF = 0x0F

	-- Sound
	ports.NR10 = 0x10
	ports.NR11 = 0x11
	ports.NR12 = 0x12
	ports.NR13 = 0x13
	ports.NR14 = 0x14

	ports.NR21 = 0x16
	ports.NR22 = 0x17
	ports.NR23 = 0x18
	ports.NR24 = 0x19

	ports.NR30 = 0x1A
	ports.NR31 = 0x1B
	ports.NR32 = 0x1C
	ports.NR33 = 0x1D
	ports.NR34 = 0x1E

	ports.NR41 = 0x20
	ports.NR42 = 0x21
	ports.NR43 = 0x22
	ports.NR44 = 0x23

	ports.NR50 = 0x24
	ports.NR51 = 0x25
	ports.NR52 = 0x26

	io.ports = ports


	io.write_logic = {}
	io.read_logic = {}
	io.write_mask = {}

	io.ram = memory.generate_block(0x100)
	io.block = {}
	io.block.mt = {}
	io.block.mt.__index = function(table, address)
		address = address - 0xFF00
		if io.read_logic[address] then
			return io.read_logic[address]()
		else
			return io.ram[address]
		end
	end

	io.write_mask[ports.JOYP] = 0x30
	io.write_mask[ports.LY] = 0x00

	io.write_logic[0x70] = function(byte)
		if io.gameboy.type == io.gameboy.types.color then
			io.ram[0x70] = bit32.band(0x7, byte)
			memory.work_ram_1.bank = bit32.band(0x7, byte)
			if memory.work_ram_1.bank == 0 then
				memory.work_ram_1.bank = 1
			end
		else
			-- Not sure if the write mask should apply in DMG / SGB mode
			io.ram[0x70] = byte
		end
	end

	io.block.mt.__newindex = function(table, address, value)
		address = address - 0xFF00
		if io.write_mask[address] then
			local masked_value = bit32.band(value, io.write_mask[address])
			local masked_memory = bit32.band(io.ram[address], bit32.bnot(io.write_mask[address]))
			value = masked_value + masked_memory
		end
		if io.write_logic[address] then
			-- Some addresses (mostly IO ports) have fancy logic or do strange things on
			-- writes, so we handle those here.
			io.write_logic[address](value)
			return
		end
		io.ram[address] = value
	end

	io.reset = function(gameboy)
		io.gameboy = gameboy

		for i = 0, #io.ram do
			io.ram[i] = 0
		end

		-- Set io registers to post power-on values
		-- Sound Enable must be set to F1
		io.ram[0x26] = 0xF1

		io.ram[ports.LCDC] = 0x91
		io.ram[ports.BGP ] = 0xFC
		io.ram[ports.OBP0] = 0xFF
		io.ram[ports.OBP1] = 0xFF
	end

	io.save_state = function()
		local state = {}

		for i = 0, 0xFF do
			state[i] = io.ram[i]
		end

		return state
	end

	io.load_state = function(state)
		for i = 0, 0xFF do
			io.ram[i] = state[i]
		end
	end

	setmetatable(io.block, io.block.mt)
	memory.map_block(0xFF, 0xFF, io.block, 0)

	return io
end

return Io
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFCB6B1CFB43A47E9B51873913D1CD6F7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">memory</string>
						<string name="ScriptGuid">{EB64DB04-4433-4978-912F-C60F87B613B7}</string>
						<ProtectedString name="Source"><![CDATA[local Memory = {}

function Memory.new(modules)
	local memory = {}

	local block_map = {}
	memory.block_map = block_map

	memory.print_block_map = function()
		--debug
		print("Block Map: ")
		for b = 0, 0xFF do
			if block_map[bit32.lshift(b, 8)] then
				--print(string.format("Block at: %02X starts at %04X", b, block_map[bit32.lshift(b, 8)].start))
				print(block_map[bit32.lshift(b, 8)])
			end
		end
	end

	memory.map_block = function(starting_high_byte, ending_high_byte, mapped_block, starting_address)
		if starting_high_byte > 0xFF or ending_high_byte > 0xFF then
			print("Bad block, bailing", starting_high_byte, ending_high_byte)
			return
		end

		--starting_address = starting_address or bit32.lshift(starting_high_byte, 8)
		for i = starting_high_byte, ending_high_byte do
			--block_map[bit32.lshift(i, 8)] = {start=starting_address, block=mapped_block}
			block_map[bit32.lshift(i, 8)] = mapped_block
		end
	end

	memory.generate_block = function(size, starting_address)
		starting_address = starting_address or 0
		local block = {}
		for i = 0, size - 1 do
			block[starting_address + i] = 0
		end
		return block
	end

	-- Default, unmapped memory
	memory.unmapped = {}
	memory.unmapped.mt = {}
	memory.unmapped.mt.__index = function(table, key)
		return 0x00
	end
	memory.unmapped.mt.__newindex = function(table, key, value)
		-- Do nothing!
	end
	setmetatable(memory.unmapped, memory.unmapped.mt)
	memory.map_block(0, 0xFF, memory.unmapped)

	-- Main Memory
	memory.work_ram_0 = memory.generate_block(4 * 1024, 0xC000)
	memory.work_ram_1_raw = memory.generate_block(4 * 7 * 1024, 0xD000)
	memory.work_ram_1 = {}
	memory.work_ram_1.bank = 1
	memory.work_ram_1.mt = {}
	memory.work_ram_1.mt.__index = function(table, address)
		return memory.work_ram_1_raw[address + ((memory.work_ram_1.bank - 1) * 4 * 1024)]
	end
	memory.work_ram_1.mt.__newindex = function(table, address, value)
		memory.work_ram_1_raw[address + ((memory.work_ram_1.bank - 1) * 4 * 1024)] = value
	end
	setmetatable(memory.work_ram_1, memory.work_ram_1.mt)
	memory.map_block(0xC0, 0xCF, memory.work_ram_0, 0)
	memory.map_block(0xD0, 0xDF, memory.work_ram_1, 0)

	memory.work_ram_echo = {}
	memory.work_ram_echo.mt = {}
	memory.work_ram_echo.mt.__index = function(table, key)
		return memory.read_byte(key - 0xE000 + 0xC000)
	end
	memory.work_ram_echo.mt.__newindex = function(table, key, value)
		memory.write_byte(key - 0xE000 + 0xC000, value)
	end
	setmetatable(memory.work_ram_echo, memory.work_ram_echo.mt)
	memory.map_block(0xE0, 0xFD, memory.work_ram_echo, 0)

	memory.read_byte = function(address)
		local high_byte = bit32.band(address, 0xFF00)
		return block_map[high_byte][address]
	end

	memory.write_byte = function(address, byte)
		local high_byte = bit32.band(address, 0xFF00)
		block_map[high_byte][address] = byte
	end

	memory.reset = function()
		-- It's tempting to want to zero out all 0x0000-0xFFFF, but
		-- instead here we'll reset only that memory which this module
		-- DIRECTLY controls, so initialization logic can be performed
		-- elsewhere as appropriate.

		for i = 0xC000, 0xCFFF do
			memory.work_ram_0[i] = 0
		end

		for i = 0xD000, 0xDFFF do
			memory.work_ram_1[i] = 0
		end

		memory.work_ram_1.bank = 1
	end

	memory.save_state = function()
		local state = {}

		state.work_ram_0 = {}
		for i = 0xC000, 0xCFFF do
			state.work_ram_0[i] = memory.work_ram_0[i]
		end

		state.work_ram_1_raw = {}
		for i = 0xD000, (0xD000 + (4 * 7 * 1024) - 1) do
			state.work_ram_1_raw[i] = memory.work_ram_1_raw[i]
		end

		state.work_ram_1_bank = 1

		return state
	end

	memory.load_state = function(state)
		for i = 0xC000, 0xCFFF do
			memory.work_ram_0[i] = state.work_ram_0[i]
		end
		for i = 0xD000, (0xD000 + (4 * 7 * 1024) - 1) do
			memory.work_ram_1_raw[i] = state.work_ram_1_raw[i]
		end

		memory.work_ram_1.bank = state.work_ram_1_bank
	end

	-- Fancy: make access to ourselves act as an array, reading / writing memory using the above
	-- logic. This should cause memory[address] to behave just as it would on hardware.
	memory.mt = {}
	memory.mt.__index = function(table, key)
		return memory.read_byte(key)
	end
	memory.mt.__newindex = function(table, key, value)
		memory.write_byte(key, value)
	end
	setmetatable(memory, memory.mt)

	return memory
end

return Memory
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDF2CCDF1797641E69A4A06903981A05C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">opcode_names</string>
						<string name="ScriptGuid">{A2395DEF-9548-4DE3-B502-CCB5E469FCFD}</string>
						<ProtectedString name="Source"><![CDATA[local opcode_names = {}

opcode_names[0x00] = "nop"
opcode_names[0x01] = "ld BC, d16"
opcode_names[0x02] = "ld (BC), A"
opcode_names[0x03] = "inc BC"
opcode_names[0x04] = "inc B"
opcode_names[0x05] = "dec B"
opcode_names[0x06] = "ld B, d8"
opcode_names[0x07] = "rlca"
opcode_names[0x08] = "ld (a16), SP"
opcode_names[0x09] = "add HL, BC"
opcode_names[0x0A] = "ld A, (BC)"
opcode_names[0x0B] = "dec BC"
opcode_names[0x0C] = "inc C"
opcode_names[0x0D] = "dec C"
opcode_names[0x0E] = "ld C, d8"
opcode_names[0x0F] = "rrca"

opcode_names[0x10] = "STOP d8" -- Should ALWAYS be followed by 0x00
opcode_names[0x11] = "ld DE, d16"
opcode_names[0x12] = "ld (DE), A"
opcode_names[0x13] = "inc DE"
opcode_names[0x14] = "inc D"
opcode_names[0x15] = "dec D"
opcode_names[0x16] = "ld D, d8"
opcode_names[0x17] = "rla"
opcode_names[0x18] = "jr r8"
opcode_names[0x19] = "add HL, DE"
opcode_names[0x1A] = "ld A, (DE)"
opcode_names[0x1B] = "dec DE"
opcode_names[0x1C] = "inc E"
opcode_names[0x1D] = "dec E"
opcode_names[0x1E] = "ld E, d8"
opcode_names[0x1F] = "rra"

opcode_names[0x20] = "jr NZ, r8"
opcode_names[0x21] = "ld HL, d16"
opcode_names[0x22] = "ld (HL+), A"
opcode_names[0x23] = "inc HL"
opcode_names[0x24] = "inc H"
opcode_names[0x25] = "dec H"
opcode_names[0x26] = "ld H, d8"
opcode_names[0x27] = "dda"
opcode_names[0x28] = "jr Z, r8"
opcode_names[0x29] = "add HL, HL"
opcode_names[0x2A] = "ld A, (HL+)"
opcode_names[0x2B] = "dec HL"
opcode_names[0x2C] = "inc L"
opcode_names[0x2D] = "dec L"
opcode_names[0x2E] = "ld L, d8"
opcode_names[0x2F] = "cpl"

opcode_names[0x30] = "jr NC, r8"
opcode_names[0x31] = "ld SP, d16"
opcode_names[0x32] = "ld (HL-), A"
opcode_names[0x33] = "inc SP"
opcode_names[0x34] = "inc (HL)"
opcode_names[0x35] = "dec (HL)"
opcode_names[0x36] = "ld (HL), d8"
opcode_names[0x37] = "scf"
opcode_names[0x38] = "jr C, r8"
opcode_names[0x39] = "add HL, SP"
opcode_names[0x3A] = "ld A, (HL-)"
opcode_names[0x3B] = "dec SP"
opcode_names[0x3C] = "inc A"
opcode_names[0x3D] = "dec A"
opcode_names[0x3E] = "ld A, d8"
opcode_names[0x3F] = "ccf"

opcode_names[0x40] = "ld B, B"
opcode_names[0x41] = "ld B, C"
opcode_names[0x42] = "ld B, D"
opcode_names[0x43] = "ld B, E"
opcode_names[0x44] = "ld B, H"
opcode_names[0x45] = "ld B, L"
opcode_names[0x46] = "ld B, (HL)"
opcode_names[0x47] = "ld B, A"
opcode_names[0x48] = "ld C, B"
opcode_names[0x49] = "ld C, C"
opcode_names[0x4A] = "ld C, D"
opcode_names[0x4B] = "ld C, E"
opcode_names[0x4C] = "ld C, H"
opcode_names[0x4D] = "ld C, L"
opcode_names[0x4E] = "ld C, (HL)"
opcode_names[0x4F] = "ld C, A"

opcode_names[0x50] = "ld D, B"
opcode_names[0x51] = "ld D, C"
opcode_names[0x52] = "ld D, D"
opcode_names[0x53] = "ld D, E"
opcode_names[0x54] = "ld D, H"
opcode_names[0x55] = "ld D, L"
opcode_names[0x56] = "ld D, (HL)"
opcode_names[0x57] = "ld D, A"
opcode_names[0x58] = "ld E, B"
opcode_names[0x59] = "ld E, C"
opcode_names[0x5A] = "ld E, D"
opcode_names[0x5B] = "ld E, E"
opcode_names[0x5C] = "ld E, H"
opcode_names[0x5D] = "ld E, L"
opcode_names[0x5E] = "ld E, (HL)"
opcode_names[0x5F] = "ld E, A"

opcode_names[0x60] = "ld H, B"
opcode_names[0x61] = "ld H, C"
opcode_names[0x62] = "ld H, D"
opcode_names[0x63] = "ld H, E"
opcode_names[0x64] = "ld H, H"
opcode_names[0x65] = "ld H, L"
opcode_names[0x66] = "ld H, (HL)"
opcode_names[0x67] = "ld H, A"
opcode_names[0x68] = "ld L, B"
opcode_names[0x69] = "ld L, C"
opcode_names[0x6A] = "ld L, D"
opcode_names[0x6B] = "ld L, E"
opcode_names[0x6C] = "ld L, H"
opcode_names[0x6D] = "ld L, L"
opcode_names[0x6E] = "ld L, (HL)"
opcode_names[0x6F] = "ld L, A"

opcode_names[0x70] = "ld (HL), B"
opcode_names[0x71] = "ld (HL), C"
opcode_names[0x72] = "ld (HL), D"
opcode_names[0x73] = "ld (HL), E"
opcode_names[0x74] = "ld (HL), H"
opcode_names[0x75] = "ld (HL), L"
opcode_names[0x76] = "halt"
opcode_names[0x77] = "ld (HL), A"
opcode_names[0x78] = "ld A, B"
opcode_names[0x79] = "ld A, C"
opcode_names[0x7A] = "ld A, D"
opcode_names[0x7B] = "ld A, E"
opcode_names[0x7C] = "ld A, H"
opcode_names[0x7D] = "ld A, L"
opcode_names[0x7E] = "ld A, (HL)"
opcode_names[0x7F] = "ld A, A"

opcode_names[0x80] = "add A, B"
opcode_names[0x81] = "add A, C"
opcode_names[0x82] = "add A, D"
opcode_names[0x83] = "add A, E"
opcode_names[0x84] = "add A, H"
opcode_names[0x85] = "add A, L"
opcode_names[0x86] = "add A, (HL)"
opcode_names[0x87] = "add A, A"
opcode_names[0x88] = "adc A, B"
opcode_names[0x89] = "adc A, C"
opcode_names[0x8A] = "adc A, D"
opcode_names[0x8B] = "adc A, E"
opcode_names[0x8C] = "adc A, H"
opcode_names[0x8D] = "adc A, L"
opcode_names[0x8E] = "adc A, (HL)"
opcode_names[0x8F] = "adc A, A"

opcode_names[0x90] = "sub B"
opcode_names[0x91] = "sub C"
opcode_names[0x92] = "sub D"
opcode_names[0x93] = "sub E"
opcode_names[0x94] = "sub H"
opcode_names[0x95] = "sub L"
opcode_names[0x96] = "sub (HL)"
opcode_names[0x97] = "sub A"
opcode_names[0x98] = "sbc A, B"
opcode_names[0x99] = "sbc A, C"
opcode_names[0x9A] = "sbc A, D"
opcode_names[0x9B] = "sbc A, E"
opcode_names[0x9C] = "sbc A, H"
opcode_names[0x9D] = "sbc A, L"
opcode_names[0x9E] = "sbc A, (HL)"
opcode_names[0x9F] = "sbc A, A"

opcode_names[0xA0] = "and B"
opcode_names[0xA1] = "and C"
opcode_names[0xA2] = "and D"
opcode_names[0xA3] = "and E"
opcode_names[0xA4] = "and H"
opcode_names[0xA5] = "and L"
opcode_names[0xA6] = "and (HL)"
opcode_names[0xA7] = "and A"
opcode_names[0xA8] = "xor B"
opcode_names[0xA9] = "xor C"
opcode_names[0xAA] = "xor D"
opcode_names[0xAB] = "xor E"
opcode_names[0xAC] = "xor H"
opcode_names[0xAD] = "xor L"
opcode_names[0xAE] = "xor (HL)"
opcode_names[0xAF] = "xor A"

opcode_names[0xB0] = "or B"
opcode_names[0xB1] = "or C"
opcode_names[0xB2] = "or D"
opcode_names[0xB3] = "or E"
opcode_names[0xB4] = "or H"
opcode_names[0xB5] = "or L"
opcode_names[0xB6] = "or (HL)"
opcode_names[0xB7] = "or A"
opcode_names[0xB8] = "cp B"
opcode_names[0xB9] = "cp C"
opcode_names[0xBA] = "cp D"
opcode_names[0xBB] = "cp E"
opcode_names[0xBC] = "cp H"
opcode_names[0xBD] = "cp L"
opcode_names[0xBE] = "cp (HL)"
opcode_names[0xBF] = "cp A"

opcode_names[0xC0] = "ret NZ"
opcode_names[0xC1] = "pop BC"
opcode_names[0xC2] = "jp NZ, a16"
opcode_names[0xC3] = "jp a16"
opcode_names[0xC4] = "call NZ, a16"
opcode_names[0xC5] = "push BC"
opcode_names[0xC6] = "add A, d8"
opcode_names[0xC7] = "rst 0x00"
opcode_names[0xC8] = "ret Z"
opcode_names[0xC9] = "ret"
opcode_names[0xCA] = "jp Z, a16"
opcode_names[0xCB] = "xCB d8"
opcode_names[0xCC] = "call Z, a16"
opcode_names[0xCD] = "call a16"
opcode_names[0xCE] = "adc A, d8"
opcode_names[0xCF] = "rst 0x08"

opcode_names[0xD0] = "ret NC"
opcode_names[0xD1] = "pop DE"
opcode_names[0xD2] = "jp NC, a16"
opcode_names[0xD3] = "-- undefined --"
opcode_names[0xD4] = "call NC, a16"
opcode_names[0xD5] = "push DE"
opcode_names[0xD6] = "sub d8"
opcode_names[0xD7] = "rst 0x10"
opcode_names[0xD8] = "ret C"
opcode_names[0xD9] = "reti"
opcode_names[0xDA] = "jp C, a16"
opcode_names[0xDB] = "-- undefined --"
opcode_names[0xDC] = "call C, a16"
opcode_names[0xDD] = "-- undefined --"
opcode_names[0xDE] = "sbc A, d8"
opcode_names[0xDF] = "rst 0x18"

opcode_names[0xE0] = "ldh (a8), A"
opcode_names[0xE1] = "pop HL"
opcode_names[0xE2] = "ld (C), A"
opcode_names[0xE3] = "-- undefined --"
opcode_names[0xE4] = "-- undefined --"
opcode_names[0xE5] = "push HL"
opcode_names[0xE6] = "and d8"
opcode_names[0xE7] = "rst 0x20"
opcode_names[0xE8] = "add SP, r8"
opcode_names[0xE9] = "jp HL"
opcode_names[0xEA] = "ld (a16), A"
opcode_names[0xEB] = "-- undefined --"
opcode_names[0xEC] = "-- undefined --"
opcode_names[0xED] = "-- undefined --"
opcode_names[0xEE] = "xor d8"
opcode_names[0xEF] = "rst 0x28"

opcode_names[0xFF01] = "ld 0xFF01, A" -- Link Cable Serial R/W
opcode_names[0xFF02] = "ld 0xFF02, A" -- Link Cable Transfer Control R/W

opcode_names[0xF0] = "ldh A, (a8)"
opcode_names[0xF1] = "pop AF"
opcode_names[0xF2] = "ld (C), A"
opcode_names[0xF3] = "di"
opcode_names[0xF4] = "-- undefined --"
opcode_names[0xF5] = "push AF"
opcode_names[0xF6] = "or d8"
opcode_names[0xF7] = "rst 0x30"
opcode_names[0xF8] = "ld HL, SP + r8"
opcode_names[0xF9] = "ld SP, HL"
opcode_names[0xFA] = "ld A, (a16)"
opcode_names[0xFB] = "ei"
opcode_names[0xFC] = "-- undefined --"
opcode_names[0xFD] = "-- undefined --"
opcode_names[0xFE] = "cp d8"
opcode_names[0xFF] = "rst 0x38"

return opcode_names
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDACDC381935C411F8A8A643152F18535">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">rom_header</string>
						<string name="ScriptGuid">{AE95DF07-5198-449C-9C21-28CE1F3202FB}</string>
						<ProtectedString name="Source"><![CDATA[local rom_header = {}
-- given an entire rom (as a string reference),
-- print out the various header data for debugging

local function read_file_into_byte_array(file)
	local byte_array = {}
	local byte = file:read()
	local i = 0
	while byte do
		byte_array[i] = byte
		byte = file:read()
		i = i + 1
	end
	return byte_array
end

local function extract_string(data, s, e)
	local str = ""
	for i = s, e do
		if data[i] ~= 0 then
			str = str .. string.char(data[i])
		end
	end
	return str
end

rom_header.mbc_names = {}
rom_header.mbc_names[0x00] = "ROM ONLY"
rom_header.mbc_names[0x01] = "MBC1"
rom_header.mbc_names[0x02] = "MBC1+RAM"
rom_header.mbc_names[0x03] = "MBC1+RAM+BATTERY"
rom_header.mbc_names[0x05] = "MBC2"
rom_header.mbc_names[0x06] = "MBC2+BATTERY"

rom_header.parse_cartridge_header = function(data)
	local header = {}
	--convert the title data into a lua string
	header.title = extract_string(data, 0x134, 0x143)
	header.manufacturer = extract_string(data, 0x13F, 0x142)

	local cgb = (bit32.band(data[0x143], 0x80) ~= 0)
	if cgb then
		header.color = true
		header.title = extract_string(data, 0x134, 0x13E)
	else
		header.color = false
	end

	header.licencee = extract_string(data, 0x144, 0x145)

	local sgb = data[0x146] == 0x3
	if sgb then
		header.super_gameboy = true
	else
		header.super_gameboy = false
	end

	header.mbc_type = data[0x147]
	header.mbc_name = rom_header.mbc_names[header.mbc_type]

	local rom_size = data[0x148]
	if rom_size < 0x8 then
		header.rom_size = bit32.lshift(32 * 1024, rom_size)
	end

	local ram_size = data[0x149]
	if ram_size == 0 then
		header.ram_size = 0
	end
	if ram_size == 1 then
		header.ram_size = 2 * 1024
	end
	if ram_size == 2 then
		header.ram_size = 8 * 1024
	end
	if ram_size == 3 then
		header.ram_size = 32 * 1024
	end

	local japanese = data[0x14A]
	if japanese then
		header.japanese = false
	else
		header.japanese = true
	end

	header.licensee_code = data[0x14B]

	return header
end

rom_header.print_cartridge_header = function(header)
	print("Title: ", header.title)
	print("Manufacturer: ", header.manufacturer)

	if header.color then
		print("Color: YES")
	else
		print("Color: NO")
	end

	print("Licencee: ", header.licencee)

	if header.super_gameboy then
		print("SuperGB: YES")
	else
		print("SuperGB: NO")
	end

	if rom_header.mbc_names[header.mbc_type] then
		print("MBC Type: " .. rom_header.mbc_names[header.mbc_type])
	else
		print("MBC Type: UNKNOWN: ", string.format("0x%02X", header.mbc_type))
	end

	print("ROM Size: ", header.rom_size)
	print("RAM Size: ", header.ram_size)

	if header.japanese then
		print("Japanese: Hai")
	else
		print("Japanese: Iie")
	end

	print("Licensee Code: ", header.licensee_code)
end

return rom_header
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8CA2E766531349E48993302C1EFD93CA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">timers</string>
						<string name="ScriptGuid">{0E79B5B3-37F3-414D-8D9F-107FAC886BEE}</string>
						<ProtectedString name="Source"><![CDATA[local Timers = {}

function Timers.new(modules)
	local io = modules.io
	local interrupts = modules.interrupts

	local timers = {}

	local system_clocks_per_second = 4194304

	timers.system_clock = 0

	timers.clock_rates = {}

	function timers:set_normal_speed()
		self.clock_rates[0] = math.floor(system_clocks_per_second / 4096)
		self.clock_rates[1] = math.floor(system_clocks_per_second / 262144)
		self.clock_rates[2] = math.floor(system_clocks_per_second / 65536)
		self.clock_rates[3] = math.floor(system_clocks_per_second / 16384)
	end

	function timers:set_double_speed()
		self.clock_rates[0] = math.floor(system_clocks_per_second / 4096 / 2)
		self.clock_rates[1] = math.floor(system_clocks_per_second / 262144 / 2)
		self.clock_rates[2] = math.floor(system_clocks_per_second / 65536 / 2)
		self.clock_rates[3] = math.floor(system_clocks_per_second / 16384 / 2)
	end

	timers.div_base = 0
	timers.timer_offset = 0
	timers.timer_enabled = false

	io.write_logic[io.ports.DIV] = function(byte)
		-- Reset the DIV timer, in this case by re-basing it to the
		-- current system clock, which will roll it back to 0 on this cycle
		div_base = timers.system_clock
	end

	io.read_logic[io.ports.DIV] = function()
		return bit32.band(bit32.rshift(timers.system_clock - timers.div_base, 8), 0xFF)
	end

	io.write_logic[io.ports.TAC] = function(byte)
		io.ram[io.ports.TAC] = byte
		timers.timer_enabled = (bit32.band(io.ram[io.ports.TAC], 0x4) == 0x4)
		timers.timer_offset = timers.system_clock
	end

	function timers:update()
		if self.timer_enabled then
			local rate_select = bit32.band(io.ram[io.ports.TAC], 0x3)
			while self.system_clock > self.timer_offset + self.clock_rates[rate_select] do
				io.ram[io.ports.TIMA] = bit32.band(io.ram[io.ports.TIMA] + 1, 0xFF)
				self.timer_offset = self.timer_offset + self.clock_rates[rate_select]
				if io.ram[io.ports.TIMA] == 0x00 then
					--overflow happened, first reset TIMA to TMA
					io.ram[io.ports.TIMA] = io.ram[io.ports.TMA]
					--then, fire off the timer interrupt
					interrupts.raise(interrupts.Timer)
				end
			end
		end
	end

	function timers:reset()
		self.system_clock = 0
		self.div_base = 0
		self.timer_offset = 0
		self.timer_enabled = false
	end

	function timers:save_state()
		return {
			system_clock = self.system_clock,
			div_base = self.div_base,
			timer_offset = self.timer_offset,
			timer_enabled = self.timer_enabled}
	end

	function timers:load_state(state)
		self.system_clock = state.system_clock
		self.div_base = state.div_base
		self.timer_offset = state.timer_offset
		self.timer_enabled = state.timer_enabled
	end

	return timers
end

return Timers
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1D4EFEAD3C9A41DDA4DFE15B102F0783">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">rtc</string>
						<string name="ScriptGuid">{3653F087-9E5C-4C4F-A53C-4F9683057C7A}</string>
						<ProtectedString name="Source"><![CDATA[local gameboy = game.ReplicatedStorage.LuaGB.gameboy

local RTC = {}

function RTC.new(modules)
	local rtc = {}
	
	rtc.latch_enabled = false
	
	rtc.timezero = os.time()
	
	rtc.sec_latch = 0
	rtc.min_latch = 0
	rtc.hour_latch = 0
	rtc.day_latch_low = 0
	rtc.day_latch_high = 0
	rtc.day_carry = 0
	rtc.halt = 0
	
	rtc.latch_rtc = function(self)
		local delta_time = os.time() - self.timezero
		
		self.sec_latch = math.floor((delta_time % 60) + 0.5)
		self.min_latch = math.floor((delta_time / 60 % 60) + 0.5)
		self.hour_latch = math.floor((delta_time / 3600 % 24) + 0.5)
		local days = math.floor((delta_time / 3600 / 24) + 0.5)
		self.day_latch_low = bit32.band(days, 0xFF) 
		self.day_latch_high =  bit32.rshift(days, 8)
		
		if (self.day_latch_high > 1) then
			self.day_carry = 1
			self.day_latch_high = bit32.band(self.day_latch_high, 0b1) 
			self.timezero += 0x200 * 3600 * 24
		end
	end	
	
	rtc.write_command = function(self, value)
		if (value == 0x00) then
			self.latch_enabled = false
		elseif (value == 0x01) then
			if (not self.latch_enabled) then
				print("Latching RTC")
				self:latch_rtc()
			end
			self.latch_enabled = true
		else
			print("Invalid RTC Input: " .. value)
		end
	end
	
	rtc.get_register = function(self, register)
		if (not self.latch_enabled) then
			print("RTC attempted to get register, but latch is not enabled.")
		end
		
		if (register == 0x08) then
			return self.sec_latch
		elseif (register == 0x09) then
			return self.min_latch	
		elseif (register == 0x0A) then
			return self.hour_latch
		elseif (register == 0x0B) then
			return self.day_latch_low
		elseif (register == 0x0C) then
			local day_high = bit32.band(self.day_latch_high, 0b1)
			local halt = bit32.lshift(self.halt, 6)
			local day_carry = bit32.lshift(self.day_carry, 7)
			return day_high + halt + day_carry
		else
			print("Invalid RTC Register: "  .. register)
		end
	end
	
	rtc.set_register = function(self, register, value)
		if (not self.latch_enabled) then
			print("RTC attempted to set register, but latch is not enabled.")
		end
		
		local delta_time = os.time() - self.timezero
		
		if (register == 0x08) then
			self.timezero = self.timezero - math.floor((delta_time % 60) + 0.5) - value
		elseif (register == 0x09) then
			self.timezero = math.floor((delta_time / 60 % 60) + 0.5) - value
		elseif (register == 0x0A) then
			self.timezero = math.floor((delta_time / 3600 % 24) + 0.5) - value
		elseif (register == 0x0B) then
			self.timezero = math.floor((delta_time / 3600 / 24) + 0.5) - value
		elseif (register == 0x0C) then
			local day_high = bit32.band(value, 0b1)
			local halt = bit32.rshift(bit32.band(value, 0b1000000), 6)
			local day_carry = bit32.rshift(bit32.band(value, 0b10000000), 7)
			
			self.halt = halt
			if (self.halt == 0) then
				
			else
				print("Stopping RTC not implemented.")	
			end
			
			self.timezero = self.timezero - math.floor((delta_time / 3600 / 24) + 0.5) - (bit32.lshift(day_high, 8))
			self.day_carry  = day_carry
		else
			print("Invalid RTC Register: "  .. register .. ", " .. value)
		end
	end
	
	return rtc
end

return RTC
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXAC30A79D1D22446D8D8DC1F5F556CC3F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">vendor</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX62043DAC0646401BA20E4808CCA6D395">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">binser</string>
						<string name="ScriptGuid">{6D671570-3740-4269-B7EA-124DE3C954AA}</string>
						<ProtectedString name="Source"><![CDATA[-- binser.lua

--[[
Copyright (c) 2016 Calvin Rose

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

local assert = assert
local error = error
local select = select
local pairs = pairs
local getmetatable = getmetatable
local setmetatable = setmetatable
local tonumber = tonumber
local type = type
local loadstring = loadstring
local concat = table.concat
local char = string.char
local byte = string.byte
local format = string.format
local sub = string.sub
local dump = string.dump
local floor = math.floor
local frexp = math.frexp
local unpack = unpack or table.unpack

-- Lua 5.3 frexp polyfill
-- From https://github.com/excessive/cpml/blob/master/modules/utils.lua
if not frexp then
	local log, abs, floor = math.log, math.abs, math.floor
	local log2 = log(2)
	frexp = function(x)
		if x == 0 then return 0, 0 end
		local e = floor(log(abs(x)) / log2 + 1)
		return x / 2 ^ e, e
	end
end

-- NIL = 202
-- FLOAT = 203
-- TRUE = 204
-- FALSE = 205
-- STRING = 206
-- TABLE = 207
-- REFERENCE = 208
-- CONSTRUCTOR = 209
-- FUNCTION = 210
-- RESOURCE = 211
-- INT64 = 212

local mts = {}
local ids = {}
local serializers = {}
local deserializers = {}
local resources = {}
local resources_by_name = {}

local function pack(...)
	return {...}, select("#", ...)
end

local function not_array_index(x, len)
	return type(x) ~= "number" or x < 1 or x > len or x ~= floor(x)
end

local function type_check(x, tp, name)
	assert(type(x) == tp,
		format("Expected parameter %q to be of type %q.", name, tp))
end

local bigIntSupport = false
local isInteger
if math.type then -- Detect Lua 5.3
	local mtype = math.type
	bigIntSupport = loadstring[[
    local char = string.char
    return function(n)
        local nn = n < 0 and -(n + 1) or n
        local b1 = nn // 0x100000000000000
        local b2 = nn // 0x1000000000000 % 0x100
        local b3 = nn // 0x10000000000 % 0x100
        local b4 = nn // 0x100000000 % 0x100
        local b5 = nn // 0x1000000 % 0x100
        local b6 = nn // 0x10000 % 0x100
        local b7 = nn // 0x100 % 0x100
        local b8 = nn % 0x100
        if n < 0 then
            b1, b2, b3, b4 = 0xFF - b1, 0xFF - b2, 0xFF - b3, 0xFF - b4
            b5, b6, b7, b8 = 0xFF - b5, 0xFF - b6, 0xFF - b7, 0xFF - b8
        end
        return char(212, b1, b2, b3, b4, b5, b6, b7, b8)
    end]]()
	isInteger = function(x)
		return mtype(x) == 'integer'
	end
else
	isInteger = function(x)
		return floor(x) == x
	end
end

-- Copyright (C) 2012-2015 Francois Perrad.
-- number serialization code modified from https://github.com/fperrad/lua-MessagePack
-- Encode a number as a big-endian ieee-754 double, big-endian signed 64 bit integer, or a small integer
local function number_to_str(n)
	if isInteger(n) then -- int
		if n <= 100 and n >= -27 then -- 1 byte, 7 bits of data
			return char(n + 27)
		elseif n <= 8191 and n >= -8192 then -- 2 bytes, 14 bits of data
			n = n + 8192
			return char(128 + (floor(n / 0x100) % 0x100), n % 0x100)
		elseif bigIntSupport then
			return bigIntSupport(n)
		end
	end
	local sign = 0
	if n < 0.0 then
		sign = 0x80
		n = -n
	end
	local m, e = frexp(n) -- mantissa, exponent
	if m ~= m then
		return char(203, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
	elseif m == 1/0 then
		if sign == 0 then
			return char(203, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
		else
			return char(203, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
		end
	end
	e = e + 0x3FE
	if e < 1 then -- denormalized numbers
		m = m * 2 ^ (52 + e)
		e = 0
	else
		m = (m * 2 - 1) * 2 ^ 52
	end
	return char(203,
		sign + floor(e / 0x10),
		(e % 0x10) * 0x10 + floor(m / 0x1000000000000),
		floor(m / 0x10000000000) % 0x100,
		floor(m / 0x100000000) % 0x100,
		floor(m / 0x1000000) % 0x100,
		floor(m / 0x10000) % 0x100,
		floor(m / 0x100) % 0x100,
		m % 0x100)
end

-- Copyright (C) 2012-2015 Francois Perrad.
-- number deserialization code also modified from https://github.com/fperrad/lua-MessagePack
local function number_from_str(str, index)
	local b = byte(str, index)
	if b < 128 then
		return b - 27, index + 1
	elseif b < 192 then
		return byte(str, index + 1) + 0x100 * (b - 128) - 8192, index + 2
	end
	local b1, b2, b3, b4, b5, b6, b7, b8 = byte(str, index + 1, index + 8)
	if b == 212 then
		local flip = b1 >= 128
		if flip then -- negative
			b1, b2, b3, b4 = 0xFF - b1, 0xFF - b2, 0xFF - b3, 0xFF - b4
			b5, b6, b7, b8 = 0xFF - b5, 0xFF - b6, 0xFF - b7, 0xFF - b8
		end
		local n = ((((((b1 * 0x100 + b2) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
		if flip then
			return (-n) - 1, index + 9
		else
			return n, index + 9
		end
	end
	local sign = b1 > 0x7F and -1 or 1
	local e = (b1 % 0x80) * 0x10 + floor(b2 / 0x10)
	local m = ((((((b2 % 0x10) * 0x100 + b3) * 0x100 + b4) * 0x100 + b5) * 0x100 + b6) * 0x100 + b7) * 0x100 + b8
	local n
	if e == 0 then
		if m == 0 then
			n = sign * 0.0
		else
			n = sign * (m / 2 ^ 52) * 2 ^ -1022
		end
	elseif e == 0x7FF then
		if m == 0 then
			n = sign * (1/0)
		else
			n = 0.0/0.0
		end
	else
		n = sign * (1.0 + m / 2 ^ 52) * 2 ^ (e - 0x3FF)
	end
	return n, index + 9
end

local types = {}

types["nil"] = function(x, visited, accum)
	accum[#accum + 1] = "\202"
end

function types.number(x, visited, accum)
	accum[#accum + 1] = number_to_str(x)
end

function types.boolean(x, visited, accum)
	accum[#accum + 1] = x and "\204" or "\205"
end

function types.string(x, visited, accum)
	local alen = #accum
	if visited[x] then
		accum[alen + 1] = "\208"
		accum[alen + 2] = number_to_str(visited[x])
	else
		visited[x] = visited.next
		visited.next =  visited.next + 1
		accum[alen + 1] = "\206"
		accum[alen + 2] = number_to_str(#x)
		accum[alen + 3] = x
	end
end

local function check_custom_type(x, visited, accum)
	local res = resources[x]
	if res then
		accum[#accum + 1] = "\211"
		types[type(res)](res, visited, accum)
		return true
	end
	local mt = getmetatable(x)
	local id = mt and ids[mt]
	if id then
		if x == visited.temp then
			error("Infinite loop in constructor.")
		end
		visited.temp = x
		accum[#accum + 1] = "\209"
		types[type(id)](id, visited, accum)
		local args, len = pack(serializers[id](x))
		accum[#accum + 1] = number_to_str(len)
		for i = 1, len do
			local arg = args[i]
			types[type(arg)](arg, visited, accum)
		end
		visited[x] = visited.next
		visited.next = visited.next + 1
		return true
	end
end

function types.userdata(x, visited, accum)
	if visited[x] then
		accum[#accum + 1] = "\208"
		accum[#accum + 1] = number_to_str(visited[x])
	else
		if check_custom_type(x, visited, accum) then return end
		error("Cannot serialize this userdata.")
	end
end

function types.table(x, visited, accum)
	if visited[x] then
		accum[#accum + 1] = "\208"
		accum[#accum + 1] = number_to_str(visited[x])
	else
		if check_custom_type(x, visited, accum) then return end
		visited[x] = visited.next
		visited.next =  visited.next + 1
		local xlen = #x
		accum[#accum + 1] = "\207"
		accum[#accum + 1] = number_to_str(xlen)
		for i = 1, xlen do
			local v = x[i]
			types[type(v)](v, visited, accum)
		end
		local key_count = 0
		for k in pairs(x) do
			if not_array_index(k, xlen) then
				key_count = key_count + 1
			end
		end
		accum[#accum + 1] = number_to_str(key_count)
		for k, v in pairs(x) do
			if not_array_index(k, xlen) then
				types[type(k)](k, visited, accum)
				types[type(v)](v, visited, accum)
			end
		end
	end
end

types["function"] = function(x, visited, accum)
	if visited[x] then
		accum[#accum + 1] = "\208"
		accum[#accum + 1] = number_to_str(visited[x])
	else
		if check_custom_type(x, visited, accum) then return end
		visited[x] = visited.next
		visited.next =  visited.next + 1
		local str = string.dump(x)
		accum[#accum + 1] = "\210"
		accum[#accum + 1] = number_to_str(#str)
		accum[#accum + 1] = str
	end
end

types.cdata = function(x, visited, accum)
	if visited[x] then
		accum[#accum + 1] = "\208"
		accum[#accum + 1] = number_to_str(visited[x])
	else
		if check_custom_type(x, visited, #accum) then return end
		error("Cannot serialize this cdata.")
	end
end

types.thread = function() error("Cannot serialize threads.") end

local function deserialize_value(str, index, visited)
	local t = byte(str, index)
	if not t then return end
	if t < 128 then
		return t - 27, index + 1
	elseif t < 192 then
		return byte(str, index + 1) + 0x100 * (t - 128) - 8192, index + 2
	elseif t == 202 then
		return nil, index + 1
	elseif t == 203 then
		return number_from_str(str, index)
	elseif t == 204 then
		return true, index + 1
	elseif t == 205 then
		return false, index + 1
	elseif t == 206 then
		local length, dataindex = deserialize_value(str, index + 1, visited)
		local nextindex = dataindex + length
		local substr = sub(str, dataindex, nextindex - 1)
		visited[#visited + 1] = substr
		return substr, nextindex
	elseif t == 207 then
		local count, nextindex = number_from_str(str, index + 1)
		local ret = {}
		visited[#visited + 1] = ret
		for i = 1, count do
			ret[i], nextindex = deserialize_value(str, nextindex, visited)
		end
		count, nextindex = number_from_str(str, nextindex)
		for i = 1, count do
			local k, v
			k, nextindex = deserialize_value(str, nextindex, visited)
			v, nextindex = deserialize_value(str, nextindex, visited)
			ret[k] = v
		end
		return ret, nextindex
	elseif t == 208 then
		local ref, nextindex = number_from_str(str, index + 1)
		return visited[ref], nextindex
	elseif t == 209 then
		local count
		local name, nextindex = deserialize_value(str, index + 1, visited)
		count, nextindex = number_from_str(str, nextindex)
		local args = {}
		for i = 1, count do
			args[i], nextindex = deserialize_value(str, nextindex, visited)
		end
		local ret = deserializers[name](unpack(args))
		visited[#visited + 1] = ret
		return ret, nextindex
	elseif t == 210 then
		local length, dataindex = deserialize_value(str, index + 1, visited)
		local nextindex = dataindex + length
		local ret = loadstring(sub(str, dataindex, nextindex - 1))
		visited[#visited + 1] = ret
		return ret, nextindex
	elseif t == 211 then
		local res, nextindex = deserialize_value(str, index + 1, visited)
		return resources_by_name[res], nextindex
	elseif t == 212 then
		return number_from_str(str, index)
	else
		error("Could not deserialize type byte " .. t .. ".")
	end
end

local function serialize(...)
	local visited = {next = 1}
	local accum = {}
	for i = 1, select("#", ...) do
		local x = select(i, ...)
		types[type(x)](x, visited, accum)
	end
	return concat(accum)
end

local function make_file_writer(file)
	return setmetatable({}, {
		__newindex = function(_, _, v)
			file:write(v)
		end
	})
end

local function serialize_to_file(path, mode, ...)
	local file, err = io.open(path, mode)
	assert(file, err)
	local visited = {next = 1}
	local accum = make_file_writer(file)
	for i = 1, select("#", ...) do
		local x = select(i, ...)
		types[type(x)](x, visited, accum)
	end
	-- flush the writer
	file:flush()
	file:close()
end

local function writeFile(path, ...)
	return serialize_to_file(path, "wb", ...)
end

local function appendFile(path, ...)
	return serialize_to_file(path, "ab", ...)
end

local function deserialize(str, index)
	assert(type(str) == "string", "Expected string to deserialize.")
	local vals = {}
	index = index or 1
	local visited = {}
	local len = 0
	local val
	while index do
		val, index = deserialize_value(str, index, visited)
		if index then
			len = len + 1
			vals[len] = val
		end
	end
	return vals, len
end

local function deserializeN(str, n, index)
	assert(type(str) == "string", "Expected string to deserialize.")
	n = n or 1
	assert(type(n) == "number", "Expected a number for parameter n.")
	assert(n > 0 and floor(n) == n, "N must be a poitive integer.")
	local vals = {}
	index = index or 1
	local visited = {}
	local len = 0
	local val
	while index and len < n do
		val, index = deserialize_value(str, index, visited)
		if index then
			len = len + 1
			vals[len] = val
		end
	end
	vals[len + 1] = index
	return unpack(vals, 1, n + 1)
end

local function readFile(path)
	local file, err = io.open(path, "rb")
	assert(file, err)
	local str = file:read("*all")
	file:close()
	return deserialize(str)
end

local function default_deserialize(metatable)
	return function(...)
		local ret = {}
		for i = 1, select("#", ...), 2 do
			ret[select(i, ...)] = select(i + 1, ...)
		end
		return setmetatable(ret, metatable)
	end
end

local function default_serialize(x)
	assert(type(x) == "table",
		"Default serialization for custom types only works for tables.")
	local args = {}
	local len = 0
	for k, v in pairs(x) do
		args[len + 1], args[len + 2] = k, v
		len = len + 2
	end
	return unpack(args, 1, len)
end

-- Templating

local function normalize_template(template)
	local ret = {}
	for i = 1, #template do
		ret[i] = template[i]
	end
	local non_array_part = {}
	-- The non-array part of the template (nested templates) have to be deterministic, so they are sorted.
	-- This means that inherently non deterministicly sortable keys (tables, functions) should NOT be used
	-- in templates. Looking for way around this.
	for k in pairs(template) do
		if not_array_index(k, #template) then
			non_array_part[#non_array_part + 1] = k
		end
	end
	table.sort(non_array_part)
	for i = 1, #non_array_part do
		local name = non_array_part[i]
		ret[#ret + 1] = {name, normalize_template(template[name])}
	end
	return ret
end

local function templatepart_serialize(part, argaccum, x, len)
	local extras = {}
	local extracount = 0
	for k, v in pairs(x) do
		extras[k] = v
		extracount = extracount + 1
	end
	for i = 1, #part do
		extracount = extracount - 1
		if type(part[i]) == "table" then
			extras[part[i][1]] = nil
			len = templatepart_serialize(part[i][2], argaccum, x[part[i][1]], len)
		else
			extras[part[i]] = nil
			len = len + 1
			argaccum[len] = x[part[i]]
		end
	end
	if extracount > 0 then
		argaccum[len + 1] = extras
	else
		argaccum[len + 1] = nil
	end
	return len + 1
end

local function templatepart_deserialize(ret, part, values, vindex)
	for i = 1, #part do
		local name = part[i]
		if type(name) == "table" then
			local newret = {}
			ret[name[1]] = newret
			vindex = templatepart_deserialize(newret, name[2], values, vindex)
		else
			ret[name] = values[vindex]
			vindex = vindex + 1
		end
	end
	local extras = values[vindex]
	if extras then
		for k, v in pairs(extras) do
			ret[k] = v
		end
	end
	return vindex + 1
end

local function template_serializer_and_deserializer(metatable, template)
	return function(x)
		argaccum = {}
		local len = templatepart_serialize(template, argaccum, x, 0)
		return unpack(argaccum, 1, len)
	end, function(...)
		local ret = {}
		local len = select("#", ...)
		local args = {...}
		templatepart_deserialize(ret, template, args, 1)
		return setmetatable(ret, metatable)
	end
end

local function register(metatable, name, serialize, deserialize)
	name = name or metatable.name
	serialize = serialize or metatable._serialize
	deserialize = deserialize or metatable._deserialize
	if not serialize then
		if metatable._template then
			local t = normalize_template(metatable._template)
			serialize, deserialize = template_serializer_and_deserializer(metatable, t)
		elseif not deserialize then
			serialize = default_serialize
			deserialize = default_deserialize(metatable)
		else
			serialize = metatable
		end
	end
	type_check(metatable, "table", "metatable")
	type_check(name, "string", "name")
	type_check(serialize, "function", "serialize")
	type_check(deserialize, "function", "deserialize")
	assert(not ids[metatable], "Metatable already registered.")
	assert(not mts[name], ("Name %q already registered."):format(name))
	mts[name] = metatable
	ids[metatable] = name
	serializers[name] = serialize
	deserializers[name] = deserialize
	return metatable
end

local function unregister(item)
	local name, metatable
	if type(item) == "string" then -- assume name
		name, metatable = item, mts[item]
	else -- assume metatable
		name, metatable = ids[item], item
	end
	type_check(name, "string", "name")
	type_check(metatable, "table", "metatable")
	mts[name] = nil
	ids[metatable] = nil
	serializers[name] = nil
	deserializers[name] = nil
	return metatable
end

local function registerClass(class, name)
	name = name or class.name
	if class.__instanceDict then -- middleclass
		register(class.__instanceDict, name)
	else -- assume 30log or similar library
		register(class, name)
	end
	return class
end

local function registerResource(resource, name)
	type_check(name, "string", "name")
	assert(not resources[resource],
		"Resource already registered.")
	assert(not resources_by_name[name],
		format("Resource %q already exists.", name))
	resources_by_name[name] = resource
	resources[resource] = name
	return resource
end

local function unregisterResource(name)
	type_check(name, "string", "name")
	assert(resources_by_name[name], format("Resource %q does not exist.", name))
	local resource = resources_by_name[name]
	resources_by_name[name] = nil
	resources[resource] = nil
	return resource
end

return {
	-- aliases
	s = serialize,
	d = deserialize,
	dn = deserializeN,
	r = readFile,
	w = writeFile,
	a = appendFile,

	serialize = serialize,
	deserialize = deserialize,
	deserializeN = deserializeN,
	readFile = readFile,
	writeFile = writeFile,
	appendFile = appendFile,
	register = register,
	unregister = unregister,
	registerResource = registerResource,
	unregisterResource = unregisterResource,
	registerClass = registerClass
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX8757FAC998F442EFBD23D64039A1B77E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">init</string>
					<string name="ScriptGuid">{905581D3-B266-442B-B3A7-390EA62C7C93}</string>
					<ProtectedString name="Source"><![CDATA[local LuaGB = {}

LuaGB.Version = "ROBLOX PORT"

local binser = require(game.ReplicatedStorage.LuaGB.vendor.binser)
local gameboy = require(game.ReplicatedStorage.LuaGB.gameboy.init)

LuaGB.game_screen_image = nil
LuaGB.game_screen_imagedata = nil

local panels = {}

function LuaGB:from_hex(p1)
	return p1:gsub("..", function(p2)
		return string.char(tonumber(p2, 16))
	end)
end

function LuaGB:to_hex(p3)
	return p3:gsub(".", function(p4)
		return string.format("%02X", string.byte(p4))
	end)
end

LuaGB.TemporaryState = nil

function LuaGB:save_state(number)
	local state_data = self.gameboy:save_state()
	local filename = "states/" .. self.game_filename .. ".s" .. number
	--local state_string = binser.serialize(state_data)
	
	self.TemporaryState = state_data
end

function LuaGB:load_state(number)
	LuaGB:reset()
	LuaGB:load_game(LuaGB.game_path)

	local filename = "states/" .. self.game_filename .. ".s" .. number
	--local file_data = game.ReplicatedStorage.GetSaveData:InvokeServer()
	
	--local state_data, elements = binser.deserialize(file_data)
	if self.TemporaryState then
		self.gameboy:load_state(self.TemporaryState)
		print("Loaded state: ", filename)
	else
		print("Error parsing state data for ", filename)
	end
end
function LuaGB:play_gameboy_audio(buffer)
end

function LuaGB:reset()
	self.gameboy = gameboy.new{}
	self.gameboy:initialize()
	self.gameboy:reset()
	self.gameboy.audio.on_buffer_full(self.play_gameboy_audio)
	self.audio_dump_running = false
	self.emulator_running = false
	self.game_loaded = false

	-- Initialize Debug Panels
	for _, panel in pairs(panels) do
		panel.init(self.gameboy)
	end
end


function LuaGB:load_game(game_path)
	self:reset()

	local file_data = game_path
	if file_data then
		self.game_path = game_path
		self.game_filename = game_path
		while string.find(self.game_filename, "/") do
			self.game_filename = string.sub(self.game_filename, string.find(self.game_filename, "/") + 1)
		end
		
		self.gameboy.cartridge.load(file_data, #file_data or string.len(file_data))
		--self:load_ram()
		self.gameboy:reset()

		print("Successfully loaded ", self.game_filename)
	else
		print("Couldn't open ", game_path, " giving up.")
		return
	end

	--self.window_title = "LuaGB v" .. self.version .. " - " .. self.gameboy.cartridge.header.title
	
	self.menu_active = false
	self.emulator_running = true
	self.game_loaded = true
end

function LuaGB:draw_game_screen(dx, dy, scale, ui)
	local pixels = self.gameboy.graphics.game_screen
	
	for y = 0, 143 do
		for x = 0, 159 do
			ui:set_canvas_pixel(x, y, Color3.fromRGB(pixels[y][x][1], pixels[y][x][2], pixels[y][x][3]))
		end
	end
	
	return pixels
end

return LuaGB
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX1D36D0E026974706A1A9FC6E19F7BE92">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LICENSE</string>
					<string name="ScriptGuid">{A4EF7199-B481-4640-8569-74634185032C}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Copyright (c) 2016, Nicholas Flynt (aka zeta0134)
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	    * Neither the name of the author nor the names of its contributors 
	      may be used to endorse or promote products derived from this 
	      software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE AUTHOR NOR ANY CONTRIBUTORS BE LIABLE FOR ANY
	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
]]]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="RemoteFunction" referent="RBXF68721F2364B40A4B0EBE4D7D235EFC7">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">RawData</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="RemoteFunction" referent="RBX6A083553AF1D4772AAADE06481819881">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">SetSaveState</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="RemoteFunction" referent="RBX3023168650FD4EE79B57845F7EE439B2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">GetSaveState</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXCAB744173FD64C59BA1762CE0CB1F95D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">canvasController</string>
				<string name="ScriptGuid">{408AB71A-D327-4C66-BC33-76C083ED1DDB}</string>
				<ProtectedString name="Source"><![CDATA[local canvasController = {}
canvasController.__index = canvasController

canvasController.new = function(canvas, width, height)
	local canvasControllerMeta = setmetatable({}, canvasController)

	canvasControllerMeta.canvas = canvas
	canvasControllerMeta.width = width
	canvasControllerMeta.height = height

	canvasControllerMeta.rawPixelData = {}
	canvasControllerMeta.frameStorage = {}
	canvasControllerMeta.frames = {}

	for y = 0, height do
		canvasControllerMeta.rawPixelData[y] = {}		
		for x = 0, width do
			canvasControllerMeta.rawPixelData[y][x] = Color3.fromRGB(0,0,0)
		end
	end	

	return canvasControllerMeta
end

function canvasController:createFrame(x,y,sX,sY,color)
	local frame
	if (self.frameStorage[1]) then
		frame = self.frameStorage[1]
		table.remove(self.frameStorage, 1)
	end
	if (not frame) then
		frame = Instance.new("Frame")
		frame.BorderSizePixel = 0
		frame.ZIndex = 99
	end
	frame.Size = UDim2.new(0,sX,0,sY)
	frame.Name = sX.."x"..sY
	frame.Parent = self.canvas
	frame.Position = UDim2.new(0,x,0,y)
	frame.BackgroundColor3 = color

	return frame
end

function canvasController:draw()
	for _,frame in pairs(self.frames) do
		frame.Parent = nil
		table.insert(self.frameStorage, frame)
	end

	local optimizedPixelData = {}
	for y = 0, self.height do
		optimizedPixelData[y] = {}
		for x = 0, self.width do

			optimizedPixelData[y][x] = {
				Color = self.rawPixelData[y][x],
				Size = Vector2.new(1,1),
				Reference = nil
			}

			if (optimizedPixelData[y][x-1]) then
				if (optimizedPixelData[y][x-1].Color == optimizedPixelData[y][x].Color) then

					if (optimizedPixelData[y][x-1].Reference) then
						optimizedPixelData[y][x].Reference = optimizedPixelData[y][x-1].Reference
						optimizedPixelData[y][x-1].Reference.Size += Vector2.new(1,0)
					else
						optimizedPixelData[y][x].Reference = optimizedPixelData[y][x-1]
						optimizedPixelData[y][x-1].Size += Vector2.new(1,0)
					end
				end
			end

		end
	end

	for y = 0, self.height do
		for x = 0, self.width do
			if (optimizedPixelData[y] and optimizedPixelData[y][x]) then
				local pixel = optimizedPixelData[y][x]
				if (not pixel.Reference) then
					table.insert(self.frames, self:createFrame(x,y,pixel.Size.X,pixel.Size.Y,pixel.Color))
				end
			end
		end
	end
end

return canvasController]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="RemoteFunction" referent="RBXFB914BC22E7E42C390D8F06FD465EEF9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">LinkCableSerial</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX4FE310E7B5A24525A12687CB6893592B">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">UI</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXDEE8958F794046D7BCE998E1CEE14A9D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">init</string>
					<string name="ScriptGuid">{0F42DB5C-8A59-4124-B0C7-2BA4228C9D03}</string>
					<ProtectedString name="Source"><![CDATA[local UI = {}
UI.__index = UI

local gameboy = game.ReplicatedStorage.LuaGB.gameboy
local ui = game.ReplicatedStorage.UI

function UI:create_canvas(ui_parent, size_x, size_y)
	if (not ui_parent or not size_x or not size_y) then
		print("Invalid input for canvas creation.")
	end
	self.canvasPixels = {}
	self.canvas_width = size_x
	self.canvas_height = size_y
	self.canvasParent = ui_parent
	for y = 0, size_y do
		for x = 0, size_x do
			self:create_canvas_pixel(x,y,Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255)))
		end
		if (y%(math.floor(size_y/4 + 0.5)) == 0) then
			wait()
		end
	end	
end

function UI:create_canvas_pixel(x, y, color)
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0,1,0,1)
	frame.BorderSizePixel = 0
	frame.Name = "pixel"
	frame.Parent = self.canvasParent
	frame.Position = UDim2.new(0,x,0,y)
	frame.BackgroundColor3 = color
	frame.ZIndex = 99
	if (not self.canvasPixels[x]) then
		self.canvasPixels[x] = {}
	end
	if (self.canvasPixels[x][y]) then
		self.canvasPixels[x][y]:Destroy()
	end
	self.canvasPixels[x][y] = frame
end
 
function UI:get_canvas_pixel_color(x, y)
	if (self.canvasPixels[x] and self.canvasPixels[x][y]) then
		return self.canvasPixels[x][y].BackgroundColor3
	end
end

function UI:set_canvas_pixel(x, y, color, transparent)
	if (not transparent or transparent == 255) then
		if (self.canvasPixels[x] and self.canvasPixels[x][y]) then
			if (self.canvasPixels[x][y].BackgroundColor3 ~= color) then
				self.canvasPixels[x][y].BackgroundColor3 = color
			end
		else
			--self:create_canvas_pixel(x, y, color)
		end
	end
end

UI.new = function()
	local new_ui = setmetatable({}, UI)
	
	new_ui.image = require(ui.image).new(new_ui)

	return new_ui
end

return UI
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXF96D85C728E84F53B0F0429AFDBCA05A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">image</string>
					<string name="ScriptGuid">{ECA4B349-A58E-485E-AB50-7C921B775670}</string>
					<ProtectedString name="Source"><![CDATA[local Image = {}
Image.__index = Image

function Image:load_image(image_name, url)
	if self.cache[image_name] then
		return self.cache[image_name]
	end
	
	local buffer = game.ReplicatedStorage.RawData:InvokeServer(url)
	
	if (buffer) then
		local parsed_image = self.PNG.new(buffer)
		if (parsed_image) then
			self.cache[image_name] = parsed_image
		end
	end
end

function Image:get_pixel(x, y, image_name)
	if (not self.cache[image_name]) then
		print("Image has not been loaded: " .. image_name)
	end
	
	return self.cache[image_name]:GetPixel(x or 0, y or 0)
end

function Image:draw_image(x, y, image_name, raw_image_table)
	if (not self.cache[image_name]) then
		print("Image has not been loaded: " .. image_name)
	end
	
	local image_width = self.cache[image_name].Width
	local image_height = self.cache[image_name].Height
	
	
	for pX=1,image_width do
		for pY=1,image_height do
			local color, alpha = self.cache[image_name]:GetPixel(pX,pY)
			local r = color.r
			r = math.floor(r * 255 + 0.5)
			
			if (self.palette and raw_image_table[y+pY-1] and raw_image_table[y+pY-1][x+pX-1]) then								
				if r == 0 then
					color = self.palette[3]
				end
				if r == 64 then
					color = self.palette[2]
				end
				if r == 128 then
					color = self.palette[1]
				end
				if r == 255 then
					color = self.palette[0]
				end
				if r == 127 then
					local current_color = raw_image_table[y+pY-1][x+pX-1]
					if current_color == self.palette[2] then
						color = self.palette[3]
					end
					if current_color == self.palette[1] then
						color = self.palette[2]
					end
					if current_color == self.palette[0] then
						color = self.palette[1]
					end
				end
			end
			
			
			if (not raw_image_table) then
				self.canvas:set_canvas_pixel(x+pX-1,y+pY-1, color, alpha)
			else
				if (alpha == 255) then
					if (raw_image_table[y+pY-1] and raw_image_table[y+pY-1][x+pX-1]) then
						raw_image_table[y+pY-1][x+pX-1] = color
					end
				end
			end
		end
	end
end

Image.new = function(canvas)
	local new_image = setmetatable({}, Image)
	
	new_image.PNG = require(script.PNG)
	new_image.canvas = canvas
	new_image.cache = {}
	
	return new_image	
end

return Image]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX5F49675076534AA29DD0E51F0EFB34C1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PNG</string>
						<string name="ScriptGuid">{69268804-9696-4DB7-9A26-96D161AEF5A2}</string>
						<ProtectedString name="Source"><![CDATA[---------------------------------------------------------------------------------------------
-- @ CloneTrooper1019, 2019
---------------------------------------------------------------------------------------------
-- [PNG Library]
--
--  A module for opening PNG files into a readable bitmap.
--  This implementation works with most PNG files.
--
---------------------------------------------------------------------------------------------

local PNG = {}
PNG.__index = PNG

local chunks = script.Chunks
local modules = script.Modules

local Deflate = require(modules.Deflate)
local Unfilter = require(modules.Unfilter)
local BinaryReader = require(modules.BinaryReader)

local function getBytesPerPixel(colorType)
	if colorType == 0 or colorType == 3 then
		return 1
	elseif colorType == 4 then
		return 2
	elseif colorType == 2 then
		return 3
	elseif colorType == 6 then
		return 4
	else
		return 0
	end
end

local function clampInt(value, min, max)
	local num = tonumber(value) or 0
	num = math.floor(num + .5)
	
	return math.clamp(num, min, max)
end

local function indexBitmap(file, x, y)
	local width = file.Width
	local height = file.Height
	
	local x = clampInt(x, 1, width) 
	local y = clampInt(y, 1, height)
	
	local bitmap = file.Bitmap
	local bpp = file.BytesPerPixel
	
	local i0 = ((x - 1) * bpp) + 1
	local i1 = i0 + bpp
	
	return bitmap[y], i0, i1
end

function PNG:GetPixel(x, y)
	local row, i0, i1 = indexBitmap(self, x, y)
	local colorType = self.ColorType
	
	local color, alpha do
		if colorType == 0 then
			local gray = unpack(row, i0, i1)
			color = Color3.fromHSV(0, 0, gray)
			alpha = 255
		elseif colorType == 2 then
			local r, g, b = unpack(row, i0, i1)
			color = Color3.fromRGB(r, g, b)
			alpha = 255
		elseif colorType == 3 then
			local palette = self.Palette
			local alphaData = self.AlphaData
			
			local index = unpack(row, i0, i1)
			index = index + 1
			
			if palette then
				color = palette[index]
			end
			
			if alphaData then
				alpha = alphaData[index]
			end
		elseif colorType == 4 then
			local gray, a = unpack(row, i0, i1)
			color = Color3.fromHSV(0, 0, gray)
			alpha = a
		elseif colorType == 6 then
			local r, g, b, a = unpack(row, i0, i1)
			color = Color3.fromRGB(r, g, b, a)
			alpha = a
		end
	end
	
	if not color then
		color = Color3.new()
	end
	
	if not alpha then
		alpha = 255
	end
	
	return color, alpha
end

function PNG.new(buffer)
	-- Create the reader.
	local reader = BinaryReader.new(buffer)
	
	-- Create the file object.
	local file =
	{
		Chunks = {};
		Metadata = {};
		
		Reading = true;
		ZlibStream = "";
	}
	
	-- Verify the file header.
	local header = reader:ReadString(8)
	
	if header ~= "\137PNG\r\n\26\n" then
		error("PNG - Input data is not a PNG file.", 2)
	end
	
	while file.Reading do
		local length = reader:ReadInt32()
		local chunkType = reader:ReadString(4)
		
		local data, crc
		
		if length > 0 then
			data = reader:ForkReader(length)
			crc = reader:ReadUInt32()
		end
		
		local chunk = 
		{
			Length = length;
			Type = chunkType;
			
			Data = data;
			CRC = crc;
		}
		
		local handler = chunks:FindFirstChild(chunkType)
		
		if handler then
			handler = require(handler)
			handler(file, chunk)
		end
		
		table.insert(file.Chunks, chunk)
	end
	
	-- Decompress the zlib stream.
	local success, response = pcall(function ()
		local result = {}
		local index = 0
		
		Deflate:InflateZlib
		{
			Input = BinaryReader.new(file.ZlibStream);
			
			Output = function (byte)
				index = index + 1
				result[index] = string.char(byte)
			end
		}
		
		return table.concat(result)
	end)
	
	if not success then
		error("PNG - Unable to unpack PNG data. " .. tostring(response), 2)
	end
	
	-- Grab expected info from the file.
	
	local width = file.Width
	local height = file.Height
	
	local bitDepth = file.BitDepth
	local colorType = file.ColorType
	
	local buffer = BinaryReader.new(response)
	file.ZlibStream = nil
	
	local bitmap = {}
	file.Bitmap = bitmap
	
	local channels = getBytesPerPixel(colorType)
	file.NumChannels = channels
	
	local bpp = math.max(1, channels * (bitDepth / 8))
	file.BytesPerPixel = bpp
	
	-- Unfilter the buffer and 
	-- load it into the bitmap.
	
	for row = 1, height do	
		local filterType = buffer:ReadByte()
		local scanline = buffer:ReadBytes(width * bpp, true)
		
		bitmap[row] = {}
		
		if filterType == 0 then
			-- None
			Unfilter:None(scanline, bitmap, bpp, row)
		elseif filterType == 1 then
			-- Sub
			Unfilter:Sub(scanline, bitmap, bpp, row)
		elseif filterType == 2 then
			-- Up
			Unfilter:Up(scanline, bitmap, bpp, row)
		elseif filterType == 3 then
			-- Average
			Unfilter:Average(scanline, bitmap, bpp, row)
		elseif filterType == 4 then
			-- Paeth
			Unfilter:Paeth(scanline, bitmap, bpp, row)
		end
	end
	
	return setmetatable(file, PNG)
end

return PNG]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX48F081D981A14E37BD5151EDA923473F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Chunks</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX7558CE6AE9F242D3A9E358EA95DEEEC2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">IEND</string>
								<string name="ScriptGuid">{42FE4A9C-36E3-4D97-AC5B-B90CBFAE48F0}</string>
								<ProtectedString name="Source"><![CDATA[local function IEND(file)
	file.Reading = nil
end

return IEND]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX06B5D61683EB44EF98B8CE6C48F2E09F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">bKGD</string>
								<string name="ScriptGuid">{EA2C4A88-3323-41EB-85C0-9C63A8CFF36E}</string>
								<ProtectedString name="Source"><![CDATA[local function bKGD(file, chunk)
	local data = chunk.Data
	
	local bitDepth = file.BitDepth
	local colorType = file.ColorType
	
	bitDepth = (2 ^ bitDepth) - 1
	
	if colorType == 3 then
		local index = data:ReadByte()
		file.BackgroundColor = file.Palette[index]
	elseif colorType == 0 or colorType == 4 then
		local gray = data:ReadUInt16() / bitDepth
		file.BackgroundColor = Color3.fromHSV(0, 0, gray)
	elseif colorType == 2 or colorType == 6 then
		local r = data:ReadUInt16() / bitDepth
		local g = data:ReadUInt16() / bitDepth
		local b = data:ReadUInt16() / bitDepth
		file.BackgroundColor = Color3.new(r, g, b)
	end
end

return bKGD]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9FCF4089ADB841D99593C22FAEF299D8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">sRGB</string>
								<string name="ScriptGuid">{8391331B-01A8-4871-A759-E4D691797281}</string>
								<ProtectedString name="Source"><![CDATA[local function sRGB(file, chunk)
	local data = chunk.Data
	file.RenderIntent = data:ReadByte()
end

return sRGB]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3802EFC3B1B14C42A2F495E00E06D775">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">tRNS</string>
								<string name="ScriptGuid">{E67B6674-2AA9-4191-A2AC-EAC267731CFC}</string>
								<ProtectedString name="Source"><![CDATA[local function tRNS(file, chunk)
	local data = chunk.Data
	
	local bitDepth = file.BitDepth
	local colorType = file.ColorType
	
	bitDepth = (2 ^ bitDepth) - 1
	
	if colorType == 3 then
		local palette = file.Palette
		local alphaMap = {}
		
		for i = 1, #palette do
			local alpha = data:ReadByte()
			
			if not alpha then
				alpha = 255
			end
			
			alphaMap[i] = alpha
		end
		
		file.AlphaData = alphaMap
	elseif colorType == 0 then
		local grayAlpha = data:ReadUInt16()
		file.Alpha = grayAlpha / bitDepth
	elseif colorType == 2 then
		-- TODO: This seems incorrect...
		local r = data:ReadUInt16() / bitDepth
		local g = data:ReadUInt16() / bitDepth
		local b = data:ReadUInt16() / bitDepth
		file.Alpha = Color3.new(r, g, b)
	else
		error("PNG - Invalid tRNS chunk")
	end	
end

return tRNS]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX146A2EA4BD4147C7B7E4BE5668EE0E78">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">IHDR</string>
								<string name="ScriptGuid">{EAA6C9B2-4C09-48AF-BEC4-14663497B112}</string>
								<ProtectedString name="Source"><![CDATA[local function IHDR(file, chunk)
	local data = chunk.Data
	
	file.Width = data:ReadInt32();
	file.Height = data:ReadInt32();
	
	file.BitDepth = data:ReadByte();
	file.ColorType = data:ReadByte();
	
	file.Methods =
	{
		Compression = data:ReadByte();
		Filtering   = data:ReadByte();
		Interlace   = data:ReadByte();
	}
end

return IHDR]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA746E1D2DA9D44DDA4905A4D632E43AD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PLTE</string>
								<string name="ScriptGuid">{4F495F88-F6CB-4AAF-8DE7-82E2A14691AE}</string>
								<ProtectedString name="Source"><![CDATA[local function PLTE(file, chunk)
	if not file.Palette then
		file.Palette = {}
	end
	
	local data = chunk.Data
	local palette = data:ReadAllBytes()
	
	if #palette % 3 ~= 0 then
		error("PNG - Invalid PLTE chunk.")
	end
	
	for i = 1, #palette, 3 do
		local r = palette[i]
		local g = palette[i + 1]
		local b = palette[i + 2]
		
		local color = Color3.fromRGB(r, g, b)
		local index = #file.Palette + 1
		
		file.Palette[index] = color
	end
end

return PLTE]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE8399D40B1244CE1B7CC7747DA741292">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">tIME</string>
								<string name="ScriptGuid">{2EC4C071-DB5F-4B9F-B013-809C588E76AB}</string>
								<ProtectedString name="Source"><![CDATA[local function tIME(file, chunk)
	local data = chunk.Data
	
	local timeStamp = 
	{
		Year  = data:ReadUInt16();
		Month = data:ReadByte();
		Day   = data:ReadByte();
		
		Hour   = data:ReadByte();
		Minute = data:ReadByte();
		Second = data:ReadByte();
	}
	
	file.TimeStamp = timeStamp
end

return tIME]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1E3857B2D1194F14A9653138C2E25AE6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">IDAT</string>
								<string name="ScriptGuid">{02E98519-DA19-4498-80D3-240F08F168F9}</string>
								<ProtectedString name="Source"><![CDATA[local function IDAT(file, chunk)
	local crc = chunk.CRC
	local hash = file.Hash or 0
	
	local data = chunk.Data
	local buffer = data.Buffer
	
	file.Hash = bit32.bxor(hash, crc)
	file.ZlibStream = file.ZlibStream .. buffer
end

return IDAT]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC5D2BB064D68402D80DD1E869FC9CB8E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">gAMA</string>
								<string name="ScriptGuid">{0228A408-87CD-4A99-8BBC-FD6E16EF3843}</string>
								<ProtectedString name="Source"><![CDATA[local function gAMA(file, chunk)
	local data = chunk.Data
	local value = data:ReadUInt32()
	file.Gamma = value / 10e4
end

return gAMA]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFB4BDAA705AA46F49BE3FD5F86BF5065">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">cHRM</string>
								<string name="ScriptGuid">{8120E04C-A8A9-444E-A176-D385F58FB5A5}</string>
								<ProtectedString name="Source"><![CDATA[local colors = {"White", "Red", "Green", "Blue"}

local function cHRM(file, chunk)
	local chrome = {}
	local data = chunk.Data
	
	for i = 1, 4 do
		local color = colors[i]
		
		chrome[color] =
		{
			[1] = data:ReadUInt32() / 10e4;
			[2] = data:ReadUInt32() / 10e4;
		}
	end
	
	file.Chromaticity = chrome
end

return cHRM]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXAFD854DA9E394C8FBDBF1FFBB948ABA2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">tEXt</string>
								<string name="ScriptGuid">{941A630C-90B3-4428-8B0F-576DBB48AF5B}</string>
								<ProtectedString name="Source"><![CDATA[local function tEXt(file, chunk)
	local data = chunk.Data
	local key, value = "", ""
	
	for byte in data:IterateBytes() do
		local char = string.char(byte)
		
		if char == '\0' then
			key = value
			value = ""
		else
			value = value .. char
		end
	end
	
	file.Metadata[key] = value
end

return tEXt]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX5E5A575302934151A9933A1CA31F815B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Modules</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXF6A397B35BBB4E688A6A64DD871B0095">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">BinaryReader</string>
								<string name="ScriptGuid">{9081C0A9-2147-4690-8CF3-F8086D127F47}</string>
								<ProtectedString name="Source"><![CDATA[local BinaryReader = {}
BinaryReader.__index = BinaryReader

function BinaryReader.new(buffer)
	local reader = 
	{
		Position = 1;
		Buffer = buffer;
		Length = #buffer;
	}
	
	return setmetatable(reader, BinaryReader)
end

function BinaryReader:ReadByte()
	local buffer = self.Buffer
	local pos = self.Position
	
	if pos <= self.Length then
		local result = buffer:sub(pos, pos)
		self.Position = pos + 1
		
		return result:byte()
	end
end

function BinaryReader:ReadBytes(count, asArray)
	local values = {}
	
	for i = 1, count do
		values[i] = self:ReadByte()
	end
	
	if asArray then
		return values
	end
	
	return unpack(values)
end

function BinaryReader:ReadAllBytes()
	return self:ReadBytes(self.Length, true)
end

function BinaryReader:IterateBytes()
	return function ()
		return self:ReadByte()
	end
end

function BinaryReader:TwosComplementOf(value, numBits)
	if value >= (2 ^ (numBits - 1)) then
		value = value - (2 ^ numBits)
	end
	
	return value
end

function BinaryReader:ReadUInt16()
	local upper, lower = self:ReadBytes(2)
	return (upper * 256) + lower
end

function BinaryReader:ReadInt16()
	local unsigned = self:ReadUInt16()
	return self:TwosComplementOf(unsigned, 16)
end

function BinaryReader:ReadUInt32()
	local upper = self:ReadUInt16()
	local lower = self:ReadUInt16()
	
	return (upper * 65536) + lower
end

function BinaryReader:ReadInt32()
	local unsigned = self:ReadUInt32()
	return self:TwosComplementOf(unsigned, 32)
end

function BinaryReader:ReadString(length)
    if length == nil then
        length = self:ReadByte()
    end
    
    local pos = self.Position
    local nextPos = math.min(self.Length, pos + length)
    
    local result = self.Buffer:sub(pos, nextPos - 1)
    self.Position = nextPos
    
    return result
end

function BinaryReader:ForkReader(length)
	local chunk = self:ReadString(length)
	return BinaryReader.new(chunk)
end

return BinaryReader]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7A1FACD196AD434FB5BA85DE8A6CDB56">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Deflate</string>
								<string name="ScriptGuid">{3B782B4D-9266-471A-B3B6-0D7911B4A159}</string>
								<ProtectedString name="Source"><![CDATA[--[[

LUA MODULE

compress.deflatelua - deflate (and zlib) implemented in Lua.

DESCRIPTION

This is a pure Lua implementation of decompressing the DEFLATE format,
including the related zlib format.

Note: This library only supports decompression.
Compression is not currently implemented.

REFERENCES

[1] DEFLATE Compressed Data Format Specification version 1.3
http://tools.ietf.org/html/rfc1951
[2] GZIP file format specification version 4.3
http://tools.ietf.org/html/rfc1952
[3] http://en.wikipedia.org/wiki/DEFLATE
[4] pyflate, by Paul Sladen
http://www.paul.sladen.org/projects/pyflate/
[5] Compress::Zlib::Perl - partial pure Perl implementation of
Compress::Zlib
http://search.cpan.org/~nwclark/Compress-Zlib-Perl/Perl.pm

LICENSE

(c) 2008-2011 David Manura.  Licensed under the same terms as Lua (MIT).
    Heavily modified by Max G. (2019)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
(end license)
--]]

local Deflate = {}

local band = bit32.band
local lshift = bit32.lshift
local rshift = bit32.rshift

local BTYPE_NO_COMPRESSION = 0
local BTYPE_FIXED_HUFFMAN = 1
local BTYPE_DYNAMIC_HUFFMAN = 2

local lens = -- Size base for length codes 257..285
{
	[0] = 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258
}

local lext = -- Extra bits for length codes 257..285
{
	[0] = 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
	3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0
}

local dists = -- Offset base for distance codes 0..29
{
	[0] = 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	8193, 12289, 16385, 24577
}

local dext = -- Extra bits for distance codes 0..29
{
	[0] = 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
	7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
	12, 12, 13, 13
}

local order = -- Permutation of code length codes
{
	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 
	11, 4, 12, 3, 13, 2, 14, 1, 15
}

-- Fixed literal table for BTYPE_FIXED_HUFFMAN
local fixedLit = {0, 8, 144, 9, 256, 7, 280, 8, 288}

 -- Fixed distance table for BTYPE_FIXED_HUFFMAN
local fixedDist = {0, 5, 32}

local function createState(bitStream)
	local state = 
	{
		Output = bitStream;
		Window = {};
		Pos = 1;
	}
	
	return state
end

local function write(state, byte)
	local pos = state.Pos
	state.Output(byte)
	state.Window[pos] = byte
	state.Pos = pos % 32768 + 1  -- 32K
end

local function memoize(fn)
	local meta = {}
	local memoizer = setmetatable({}, meta)
	
	function meta:__index(k)
		local v = fn(k)
		memoizer[k] = v
		
		return v
	end
	
	return memoizer
end

-- small optimization (lookup table for powers of 2)
local pow2 = memoize(function (n) 
	return 2 ^ n 
end)

-- weak metatable marking objects as bitstream type
local isBitStream = setmetatable({}, { __mode = 'k' })

local function createBitStream(reader)
	local buffer = 0
	local bitsLeft = 0
	
	local stream = {}
	isBitStream[stream] = true
	
	function stream:GetBitsLeft()
		return bitsLeft
	end
	
	function stream:Read(count)
		count = count or 1
		
		while bitsLeft < count do
			local byte = reader:ReadByte()
			
			if not byte then 
				return 
			end
			
			buffer = buffer + lshift(byte, bitsLeft)
			bitsLeft = bitsLeft + 8
		end
		
		local bits
		
		if count == 0 then
			bits = 0
		elseif count == 32 then
			bits = buffer
			buffer = 0
		else
			bits = band(buffer, rshift(2^32 - 1, 32 - count))
			buffer = rshift(buffer, count)
		end
		
		bitsLeft = bitsLeft - count
		return bits
	end
	
	return stream
end

local function getBitStream(obj)
	if isBitStream[obj] then
		return obj
	end
	
	return createBitStream(obj)
end

local function sortHuffman(a, b)
	return a.NumBits == b.NumBits and a.Value < b.Value or a.NumBits < b.NumBits
end

local function msb(bits, numBits)
	local res = 0
		
	for i = 1, numBits do
		res = lshift(res, 1) + band(bits, 1)
		bits = rshift(bits, 1)
	end
		
	return res
end

local function createHuffmanTable(init, isFull)
	local hTable = {}
	
	if isFull then
		for val, numBits in pairs(init) do
			if numBits ~= 0 then
				hTable[#hTable + 1] = 
				{
					Value = val;
					NumBits = numBits;
				}
			end
		end
	else
		for i = 1, #init - 2, 2 do
			local firstVal = init[i]
			
			local numBits = init[i + 1]
			local nextVal = init[i + 2]
			
			if numBits ~= 0 then
				for val = firstVal, nextVal - 1 do
					hTable[#hTable + 1] = 
					{
						Value = val;
						NumBits = numBits;
					}
				end
			end
		end
	end
	
	table.sort(hTable, sortHuffman)
	
	local code = 1
	local numBits = 0
	
	for i, slide in ipairs(hTable) do
		if slide.NumBits ~= numBits then
			code = code * pow2[slide.NumBits - numBits]
			numBits = slide.NumBits
		end
		
		slide.Code = code
		code = code + 1
	end
	
	local minBits = math.huge
	local look = {}
	
	for i, slide in ipairs(hTable) do
		minBits = math.min(minBits, slide.NumBits)
		look[slide.Code] = slide.Value
	end

	local firstCode = memoize(function (bits) 
		return pow2[minBits] + msb(bits, minBits) 
	end)
	
	function hTable:Read(bitStream)
		local code = 1 -- leading 1 marker
		local numBits = 0
		
		while true do
			if numBits == 0 then  -- small optimization (optional)
				local index = bitStream:Read(minBits)
				numBits = numBits + minBits
				code = firstCode[index]
			else
				local bit = bitStream:Read()
				numBits = numBits + 1
				code = code * 2 + bit -- MSB first
			end
			
			local val = look[code]
			
			if val then
				return val
			end
		end
	end
	
	return hTable
end

local function parseZlibHeader(bitStream)
	-- Compression Method
	local cm = bitStream:Read(4)
	
	-- Compression info
	local cinfo = bitStream:Read(4)  
	
	-- FLaGs: FCHECK (check bits for CMF and FLG)   
	local fcheck = bitStream:Read(5)
	
	-- FLaGs: FDICT (present dictionary)
	local fdict = bitStream:Read(1)
	
	-- FLaGs: FLEVEL (compression level)
	local flevel = bitStream:Read(2)
	
	-- CMF (Compresion Method and flags)
	local cmf = cinfo * 16  + cm
	
	-- FLaGs
	local flg = fcheck + fdict * 32 + flevel * 64 
	
	if cm ~= 8 then -- not "deflate"
		error("unrecognized zlib compression method: " .. cm)
	end
	
	if cinfo > 7 then
		error("invalid zlib window size: cinfo=" .. cinfo)
	end
	
	local windowSize = 2 ^ (cinfo + 8)
	
	if (cmf * 256 + flg) % 31 ~= 0 then
		error("invalid zlib header (bad fcheck sum)")
	end
	
	if fdict == 1 then
		error("FIX:TODO - FDICT not currently implemented")
	end
	
	return windowSize
end

local function parseHuffmanTables(bitStream)
	local numLits  = bitStream:Read(5) -- # of literal/length codes - 257
	local numDists = bitStream:Read(5) -- # of distance codes - 1
	local numCodes = bitStream:Read(4) -- # of code length codes - 4
	
	local codeLens = {}
	
	for i = 1, numCodes + 4 do
		local index = order[i]
		codeLens[index] = bitStream:Read(3)
	end
	
	codeLens = createHuffmanTable(codeLens, true)

	local function decode(numCodes)
		local init = {}
		local numBits
		local val = 0
		
		while val < numCodes do
			local codeLen = codeLens:Read(bitStream)
			local numRepeats
			
			if codeLen <= 15 then
				numRepeats = 1
				numBits = codeLen
			elseif codeLen == 16 then
				numRepeats = 3 + bitStream:Read(2)
			elseif codeLen == 17 then
				numRepeats = 3 + bitStream:Read(3)
				numBits = 0
			elseif codeLen == 18 then
				numRepeats = 11 + bitStream:Read(7)
				numBits = 0
			end
			
			for i = 1, numRepeats do
				init[val] = numBits
				val = val + 1
			end
		end
		
		return createHuffmanTable(init, true)
	end

	local numLitCodes = numLits + 257
	local numDistCodes = numDists + 1
	
	local litTable = decode(numLitCodes)
	local distTable = decode(numDistCodes)
	
	return litTable, distTable
end

local function parseCompressedItem(bitStream, state, litTable, distTable)
	local val = litTable:Read(bitStream)
	
	if val < 256 then -- literal
		write(state, val)
	elseif val == 256 then -- end of block
		return true
	else
		local lenBase = lens[val - 257]
		local numExtraBits = lext[val - 257]
		
		local extraBits = bitStream:Read(numExtraBits)
		local len = lenBase + extraBits
		
		local distVal = distTable:Read(bitStream)
		local distBase = dists[distVal]
		
		local distNumExtraBits = dext[distVal]
		local distExtraBits = bitStream:Read(distNumExtraBits)
		
		local dist = distBase + distExtraBits
		
		for i = 1, len do
			local pos = (state.Pos - 1 - dist) % 32768 + 1
			local byte = assert(state.Window[pos], "invalid distance")
			write(state, byte)
		end
	end
	
	return false
end

local function parseBlock(bitStream, state)
	local bFinal = bitStream:Read(1)
	local bType = bitStream:Read(2)
	
	if bType == BTYPE_NO_COMPRESSION then
		local left = bitStream:GetBitsLeft()
		bitStream:Read(left)
		
		local len = bitStream:Read(16)
		local nlen = bitStream:Read(16)

		for i = 1, len do
			local byte = bitStream:Read(8)
			write(state, byte)
		end
	elseif bType == BTYPE_FIXED_HUFFMAN or bType == BTYPE_DYNAMIC_HUFFMAN then
		local litTable, distTable

		if bType == BTYPE_DYNAMIC_HUFFMAN then
			litTable, distTable = parseHuffmanTables(bitStream)
		else
			litTable = createHuffmanTable(fixedLit)
			distTable = createHuffmanTable(fixedDist)
		end
		
		repeat until parseCompressedItem(bitStream, state, litTable, distTable)
	else
		error("unrecognized compression type")
	end

	return bFinal ~= 0
end

function Deflate:Inflate(io)
	local state = createState(io.Output)
	local bitStream = getBitStream(io.Input)
	
	repeat until parseBlock(bitStream, state)
end

function Deflate:InflateZlib(io)
	local bitStream = getBitStream(io.Input)
	local windowSize = parseZlibHeader(bitStream)
	
	self:Inflate
	{
		Input = bitStream;
		Output = io.Output;
	}
	
	local bitsLeft = bitStream:GetBitsLeft()
	bitStream:Read(bitsLeft)
end

return Deflate]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2368B1FC0E114C5AA8509BD7E174CC7C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Unfilter</string>
								<string name="ScriptGuid">{6CF373F1-F9ED-4733-83A8-BF63892332F5}</string>
								<ProtectedString name="Source"><![CDATA[local Unfilter = {}

function Unfilter:None(scanline, pixels, bpp, row)
	for i = 1, #scanline do
		pixels[row][i] = scanline[i]
	end
end

function Unfilter:Sub(scanline, pixels, bpp, row)
	for i = 1, bpp do
		pixels[row][i] = scanline[i]
	end
	
	for i = bpp + 1, #scanline do
		local x = scanline[i]
		local a = pixels[row][i - bpp]
		pixels[row][i] = bit32.band(x + a, 0xFF)
	end
end

function Unfilter:Up(scanline, pixels, bpp, row)
	if row > 1 then
		local upperRow = pixels[row - 1]
		
		for i = 1, #scanline do
			local x = scanline[i]
			local b = upperRow[i]
			pixels[row][i] = bit32.band(x + b, 0xFF)
		end
	else
		self:None(scanline, pixels, bpp, row)
	end
end

function Unfilter:Average(scanline, pixels, bpp, row)
	if row > 1 then
		for i = 1, bpp do
			local x = scanline[i]
			local b = pixels[row - 1][i]
			
			b = bit32.rshift(b, 1)
			pixels[row][i] = bit32.band(x + b, 0xFF)
		end
		
		for i = bpp + 1, #scanline do
			local x = scanline[i]
			local b = pixels[row - 1][i]
			
			local a = pixels[row][i - bpp]
			local ab = bit32.rshift(a + b, 1)
			
			pixels[row][i] = bit32.band(x + ab, 0xFF)
		end
	else
		for i = 1, bpp do
			pixels[row][i] = scanline[i]
		end
	
		for i = bpp + 1, #scanline do
			local x = scanline[i]
			local b = pixels[row - 1][i]
			
			b = bit32.rshift(b, 1)
			pixels[row][i] = bit32.band(x + b, 0xFF)
		end
	end
end

function Unfilter:Paeth(scanline, pixels, bpp, row)
	if row > 1 then
		local pr
		
		for i = 1, bpp do
			local x = scanline[i]
			local b = pixels[row - 1][i]
			pixels[row][i] = bit32.band(x + b, 0xFF)
		end
		
		for i = bpp + 1, #scanline do
			local a = pixels[row][i - bpp]
			local b = pixels[row - 1][i]
			local c = pixels[row - 1][i - bpp]
			
			local x = scanline[i]
			local p = a + b - c
			
			local pa = math.abs(p - a)
			local pb = math.abs(p - b)
			local pc = math.abs(p - c)
			
			if pa <= pb and pa <= pc then
				pr = a
			elseif pb <= pc then
				pr = b
			else
				pr = c
			end
			
			pixels[row][i] = bit32.band(x + pr, 0xFF)
		end
	else
		self:Sub(scanline, pixels, bpp, row)
	end
end

return Unfilter]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="RemoteFunction" referent="RBXFDCC35089F8646099321768F598F5610">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">GetROMs</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="RemoteFunction" referent="RBX88C4E1C962894BDF9FF23B6564DB63F0">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">SaveROM</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXB3CD8A9BE9EE43378D40FF651E38C506">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">ROMs</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="StringValue" referent="RBXDC9C5F6F038D4CC3AC9680BE3AB88993">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">gurbsadventure.gb</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<string name="Value">https://cdn.discordapp.com/attachments/800465522227544094/831275037465378826/GurbsAdventure.gb</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX88A6616D2B3D45CB9BEC3FC80EEA9CA3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">pk91.gb</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<string name="Value">https://cdn.discordapp.com/attachments/800465522227544094/831275534427619338/pk91.gb</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX0A54DBA6CDCF422B8CA0F587DB6D3B83">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">tir2.gb</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<string name="Value">https://cdn.discordapp.com/attachments/800465522227544094/831278522236010537/tir2.gb</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBXA6B3F0DBDFE14CF7B8B06EAD621999D4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">dcqid1.gb</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<string name="Value">https://cdn.discordapp.com/attachments/800465522227544094/831308447122587678/dcqid1.gb</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXFACAB586E4EF4800A263787A31449721">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">DisabledROMs</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="StringValue" referent="RBXE94F48711CD54D00B6071B9A84A76DD2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">deadeus.gb</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<string name="Value">https://cdn.discordapp.com/attachments/800465522227544094/830606346410786826/Deadeus.gb</string>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBX99FFA15FBE584E67954CAD1BD268CE4B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="GuidRegistryService" referent="RBX779357B4FE83412CA8EF907AB3C9E526">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX87D2F904F60442F7BC8E6A17C2352D4D">
		<Properties>
			<Color3 name="Ambient">
				<R>0.203921586</R>
				<G>0.203921586</G>
				<B>0.203921586</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.752941251</R>
				<G>0.752941251</G>
				<B>0.752941251</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">true</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.0470588282</R>
				<G>0.0470588282</G>
				<B>0.0470588282</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<float name="ShadowSoftness">0.200000003</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">2</token>
			<string name="TimeOfDay">06:00:00</string>
		</Properties>
		<Item class="Sky" referent="RBX21FD376FA83741D296F1BFA454EC4308">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="CelestialBodiesShown">false</bool>
				<float name="MoonAngularSize">0</float>
				<Content name="MoonTextureId"><url>rbxassetid://0</url></Content>
				<string name="Name">Sky</string>
				<Content name="SkyboxBk"><url>rbxassetid://3595370552</url></Content>
				<Content name="SkyboxDn"><url>rbxassetid://3595370552</url></Content>
				<Content name="SkyboxFt"><url>rbxassetid://3595370552</url></Content>
				<Content name="SkyboxLf"><url>rbxassetid://3595370552</url></Content>
				<Content name="SkyboxRt"><url>rbxassetid://3595370552</url></Content>
				<Content name="SkyboxUp"><url>rbxassetid://3595370552</url></Content>
				<int64 name="SourceAssetId">3595446009</int64>
				<int name="StarCount">0</int>
				<float name="SunAngularSize">0</float>
				<Content name="SunTextureId"><url>rbxassetid://0</url></Content>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
	<Item class="Teams" referent="RBX8FF3B9F1BAA6436B9D82D7B7948C5A8B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBXA915837AA12D44EBAA969212E324CC62">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBX86B98E8A47A04F3FBC09555A6E44BE6D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="Enabled">true</bool>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX49D839D1BCE44DE481F75CA26BDFBA2E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="HttpEnabled">true</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="LanguageService" referent="RBX0AE423C19FED47CA92350BDA7DFD8390">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LanguageService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="DataStoreService" referent="RBX9B8A0D1949F149C5A1E69ADD31D3D84A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutomaticRetry">true</bool>
			<bool name="LegacyNamingScheme">false</bool>
			<string name="Name">DataStoreService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>